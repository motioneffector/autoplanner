# REPORT-051-060: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #51-60 as specified in REPORT-SPEC.md.

---

## Violation #51: tests/13-reflow-algorithm.test.ts:1338

**Test Name:** `INV 3: chain bounds are hard constraints`

**Violation Line:**
```typescript
expect(result).toBeNull(); // No valid assignment possible
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies INV 3 from the reflow algorithm specification: "Chain bounds are hard constraints" (notes/testing-spec-13-reflow-algorithm.md:471). When a child's domain is outside the chain bounds, the search should fail (return null).

**What functionality or behavior is it verifying?**

The test verifies that:
1. A parent instance is created at 09:00 with 60-minute duration (lines 1317-1321)
2. A child instance is created with earlyWobble=0 and lateWobble=0 (lines 1322-1328)
3. The child's only available slot is 11:00 (line 1332) - outside the chain bounds
4. Parent ends at 10:00, so child should be at 10:00 (no wobble)
5. Since 11:00 is outside bounds, no solution exists
6. The search returns null (line 1338)

**Why does this specific test matter?**

Chain bounds ensure child tasks happen at the right time relative to parent:
- If bounds were soft, child could be scheduled at wrong time
- Hard bounds guarantee temporal relationships
- This maintains care chain integrity

**What are the consequences if this test is wrong or weak?**

The `toBeNull()` assertion is weak because:
1. It only verifies the result is null
2. It doesn't verify that a valid configuration WOULD succeed
3. Doesn't verify the reason for failure
4. Could pass if `backtrackSearch` always returns null

It could pass when:
- `backtrackSearch` is broken
- The domains are empty for other reasons
- The constraints aren't properly checked

**Why does getting it right matter?**

For medically fragile people:
- Chain bounds ensure care sequences are correct
- Medication after meal needs to happen at the right time
- Hard bounds prevent dangerous timing errors

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **INV 3** - notes/testing-spec-13-reflow-algorithm.md:471 states "INV 3: Chain bounds are hard constraints"

2. **Property Test** - notes/testing-spec-13-reflow-algorithm.md:492 states "PROPERTY: Chain bounds never violated (unless conflict reported)"

3. **Test Plan Reference** - notes/test-plan-13.md:195 states "INV 3 | chain bounds hard | Attempt violation"

4. **Hard Constraint Theorem** - notes/testing-spec-13-reflow-algorithm.md:442 states "THEOREM: If a valid arrangement exists that satisfies all hard constraints, the algorithm finds it"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('INV 3: chain bounds are hard constraints', () => {
  const parent = {
    seriesId: seriesId('A'),
    fixed: true,
    idealTime: datetime('2025-01-15T09:00:00'),
    duration: minutes(60),
  } as Instance;
  const child = {
    seriesId: seriesId('B'),
    fixed: false,
    parentId: seriesId('A'),
    earlyWobble: minutes(0),
    lateWobble: minutes(0),
  } as Instance;

  // First, verify that a VALID configuration DOES succeed
  const validDomains = new Map<Instance, LocalDateTime[]>();
  validDomains.set(parent, [datetime('2025-01-15T09:00:00')]);
  validDomains.set(child, [datetime('2025-01-15T10:00:00')]); // Within bounds
  const validConstraints = [{ type: 'chain', parent, child }];
  const validResult = backtrackSearch([parent, child], validDomains, validConstraints);
  expect(validResult).not.toBeNull();

  // Now test that invalid configuration fails
  const invalidDomains = new Map<Instance, LocalDateTime[]>();
  invalidDomains.set(parent, [datetime('2025-01-15T09:00:00')]);
  invalidDomains.set(child, [datetime('2025-01-15T11:00:00')]); // Outside bounds
  const invalidConstraints = [{ type: 'chain', parent, child }];
  const invalidResult = backtrackSearch([parent, child], invalidDomains, invalidConstraints);

  // INV 3: Should not find solution because child is outside bounds
  expect(invalidResult).toBeNull();
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(validResult).not.toBeNull()` - Valid config succeeds
2. `expect(invalidResult).toBeNull()` - Invalid config fails

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- First verifies a valid configuration succeeds
- Then verifies an invalid configuration fails
- Tests the contrast between valid and invalid
- Cannot pass if backtrackSearch always returns null
- Cannot pass if chain bounds aren't enforced

**What specific changes would transform this test into its ideal form?**

Add before line 1330:
```typescript
// First verify valid configuration succeeds
const validDomains = new Map<Instance, LocalDateTime[]>();
validDomains.set(parent, [datetime('2025-01-15T09:00:00')]);
validDomains.set(child, [datetime('2025-01-15T10:00:00')]); // Within bounds
const validResult = backtrackSearch([parent, child], validDomains, [{ type: 'chain', parent, child }]);
expect(validResult).not.toBeNull();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1320-1369 to examine the exact violation at line 1338 and full test context

3. **Search for INV 3 and chain bounds** - Used Grep tool with pattern `INV 3|chain bounds|hard constraint|LAW.*chain|chain.*hard` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 442: Theorem about hard constraints
   - Line 471: INV 3: Chain bounds are hard constraints

4. **Search test plan reference** - Used Grep tool with pattern `INV 3|chain bounds|hard constraint` in notes/test-plan-13.md, finding:
   - Line 185: Chain bounds respected tests
   - Line 195: INV 3 | chain bounds hard | Attempt violation

5. **Read invariants section** - Used Read tool on notes/testing-spec-13-reflow-algorithm.md lines 465-494 to find:
   - Line 471: INV 3 definition
   - Line 492: Property test for chain bounds

---

## Violation #52: tests/13-reflow-algorithm.test.ts:1385

**Test Name:** `simple daily schedule - 5 daily series non-overlapping`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // Non-overlapping - no conflicts expected
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that the reflow algorithm can schedule 5 non-overlapping daily series without conflicts. The series are at 09:00, 10:00, 11:00, 12:00, and 13:00 with 60-minute durations.

**What functionality or behavior is it verifying?**

The test verifies that:
1. 5 series are created with staggered times (lines 1375-1380)
2. Each is 60 minutes apart, so no overlap
3. Reflow is called (line 1383)
4. No conflicts should exist (line 1385)
5. All 5 series should be assigned (lines 1386-1389)
6. Each assignment should have a valid time format (lines 1390-1392)

**Why does this specific test matter?**

Basic scheduling must work:
- Non-overlapping schedules are the simplest case
- If this fails, the algorithm is fundamentally broken
- This is a sanity check for the reflow system

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify that conflicts WOULD be reported if they existed
3. It doesn't verify the series were actually scheduled
4. Could pass if reflow just returns empty conflicts always

Note: The subsequent assertions (lines 1386-1392) provide stronger verification of the schedule.

**Why does getting it right matter?**

For medically fragile people:
- Daily care tasks need to be scheduled correctly
- Non-overlapping schedules are the basic requirement
- Conflicts in simple cases would indicate serious bugs

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-13.md:207 states "simple daily schedule | 5 daily series | Valid non-overlapping schedule"

2. **Reflow Algorithm** - notes/testing-spec-13-reflow-algorithm.md defines the multi-phase reflow process

3. **INV 5** - notes/testing-spec-13-reflow-algorithm.md:473 states "INV 5: All conflicts reported (no silent failures)"

4. **Property Test** - notes/testing-spec-13-reflow-algorithm.md:489 states "PROPERTY: For randomly generated valid schedules, algorithm finds a solution"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('simple daily schedule - 5 daily series non-overlapping', () => {
  const series = Array.from({ length: 5 }, (_, i) =>
    createBasicSeries(`S${i}`, {
      idealTime: `2025-01-15T${String(9 + i).padStart(2, '0')}:00:00`,
      duration: 60,
    })
  );

  const input = createReflowInput(series);
  const result = reflow(input);

  // CRITICAL: First verify we have exactly 5 assignments
  expect(result.assignments).toHaveLength(5);

  // Then verify no conflicts
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);

  // Verify all series are assigned
  const assignedSeriesIds = result.assignments.map((a) => a.seriesId);
  expect(assignedSeriesIds).toHaveLength(5);
  expect(assignedSeriesIds).toEqual(expect.arrayContaining([
    seriesId('S0'), seriesId('S1'), seriesId('S2'), seriesId('S3'), seriesId('S4'),
  ]));

  // Verify times are valid and non-overlapping
  result.assignments.forEach((a) => {
    expect(a.time).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/);
  });

  // Verify non-overlapping by checking all times are different hours
  const hours = result.assignments.map(a => parseInt(a.time.substring(11, 13)));
  expect(new Set(hours).size).toBe(5); // All different hours
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(5)` - All scheduled
2. `expect(result.conflicts).toHaveLength(0)` - No conflicts
3. `expect(result.conflicts).toEqual([])` - Empty array
4. `expect(assignedSeriesIds).toHaveLength(5)` - All IDs present
5. `expect(new Set(hours).size).toBe(5)` - Non-overlapping

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all series are scheduled first
- Then verifies no conflicts
- Checks non-overlapping explicitly
- Cannot pass if reflow doesn't schedule all series
- Cannot pass if times overlap

**What specific changes would transform this test into its ideal form?**

Add before line 1385:
```typescript
// First verify all 5 series are assigned
expect(result.assignments).toHaveLength(5);
```

Replace line 1385:
```typescript
expect(result.conflicts).toHaveLength(0);
```

With:
```typescript
expect(result.conflicts).toHaveLength(0);
expect(result.conflicts).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1368-1417 to examine the exact violation at line 1385 and full test context

3. **Search for simple daily schedule** - Used Grep tool with pattern `simple daily schedule|non-overlapping|no conflicts|conflicts.*0|integration.*reflow` in notes/testing-spec-13-reflow-algorithm.md - no matches found

4. **Search test plan reference** - Used Grep tool with pattern `simple daily schedule|5 daily|non-overlapping|integration` in notes/test-plan-13.md, finding:
   - Line 207: "simple daily schedule | 5 daily series | Valid non-overlapping schedule"
   - Line 238: "Two non-overlapping | A 09:00, B 10:00 | Both at ideal times"

5. **Read test plan integration section** - Used Read tool on notes/test-plan-13.md lines 203-227 to find:
   - Lines 205-211: Full Reflow Scenarios test plan
   - Lines 215-219: Complex Scenarios test plan

---

## Violation #53: tests/13-reflow-algorithm.test.ts:1490

**Test Name:** `multiple chains - both chains scheduled`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // All constraints satisfied
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that the reflow algorithm can handle multiple independent chains (A→B and C→D) and schedule all of them without conflicts.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Four series are created: A (fixed at 09:00), B (child of A), C (fixed at 14:00), D (child of C) (lines 1471-1474)
2. Two chains are defined: A→B and C→D (lines 1477-1480)
3. Reflow is called (line 1484)
4. All four series are assigned (lines 1486-1489)
5. No conflicts exist (line 1490)

**Why does this specific test matter?**

Real schedules often have multiple chains:
- Morning routine chain
- Evening routine chain
- Multiple independent care sequences

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify chain relationships are respected
3. It doesn't verify children are scheduled after parents
4. Could pass if reflow returns empty conflicts always

Note: The assertion at lines 1486-1489 verifies all series are assigned.

**Why does getting it right matter?**

For medically fragile people:
- Multiple chains represent different care sequences
- Both chains must work correctly
- Failure could disrupt entire care schedule

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-13.md:217 states "multiple chains | A→B, C→D | Both chains scheduled"

2. **INV 3** - notes/testing-spec-13-reflow-algorithm.md:471 states "INV 3: Chain bounds are hard constraints"

3. **LAW 2 (Links)** - notes/testing-spec-11-links.md:69 states "LAW 2: Parent can have multiple children"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('multiple chains - both chains scheduled', () => {
  const input = createReflowInput(
    [
      createBasicSeries('A', { fixed: true, idealTime: '2025-01-15T09:00:00', duration: 60 }),
      createBasicSeries('B'),
      createBasicSeries('C', { fixed: true, idealTime: '2025-01-15T14:00:00', duration: 60 }),
      createBasicSeries('D'),
    ],
    {
      chains: [
        { parentId: seriesId('A'), childId: seriesId('B'), distance: 0, earlyWobble: 0, lateWobble: 30 },
        { parentId: seriesId('C'), childId: seriesId('D'), distance: 0, earlyWobble: 0, lateWobble: 30 },
      ],
    }
  );

  const result = reflow(input);

  // All 4 series should be assigned
  expect(result.assignments).toHaveLength(4);

  const assignedIds = result.assignments.map((a) => a.seriesId);
  expect(assignedIds).toEqual(expect.arrayContaining([
    seriesId('A'), seriesId('B'), seriesId('C'), seriesId('D'),
  ]));

  // No conflicts
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);

  // Verify chain relationships: B after A, D after C
  const getTime = (id: string) => result.assignments.find(a => a.seriesId === seriesId(id))!.time;
  expect(getTime('A') < getTime('B')).toBe(true);  // Chain 1 respected
  expect(getTime('C') < getTime('D')).toBe(true);  // Chain 2 respected

  // Verify chain bounds: B is within 30 min of A's end
  const aEnd = parseDateTime(getTime('A')).plus({ minutes: 60 });
  const bStart = parseDateTime(getTime('B'));
  expect(bStart >= aEnd && bStart <= aEnd.plus({ minutes: 30 })).toBe(true);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(4)` - All scheduled
2. `expect(assignedIds).toEqual(...)` - All IDs present
3. `expect(result.conflicts).toHaveLength(0)` - No conflicts
4. `expect(getTime('A') < getTime('B')).toBe(true)` - Chain 1 respected
5. `expect(getTime('C') < getTime('D')).toBe(true)` - Chain 2 respected

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all series are scheduled
- Verifies chain order is respected
- Verifies chain bounds are respected
- Cannot pass if chains are ignored
- Cannot pass if conflicts exist but aren't reported

**What specific changes would transform this test into its ideal form?**

Add before line 1486:
```typescript
// All 4 series should be assigned
expect(result.assignments).toHaveLength(4);
```

Add after line 1490:
```typescript
// Verify chain relationships
const getTime = (id: string) => result.assignments.find(a => a.seriesId === seriesId(id))!.time;
expect(getTime('A') < getTime('B')).toBe(true);
expect(getTime('C') < getTime('D')).toBe(true);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1470-1519 to examine the exact violation at line 1490 and full test context

3. **Search for multiple chains test plan** - Used Grep tool with pattern `multiple chains|both chains|A→B.*C→D` in notes/test-plan-13.md, finding:
   - Line 217: "multiple chains | A→B, C→D | Both chains scheduled"

---

## Violation #54: tests/13-reflow-algorithm.test.ts:1532

**Test Name:** `near-conflict - tight fit solution found`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // Tight fit but solution exists
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that the reflow algorithm can find solutions for "near-conflict" scenarios where the available window is exactly large enough to fit all tasks without overlap.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Three 1-hour tasks are created (lines 1520-1527)
2. All three want to be at 09:00 but have a window of 09:00-12:00 (3 hours)
3. With 3 tasks × 60 minutes = 180 minutes needed, and 180 minutes available, it's a tight fit
4. Reflow is called (line 1530)
5. No conflicts exist (line 1532) - algorithm should find the tight fit solution
6. All series are assigned (lines 1533-1536)
7. All are within the time window (lines 1538-1542)

**Why does this specific test matter?**

Near-conflict scenarios test the algorithm's ability to:
- Find solutions when space is tight
- Not falsely report conflicts when solutions exist
- Handle boundary cases effectively

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the solution is actually valid
3. It doesn't verify tasks don't overlap
4. Could pass if reflow ignores conflicts

Note: The subsequent assertions verify assignment completeness and time window bounds.

**Why does getting it right matter?**

For medically fragile people:
- Care schedules often have tight time constraints
- The algorithm must find valid solutions when they exist
- False conflicts could cause unnecessary scheduling failures

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-13.md:219 states "near-conflict | Tight fit | Solution found"

2. **Theorem** - notes/testing-spec-13-reflow-algorithm.md:442 states "THEOREM: If a valid arrangement exists that satisfies all hard constraints, the algorithm finds it"

3. **Property Test** - notes/testing-spec-13-reflow-algorithm.md:489 states "PROPERTY: For randomly generated valid schedules, algorithm finds a solution"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('near-conflict - tight fit solution found', () => {
  // Three 1-hour tasks in a 3-hour window (exact fit)
  const series = Array.from({ length: 3 }, (_, i) =>
    createBasicSeries(`S${i}`, {
      idealTime: '2025-01-15T09:00:00',
      duration: 60,
      timeWindowStart: '09:00',
      timeWindowEnd: '12:00',
    })
  );

  const input = createReflowInput(series);
  const result = reflow(input);

  // All 3 series should be assigned
  expect(result.assignments).toHaveLength(3);

  // No conflicts - tight fit but solution exists
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);

  // All series assigned
  const assignedIds = result.assignments.map((a) => a.seriesId);
  expect(assignedIds).toEqual(expect.arrayContaining([
    seriesId('S0'), seriesId('S1'), seriesId('S2'),
  ]));

  // Verify all assignments are within the time window
  result.assignments.forEach((a) => {
    const hour = parseInt(a.time.substring(11, 13));
    expect(hour).toBeGreaterThanOrEqual(9);
    expect(hour).toBeLessThanOrEqual(12);
  });

  // CRITICAL: Verify tasks don't overlap
  const times = result.assignments.map(a => ({
    start: parseDateTime(a.time),
    end: parseDateTime(a.time).plus({ minutes: 60 }),
  }));
  for (let i = 0; i < times.length; i++) {
    for (let j = i + 1; j < times.length; j++) {
      const overlaps = times[i].start < times[j].end && times[j].start < times[i].end;
      expect(overlaps).toBe(false);
    }
  }
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(3)` - All scheduled
2. `expect(result.conflicts).toHaveLength(0)` - No conflicts
3. `expect(assignedIds).toEqual(...)` - All IDs present
4. `expect(hour).toBeGreaterThanOrEqual(9)` - Within window
5. `expect(overlaps).toBe(false)` - No overlapping tasks

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all tasks are scheduled
- Verifies no conflicts
- Verifies time window bounds
- Verifies tasks don't overlap
- Cannot pass if algorithm fails to find tight fit
- Cannot pass if tasks overlap

**What specific changes would transform this test into its ideal form?**

Add before line 1532:
```typescript
// All 3 series should be assigned
expect(result.assignments).toHaveLength(3);
```

Add after line 1542:
```typescript
// Verify tasks don't overlap
const sortedTimes = result.assignments.map(a => a.time).sort();
for (let i = 0; i < sortedTimes.length - 1; i++) {
  const thisEnd = parseInt(sortedTimes[i].substring(11, 13)) + 1; // +1 hour
  const nextStart = parseInt(sortedTimes[i + 1].substring(11, 13));
  expect(thisEnd).toBeLessThanOrEqual(nextStart);
}
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1515-1564 to examine the exact violation at line 1532 and full test context

3. **Search for near-conflict test plan** - Used Grep tool with pattern `near-conflict|tight fit|tight.*solution|3-hour window|Tight fit` in notes/test-plan-13.md, finding:
   - Line 219: "near-conflict | Tight fit | Solution found"

---

## Violation #55: tests/13-reflow-algorithm.test.ts:1595

**Test Name:** `complex constraint network - correct result`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // Valid ordering exists
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that the reflow algorithm can handle complex constraint networks - specifically, 20 series with 19 mustBeBefore constraints forming a chain (S0→S1→S2→...→S19).

**What functionality or behavior is it verifying?**

The test verifies that:
1. 20 series are created with 30-minute durations (lines 1578-1580)
2. 19 mustBeBefore constraints form a chain (lines 1583-1589)
3. Reflow is called (line 1592)
4. No conflicts exist (line 1595)
5. All 20 series are assigned (lines 1596-1597)
6. The ordering is correct: S0 < S1 < S2 < ... < S19 (lines 1599-1604)

**Why does this specific test matter?**

Complex constraint networks test:
- Algorithm scalability
- Constraint propagation correctness
- Ability to satisfy transitive ordering requirements

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify constraints are actually satisfied
3. Could pass if reflow ignores constraints

Note: The subsequent assertions verify assignment count and ordering, providing stronger verification.

**Why does getting it right matter?**

For medically fragile people:
- Complex care schedules have many constraints
- All constraints must be satisfied
- Failures could disrupt entire care sequences

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-13.md:228 states "complex constraint network | Many constraints | Correct result"

2. **LAW 12** - notes/test-plan-13.md:72 states "propagation is sound | any constraint network | No valid solutions removed | LAW 12"

3. **Theorem** - notes/testing-spec-13-reflow-algorithm.md:442 states "THEOREM: If a valid arrangement exists that satisfies all hard constraints, the algorithm finds it"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('complex constraint network - correct result', () => {
  const series = Array.from({ length: 20 }, (_, i) =>
    createBasicSeries(`S${i}`, { duration: 30 })
  );

  const constraints = [];
  for (let i = 0; i < 19; i++) {
    constraints.push({
      type: 'mustBeBefore',
      firstSeries: seriesId(`S${i}`),
      secondSeries: seriesId(`S${i + 1}`),
    });
  }

  const input = createReflowInput(series, { constraints });
  const result = reflow(input);

  // All 20 series should be assigned
  expect(result.assignments).toHaveLength(20);

  // Should find valid ordering - no conflicts
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);

  // All series assigned
  const assignedIds = new Set(result.assignments.map((a) => a.seriesId));
  expect(assignedIds.size).toBe(20);

  // Verify all series are assigned and in correct order (transitive chain)
  const times = Array.from({ length: 20 }, (_, i) =>
    result.assignments.find((a) => a.seriesId === seriesId(`S${i}`))?.time
  );

  // All times should be defined
  times.forEach((t, i) => {
    expect(t).toBeDefined();
    expect(t).not.toBeNull();
  });

  // Verify chain order: S0 < S1 < S2 < ... < S19
  for (let i = 0; i < 19; i++) {
    expect(times[i]! < times[i + 1]!).toBe(true);
  }
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(20)` - All scheduled
2. `expect(result.conflicts).toHaveLength(0)` - No conflicts
3. `expect(assignedIds.size).toBe(20)` - All unique IDs
4. `expect(times[i]! < times[i + 1]!).toBe(true)` - Order respected

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all series are scheduled first
- Verifies no conflicts
- Explicitly checks transitive order
- Cannot pass if order is wrong
- Cannot pass if series are missing

**What specific changes would transform this test into its ideal form?**

Add before line 1595:
```typescript
// All 20 series should be assigned
expect(result.assignments).toHaveLength(20);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1575-1624 to examine the exact violation at line 1595 and full test context

3. **Search for complex constraint test plan** - Used Grep tool with pattern `complex constraint|constraint network|20 series|chain of constraints` in notes/test-plan-13.md, finding:
   - Line 72: "propagation is sound | any constraint network | No valid solutions removed | LAW 12"
   - Line 228: "complex constraint network | Many constraints | Correct result"

---

## Violation #56: tests/13-reflow-algorithm.test.ts:1680

**Test Name:** `two non-overlapping - both at ideal times`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // Non-overlapping - no conflicts
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test is a Known Answer Test verifying that two non-overlapping fixed series (A at 09:00, B at 10:00) are scheduled at their ideal times with no conflicts.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Series A is created fixed at 09:00 with 60-minute duration (line 1668)
2. Series B is created fixed at 10:00 with 60-minute duration (line 1669)
3. A ends at 10:00, B starts at 10:00 - no overlap (adjacent is allowed)
4. Both are assigned at their ideal times (lines 1674-1679)
5. No conflicts exist (line 1680)

**Why does this specific test matter?**

Known Answer Tests validate predictable outcomes:
- When series don't overlap, both should get their ideal times
- This is the simplest success case for the reflow algorithm
- Failure would indicate fundamental scheduling bugs

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify that conflicts WOULD be reported if they existed
3. Could pass if reflow always returns empty conflicts

Note: The preceding assertions (lines 1674-1679) verify the actual times.

**Why does getting it right matter?**

For medically fragile people:
- Non-overlapping schedules are the most common case
- If this fails, the algorithm is fundamentally broken
- This is a basic sanity check for scheduling correctness

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-13.md:238 states "Two non-overlapping | A 09:00, B 10:00 | Both at ideal times"

2. **Adjacent Allowed** - notes/test-plan-13.md:144 states "adjacent instances allowed | A 09:00-10:00, B 10:00-11:00 | true"

3. **INV 5** - notes/testing-spec-13-reflow-algorithm.md:473 states "INV 5: All conflicts reported (no silent failures)"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('two non-overlapping - both at ideal times', () => {
  const input = createReflowInput([
    createBasicSeries('A', { fixed: true, idealTime: '2025-01-15T09:00:00', duration: 60 }),
    createBasicSeries('B', { fixed: true, idealTime: '2025-01-15T10:00:00', duration: 60 }),
  ]);

  const result = reflow(input);

  // Both series should be assigned
  expect(result.assignments).toHaveLength(2);

  // A at ideal time
  expect(result.assignments.find((a) => a.seriesId === seriesId('A'))?.time).toBe(
    datetime('2025-01-15T09:00:00')
  );

  // B at ideal time
  expect(result.assignments.find((a) => a.seriesId === seriesId('B'))?.time).toBe(
    datetime('2025-01-15T10:00:00')
  );

  // No conflicts - non-overlapping series
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(2)` - Both scheduled
2. `expect(...A...time).toBe(...)` - A at ideal time
3. `expect(...B...time).toBe(...)` - B at ideal time
4. `expect(result.conflicts).toHaveLength(0)` - No conflicts
5. `expect(result.conflicts).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies both series are scheduled
- Verifies exact times match expected
- Verifies no conflicts with both length and equality
- Cannot pass if series aren't scheduled
- Cannot pass if times are wrong

**What specific changes would transform this test into its ideal form?**

Add before line 1674:
```typescript
// Both series should be assigned
expect(result.assignments).toHaveLength(2);
```

Replace line 1680:
```typescript
expect(result.conflicts).toHaveLength(0);
```

With:
```typescript
expect(result.conflicts).toHaveLength(0);
expect(result.conflicts).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1660-1719 to examine the exact violation at line 1680 and full test context

3. **Search for two non-overlapping test plan** - Used Grep tool with pattern `two non-overlapping|both at ideal|09:00.*10:00|non-overlapping.*ideal` in notes/test-plan-13.md, finding:
   - Line 79: "noOverlap prunes overlapping slots | A fixed at 09:00-10:00 | B cannot be 09:00-10:00"
   - Line 144: "adjacent instances allowed | A 09:00-10:00, B 10:00-11:00 | true"
   - Line 238: "Two non-overlapping | A 09:00, B 10:00 | Both at ideal times"
   - Line 239: "Must reschedule B | A fixed 09:00-10:00, B ideal 09:30 | B moved to 10:00"

---

## Violation #57: tests/13-reflow-algorithm.test.ts:1790

**Test Name:** `arc consistency reduces space - domain shrinks after propagation`

**Violation Line:**
```typescript
expect(domainBefore!.length).toBe(5); // 5 slots before propagation
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 25: "Arc consistency dramatically reduces search space" (notes/testing-spec-13-reflow-algorithm.md:458). It tests that constraint propagation prunes invalid domain values.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Instance A is fixed at 09:00 with 60-minute duration (lines 1770-1775)
2. Instance B has 5 possible slots before propagation: 08:00, 08:30, 09:00, 09:30, 10:00 (lines 1776-1782)
3. A noOverlap constraint is added between A and B (line 1784)
4. After propagation, B's domain should be smaller (line 1794)
5. The pre-propagation length is verified as 5 (line 1790)

**Why does this specific test matter?**

Arc consistency is critical for performance:
- Without it, the search space is exponential
- Propagation prunes invalid values early
- This prevents combinatorial explosion

**What are the consequences if this test is wrong or weak?**

The `toBe(5)` assertion is weak because:
1. It only verifies the count is 5
2. It doesn't verify the actual slot values
3. An array of 5 wrong values would pass
4. The setup verification doesn't confirm the right slots exist

**Why does getting it right matter?**

For medically fragile people:
- Efficient scheduling matters for real-time use
- Arc consistency ensures the algorithm terminates quickly
- Wrong domain values could lead to incorrect schedules

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 25** - notes/testing-spec-13-reflow-algorithm.md:458 states "LAW 25: Arc consistency dramatically reduces search space"

2. **Test Plan Reference** - notes/test-plan-13.md:250 states "arc consistency reduces space | Large domain pre-propagation | Smaller post | LAW 25"

3. **Verification Strategy** - notes/testing-spec-13-reflow-algorithm.md:484 states "Arc consistency propagation" as a unit test target

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('arc consistency reduces space - domain shrinks after propagation', () => {
  const instances = [
    { seriesId: seriesId('A'), fixed: true, duration: minutes(60) },
    { seriesId: seriesId('B'), fixed: false, duration: minutes(60) },
  ] as Instance[];

  const domainsBefore = new Map<Instance, LocalDateTime[]>();
  domainsBefore.set(instances[0], [datetime('2025-01-15T09:00:00')]);

  const expectedDomainB = [
    datetime('2025-01-15T08:00:00'),
    datetime('2025-01-15T08:30:00'),
    datetime('2025-01-15T09:00:00'),
    datetime('2025-01-15T09:30:00'),
    datetime('2025-01-15T10:00:00'),
  ];
  domainsBefore.set(instances[1], expectedDomainB);

  const constraints = [{ type: 'noOverlap', instances }];
  const domainsAfter = propagateConstraints(domainsBefore, constraints);

  const domainBefore = domainsBefore.get(instances[1]);
  const domainAfter = domainsAfter.get(instances[1]);

  // Verify setup: exactly the expected domain before propagation
  expect(domainBefore).toEqual(expectedDomainB);
  expect(domainBefore).toHaveLength(5);

  expect(domainAfter).toBeDefined();
  expect(domainAfter).not.toBeNull();

  // After propagation, domain should be reduced
  expect(domainAfter!.length).toBeLessThan(5);

  // Verify that pruned slots are the conflicting ones (09:00, 09:30)
  // A occupies 09:00-10:00, so B cannot be at 09:00 or 09:30
  expect(domainAfter).not.toContain(datetime('2025-01-15T09:00:00'));
  expect(domainAfter).not.toContain(datetime('2025-01-15T09:30:00'));

  // Valid slots should remain
  expect(domainAfter).toContain(datetime('2025-01-15T08:00:00'));
  expect(domainAfter).toContain(datetime('2025-01-15T10:00:00'));
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(domainBefore).toEqual(expectedDomainB)` - Exact setup verification
2. `expect(domainAfter!.length).toBeLessThan(5)` - Reduction occurred
3. `expect(domainAfter).not.toContain(...)` - Conflicting slots pruned
4. `expect(domainAfter).toContain(...)` - Valid slots preserved

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies exact domain values before propagation
- Verifies specific slots are pruned
- Verifies valid slots remain
- Cannot pass if propagation is broken

**What specific changes would transform this test into its ideal form?**

Replace line 1790:
```typescript
expect(domainBefore!.length).toBe(5);
```

With:
```typescript
expect(domainBefore).toEqual([
  datetime('2025-01-15T08:00:00'),
  datetime('2025-01-15T08:30:00'),
  datetime('2025-01-15T09:00:00'),
  datetime('2025-01-15T09:30:00'),
  datetime('2025-01-15T10:00:00'),
]);
```

Add after line 1794:
```typescript
// Verify conflicting slots pruned, valid slots remain
expect(domainAfter).not.toContain(datetime('2025-01-15T09:00:00'));
expect(domainAfter).toContain(datetime('2025-01-15T10:00:00'));
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1770-1829 to examine the exact violation at line 1790 and full test context

3. **Search for arc consistency test plan** - Used Grep tool with pattern `arc consistency|domain shrinks|propagation.*shrink|reduce.*domain` in notes/test-plan-13.md, finding:
   - Line 250: "arc consistency reduces space | Large domain pre-propagation | Smaller post | LAW 25"

4. **Search for LAW 25** - Used Grep tool with pattern `arc consistency|LAW 25|propagateConstraints|constraint propagation` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 458: "LAW 25: Arc consistency dramatically reduces search space"

5. **Read specification context** - Used Read tool on notes/testing-spec-13-reflow-algorithm.md lines 450-499 to find:
   - Line 458: LAW 25 definition
   - Line 484: Arc consistency propagation as unit test target

---

## Violation #58: tests/13-reflow-algorithm.test.ts:1794

**Test Name:** `arc consistency reduces space - domain shrinks after propagation`

**Violation Line:**
```typescript
expect(domainAfter!.length).toBeLessThan(5); // After propagation, domain should be reduced
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 25: "Arc consistency dramatically reduces search space" (notes/testing-spec-13-reflow-algorithm.md:458). Specifically, it tests that after constraint propagation, the domain of B is smaller than before.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Instance A is fixed at 09:00 with 60-minute duration (line 1770)
2. Instance B has 5 possible slots: 08:00, 08:30, 09:00, 09:30, 10:00 (lines 1776-1782)
3. A noOverlap constraint is added (line 1784)
4. After propagation, B's domain is smaller than 5 (line 1794)
5. The slots 09:00 and 09:30 should be pruned (conflict with A at 09:00-10:00)

**Why does this specific test matter?**

Arc consistency is fundamental to constraint propagation:
- It removes impossible values before search
- Reduces the combinatorial explosion
- Makes the algorithm tractable

**What are the consequences if this test is wrong or weak?**

The `toBeLessThan(5)` assertion is weak because:
1. It only sets an upper bound of 4
2. It doesn't verify WHICH slots were pruned
3. Domain could shrink to 0 or 1 and still pass
4. Could pass if propagation is overly aggressive (wrong)
5. Doesn't verify the correct slots remain

**Why does getting it right matter?**

For medically fragile people:
- Correct constraint propagation ensures valid schedules
- Wrong propagation could eliminate valid options
- The algorithm depends on sound arc consistency

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 25** - notes/testing-spec-13-reflow-algorithm.md:458 states "LAW 25: Arc consistency dramatically reduces search space"

2. **Test Plan Reference** - notes/test-plan-13.md:250 states "arc consistency reduces space | Large domain pre-propagation | Smaller post | LAW 25"

3. **Propagation Soundness** - notes/test-plan-13.md:72 states "propagation is sound | any constraint network | No valid solutions removed | LAW 12"

4. **Propagate Function** - notes/testing-spec-13-reflow-algorithm.md:217 defines `propagate(graph: ConstraintGraph): boolean`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('arc consistency reduces space - domain shrinks after propagation', () => {
  const instances = [
    { seriesId: seriesId('A'), fixed: true, duration: minutes(60) },
    { seriesId: seriesId('B'), fixed: false, duration: minutes(60) },
  ] as Instance[];

  const domainsBefore = new Map<Instance, LocalDateTime[]>();
  domainsBefore.set(instances[0], [datetime('2025-01-15T09:00:00')]);
  domainsBefore.set(instances[1], [
    datetime('2025-01-15T08:00:00'),
    datetime('2025-01-15T08:30:00'),
    datetime('2025-01-15T09:00:00'),
    datetime('2025-01-15T09:30:00'),
    datetime('2025-01-15T10:00:00'),
  ]);

  const constraints = [{ type: 'noOverlap', instances }];
  const domainsAfter = propagateConstraints(domainsBefore, constraints);

  const domainBefore = domainsBefore.get(instances[1]);
  const domainAfter = domainsAfter.get(instances[1]);

  // Verify setup
  expect(domainBefore).toHaveLength(5);

  // Verify reduction occurred
  expect(domainAfter).toBeDefined();
  expect(domainAfter!.length).toBeLessThan(5);

  // CRITICAL: Verify EXACTLY which slots remain
  // A occupies 09:00-10:00, so B cannot be at 09:00 or 09:30
  expect(domainAfter).toHaveLength(3);  // Exactly 3 valid slots
  expect(domainAfter).toContainEqual(datetime('2025-01-15T08:00:00'));
  expect(domainAfter).toContainEqual(datetime('2025-01-15T08:30:00'));
  expect(domainAfter).toContainEqual(datetime('2025-01-15T10:00:00'));

  // Verify conflicting slots were pruned
  expect(domainAfter).not.toContainEqual(datetime('2025-01-15T09:00:00'));
  expect(domainAfter).not.toContainEqual(datetime('2025-01-15T09:30:00'));
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(domainAfter).toHaveLength(3)` - Exact reduction
2. `expect(domainAfter).toContainEqual(...)` - Valid slots remain
3. `expect(domainAfter).not.toContainEqual(...)` - Conflicting slots pruned

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies exact remaining domain size
- Verifies specific valid slots remain
- Verifies specific conflicting slots are pruned
- Cannot pass if propagation is wrong

**What specific changes would transform this test into its ideal form?**

Replace line 1794:
```typescript
expect(domainAfter!.length).toBeLessThan(5);
```

With:
```typescript
// Exactly 3 slots should remain (08:00, 08:30, 10:00)
expect(domainAfter).toHaveLength(3);
expect(domainAfter).toContainEqual(datetime('2025-01-15T08:00:00'));
expect(domainAfter).toContainEqual(datetime('2025-01-15T10:00:00'));
expect(domainAfter).not.toContainEqual(datetime('2025-01-15T09:00:00'));
expect(domainAfter).not.toContainEqual(datetime('2025-01-15T09:30:00'));
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1765-1814 to examine the exact violation at line 1794 and full test context

3. **Search for LAW 25 and propagation** - Used Grep tool with pattern `LAW 25|reduces search space|propagate` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 217: "propagate(graph: ConstraintGraph): boolean"
   - Line 267: "if propagate(graph):"
   - Line 458: "LAW 25: Arc consistency dramatically reduces search space"

4. **Search for arc consistency test plan** - Used Grep tool with pattern `arc consistency|domain.*shrink|propagat|reduces space` in notes/test-plan-13.md, finding:
   - Line 72: "propagation is sound | any constraint network | No valid solutions removed | LAW 12"
   - Line 73: "propagation incomplete | complex network | May need backtracking | LAW 13"
   - Line 250: "arc consistency reduces space | Large domain pre-propagation | Smaller post | LAW 25"

---

## Violation #59: tests/13-reflow-algorithm.test.ts:1823

**Test Name:** `MRV finds conflicts early - fast failure on unsolvable`

**Violation Line:**
```typescript
expect(result).toBeNull(); // Unsolvable - correctly returns null
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 26: "MRV ordering finds conflicts early" (notes/testing-spec-13-reflow-algorithm.md:459). It tests that the algorithm quickly detects unsolvable problems using Minimum Remaining Values heuristic.

**What functionality or behavior is it verifying?**

The test verifies that:
1. 10 fixed instances are created, all at the same time 09:00 (lines 1799-1804)
2. All have 60-minute duration and single-element domains (lines 1806-1809)
3. All pairs have noOverlap constraints (lines 1811-1816)
4. This is unsolvable - 10 items cannot all be at 09:00 without overlap
5. backtrackSearch returns null (line 1823)
6. Detection is fast (under 100ms) (line 1824)

**Why does this specific test matter?**

Fast failure detection is critical:
- Without MRV, algorithm could explore exponentially many branches
- MRV finds the most constrained variable first
- Detects conflicts before wasting computation

**What are the consequences if this test is wrong or weak?**

The `toBeNull()` assertion is weak because:
1. It only verifies the result is null
2. It doesn't verify WHY it's null
3. Could pass if backtrackSearch always returns null
4. Doesn't verify MRV is actually being used
5. Doesn't verify conflicts would be found correctly if solvable

**Why does getting it right matter?**

For medically fragile people:
- Real-time scheduling needs fast responses
- Detecting impossibility quickly allows fallback strategies
- Slow algorithms could cause care delays

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 26** - notes/testing-spec-13-reflow-algorithm.md:459 states "LAW 26: MRV ordering finds conflicts early"

2. **Test Plan Reference** - notes/test-plan-13.md:251 states "MRV finds conflicts early | Unsolvable | Fast failure | LAW 26"

3. **Variable Ordering** - notes/testing-spec-13-reflow-algorithm.md:257 states "instance = selectUnassigned(graph, assignment)  // variable ordering"

4. **MRV + Degree** - notes/testing-spec-13-reflow-algorithm.md:278 states "7.1 Variable Ordering (MRV + Degree)"

5. **Terminates on No Solution** - notes/test-plan-13.md:94 states "terminates on no solution | unsolvable | Returns null | LAW 16"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('MRV finds conflicts early - fast failure on unsolvable', () => {
  // Unsolvable: 10 fixed items all at same time
  const instances = Array.from({ length: 10 }, (_, i) => ({
    seriesId: seriesId(`S${i}`),
    fixed: true,
    idealTime: datetime('2025-01-15T09:00:00'),
    duration: minutes(60),
  })) as Instance[];

  const domains = new Map<Instance, LocalDateTime[]>();
  instances.forEach((inst) => {
    domains.set(inst, [datetime('2025-01-15T09:00:00')]);
  });

  const constraints = [];
  for (let i = 0; i < instances.length; i++) {
    for (let j = i + 1; j < instances.length; j++) {
      constraints.push({ type: 'noOverlap', instances: [instances[i], instances[j]] });
    }
  }

  // First verify that a SOLVABLE problem succeeds
  const solvableInstances = [instances[0]];
  const solvableDomains = new Map<Instance, LocalDateTime[]>();
  solvableDomains.set(instances[0], [datetime('2025-01-15T09:00:00')]);
  const solvableResult = backtrackSearch(solvableInstances, solvableDomains, []);
  expect(solvableResult).not.toBeNull();

  // Now verify the unsolvable problem fails
  const start = Date.now();
  const result = backtrackSearch(instances, domains, constraints);
  const elapsed = Date.now() - start;

  // Unsolvable - correctly returns null
  expect(result).toBeNull();

  // Should fail fast due to MRV heuristic
  expect(elapsed).toBeLessThan(100);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(solvableResult).not.toBeNull()` - Algorithm works for solvable
2. `expect(result).toBeNull()` - Unsolvable returns null
3. `expect(elapsed).toBeLessThan(100)` - Fast failure

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- First verifies algorithm works for solvable problems
- Then verifies unsolvable returns null
- Verifies fast detection (not exponential time)
- Cannot pass if algorithm always returns null

**What specific changes would transform this test into its ideal form?**

Add before line 1818:
```typescript
// First verify that a solvable problem succeeds
const solvableInstances = [instances[0]];
const solvableDomains = new Map<Instance, LocalDateTime[]>();
solvableDomains.set(instances[0], [datetime('2025-01-15T09:00:00')]);
const solvableResult = backtrackSearch(solvableInstances, solvableDomains, []);
expect(solvableResult).not.toBeNull();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1795-1844 to examine the exact violation at line 1823 and full test context

3. **Search for MRV test plan** - Used Grep tool with pattern `MRV|conflicts early|fast failure|unsolvable` in notes/test-plan-13.md, finding:
   - Line 94: "terminates on no solution | unsolvable | Returns null | LAW 16"
   - Line 251: "MRV finds conflicts early | Unsolvable | Fast failure | LAW 26"

4. **Search for LAW 26 and MRV** - Used Grep tool with pattern `LAW 26|MRV|minimum remaining values|variable ordering` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 257: "instance = selectUnassigned(graph, assignment)  // variable ordering"
   - Line 278: "7.1 Variable Ordering (MRV + Degree)"
   - Line 459: "LAW 26: MRV ordering finds conflicts early"

---

## Violation #60: tests/13-reflow-algorithm.test.ts:1863

**Test Name:** `correctness over performance - correct result always`

**Violation Line:**
```typescript
expect(result.conflicts).toHaveLength(0); // Valid assignment exists
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 28: "Correctness over performance (life-critical)" (notes/testing-spec-13-reflow-algorithm.md:461). It ensures the algorithm always finds valid solutions even for edge cases that might tempt shortcuts.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Series A is fixed at 09:00 with 60-minute duration (line 1855)
2. Series B wants 09:30 (conflicts with A) but has wiggle (daysBefore=1, daysAfter=1) (line 1856)
3. Series C wants 10:00 (line 1857)
4. A valid non-overlapping solution exists and is found (line 1863)
5. All 3 series are assigned (line 1865)
6. No overlaps exist (lines 1867-1871)

**Why does this specific test matter?**

This is an edge case:
- B's ideal time conflicts with A
- B must be rescheduled, not skipped
- Algorithm must not take shortcuts that miss valid solutions

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify a solution was found
3. It doesn't verify the solution is non-overlapping
4. Could pass if reflow always returns empty conflicts

Note: The subsequent assertions (lines 1865-1871) provide stronger verification.

**Why does getting it right matter?**

For medically fragile people:
- If valid schedules exist, they MUST be found
- Reporting false conflicts could skip care tasks
- LAW 28 is the fundamental principle: correctness over performance

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 28** - notes/testing-spec-13-reflow-algorithm.md:461 states "LAW 28: Correctness over performance (life-critical)"

2. **Life-Critical Context** - notes/testing-spec-13-reflow-algorithm.md:7 states "Critical: This is life-critical software. If a valid arrangement exists, we MUST find it."

3. **Test Plan Reference** - notes/test-plan-13.md:253 states "correctness over performance | Any input | Correct result | LAW 28"

4. **Critical Statement** - notes/test-plan-13.md:7 states "CRITICAL: This is life-critical software. If a valid arrangement exists, we MUST find it."

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('correctness over performance - correct result always', () => {
  // Edge case that might tempt shortcuts
  const input = createReflowInput([
    createBasicSeries('A', { fixed: true, idealTime: '2025-01-15T09:00:00', duration: 60 }),
    createBasicSeries('B', { idealTime: '2025-01-15T09:30:00', duration: 60, daysBefore: 1, daysAfter: 1 }),
    createBasicSeries('C', { idealTime: '2025-01-15T10:00:00', duration: 60 }),
  ]);

  const result = reflow(input);

  // CRITICAL: All 3 series should be assigned
  expect(result.assignments).toHaveLength(3);

  const assignedIds = new Set(result.assignments.map((a) => a.seriesId));
  expect(assignedIds.size).toBe(3);
  expect(assignedIds.has(seriesId('A'))).toBe(true);
  expect(assignedIds.has(seriesId('B'))).toBe(true);
  expect(assignedIds.has(seriesId('C'))).toBe(true);

  // Must find valid non-overlapping assignment
  expect(result.conflicts).toHaveLength(0);
  expect(result.conflicts).toEqual([]);

  // Verify no overlaps
  const times = result.assignments.map((a) => a.time).sort();
  for (let i = 0; i < times.length - 1; i++) {
    expect(times[i]! < times[i + 1]!).toBe(true);
  }

  // Verify A is at its fixed time
  const timeA = result.assignments.find(a => a.seriesId === seriesId('A'))?.time;
  expect(timeA).toBe(datetime('2025-01-15T09:00:00'));
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.assignments).toHaveLength(3)` - All scheduled
2. `expect(assignedIds.has(...)).toBe(true)` - Each series assigned
3. `expect(result.conflicts).toHaveLength(0)` - No conflicts
4. `expect(result.conflicts).toEqual([])` - Empty array
5. `expect(times[i]! < times[i + 1]!).toBe(true)` - No overlaps
6. `expect(timeA).toBe(...)` - Fixed series at correct time

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all series are scheduled first
- Verifies specific series IDs are present
- Verifies no conflicts
- Verifies no overlaps
- Verifies fixed series at correct time
- Cannot pass if any series is skipped

**What specific changes would transform this test into its ideal form?**

Add before line 1863:
```typescript
// All 3 series should be assigned
expect(result.assignments).toHaveLength(3);
```

Replace line 1863:
```typescript
expect(result.conflicts).toHaveLength(0);
```

With:
```typescript
expect(result.conflicts).toHaveLength(0);
expect(result.conflicts).toEqual([]);
```

Add after line 1865:
```typescript
// Verify each series is assigned
expect(assignedIds.has(seriesId('A'))).toBe(true);
expect(assignedIds.has(seriesId('B'))).toBe(true);
expect(assignedIds.has(seriesId('C'))).toBe(true);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 1845-1875 to examine the exact violation at line 1863 and full test context

3. **Search for correctness over performance test plan** - Used Grep tool with pattern `correctness over performance|correct result|life.critical|LAW 28` in notes/test-plan-13.md, finding:
   - Line 7: "CRITICAL: This is life-critical software. If a valid arrangement exists, we MUST find it."
   - Line 253: "correctness over performance | Any input | Correct result | LAW 28"

4. **Search for LAW 28** - Used Grep tool with pattern `LAW 28|correctness over performance|life.critical` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 7: "Critical: This is life-critical software. If a valid arrangement exists, we MUST find it."
   - Line 461: "LAW 28: Correctness over performance (life-critical)"

---
