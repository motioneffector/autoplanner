/**
 * Deadweight Test Analysis
 *
 * Inverts Stryker's mutation testing data to find tests that don't kill any mutants.
 * Reads reports/mutation/mutation.json (generated by `npx stryker run` with JSON reporter).
 *
 * Classifies every test into three tiers:
 *   Tier 1 (Killers)  — killed at least one mutant
 *   Tier 2 (Coverage) — covered mutated code but killed nothing
 *   Tier 3 (Ghosts)   — never even executed mutated code
 *
 * Run: bun scripts/analyze-deadweight-tests.ts
 */

import { readFileSync, existsSync } from 'fs'
import type { MutationTestResult } from 'mutation-testing-report-schema'

const REPORT_PATH = 'reports/mutation/mutation.json'
const EXCLUDED_FROM_STRYKER = [
  'tests/fuzz/**',
  'tests/14-public-api.test.ts',
  'tests/16-integration.test.ts',
]

// ============================================================================
// Load report
// ============================================================================

if (!existsSync(REPORT_PATH)) {
  console.error(`No mutation report found at ${REPORT_PATH}.`)
  console.error(`Run \`npx stryker run\` first to generate the JSON report.`)
  console.error(`(Ensure "json" is in the reporters array in stryker.config.json)`)
  process.exit(1)
}

const raw = readFileSync(REPORT_PATH, 'utf-8')
let report: MutationTestResult
try {
  report = JSON.parse(raw)
} catch {
  console.error(`Failed to parse ${REPORT_PATH} — file may be malformed or truncated.`)
  console.error(`Try deleting it and re-running \`npx stryker run\`.`)
  process.exit(1)
}

// ============================================================================
// Build test registry: id → { name, file }
// ============================================================================

type TestInfo = { id: string; name: string; file: string }

const testRegistry = new Map<string, TestInfo>()

if (report.testFiles) {
  for (const [filePath, testFile] of Object.entries(report.testFiles)) {
    for (const test of testFile.tests) {
      testRegistry.set(test.id, { id: test.id, name: test.name, file: filePath })
    }
  }
}

if (testRegistry.size === 0) {
  console.error('No tests found in the report. The testFiles section may be empty.')
  console.error('Ensure Stryker is configured to report test information.')
  process.exit(1)
}

// ============================================================================
// Build kill/cover sets and count mutant stats
// ============================================================================

const killerIds = new Set<string>()
const coverIds = new Set<string>()
const killCountByTest = new Map<string, number>()
const uniqueKillCountByTest = new Map<string, number>()
const killProfileByTest = new Map<string, Set<string>>()

let totalMutants = 0
let killedMutants = 0
let survivedMutants = 0
let noCoverageMutants = 0
let noBailDetected = false

for (const fileResult of Object.values(report.files)) {
  for (const mutant of fileResult.mutants) {
    totalMutants++

    if (mutant.status === 'Killed') killedMutants++
    else if (mutant.status === 'Survived') survivedMutants++
    else if (mutant.status === 'NoCoverage') noCoverageMutants++

    if (mutant.killedBy) {
      if (mutant.killedBy.length > 1) noBailDetected = true

      for (const testId of mutant.killedBy) {
        killerIds.add(testId)
        killCountByTest.set(testId, (killCountByTest.get(testId) ?? 0) + 1)

        let profile = killProfileByTest.get(testId)
        if (!profile) {
          profile = new Set<string>()
          killProfileByTest.set(testId, profile)
        }
        profile.add(mutant.id)
      }

      // Unique kill: only one test killed this mutant
      if (mutant.killedBy.length === 1) {
        const testId = mutant.killedBy[0]!
        uniqueKillCountByTest.set(testId, (uniqueKillCountByTest.get(testId) ?? 0) + 1)
      }
    }

    if (mutant.coveredBy) {
      for (const testId of mutant.coveredBy) {
        coverIds.add(testId)
      }
    }
  }
}

if (totalMutants === 0) {
  console.error('No mutants found in the report. The stryker run may have been empty.')
  console.error('Check that stryker.config.json mutates the correct files.')
  process.exit(1)
}

// ============================================================================
// Classify tests into tiers
// ============================================================================

const tier1: TestInfo[] = []
const tier2: TestInfo[] = []
const tier3: TestInfo[] = []

for (const [testId, info] of testRegistry) {
  if (killerIds.has(testId)) {
    tier1.push(info)
  } else if (coverIds.has(testId)) {
    tier2.push(info)
  } else {
    tier3.push(info)
  }
}

// ============================================================================
// Dominated-test detection
// ============================================================================

type DominatedInfo = {
  test: TestInfo
  kills: number
  dominator: TestInfo
  dominatorKills: number
}

const dominated: DominatedInfo[] = []

// Only zero-unique-kill tier 1 tests can be dominated — tests with unique kills
// have a mutant no other test kills, so no single test can be a strict superset.
const candidates = tier1.filter(t => (uniqueKillCountByTest.get(t.id) ?? 0) === 0)

// Build sorted list of potential dominators (all tier 1 tests with a kill profile)
const dominatorPool = tier1
  .filter(t => (killCountByTest.get(t.id) ?? 0) > 0)
  .sort((a, b) => (killCountByTest.get(a.id) ?? 0) - (killCountByTest.get(b.id) ?? 0))

for (const candidate of candidates) {
  const candidateProfile = killProfileByTest.get(candidate.id)
  if (!candidateProfile || candidateProfile.size === 0) continue

  const candidateKills = candidateProfile.size

  for (const potential of dominatorPool) {
    if (potential.id === candidate.id) continue

    const potentialProfile = killProfileByTest.get(potential.id)
    if (!potentialProfile) continue
    if (potentialProfile.size <= candidateKills) continue // Can't be strict superset

    // Check if candidate's kills are a strict subset of potential's kills
    let isSubset = true
    for (const mutantId of candidateProfile) {
      if (!potentialProfile.has(mutantId)) {
        isSubset = false
        break
      }
    }

    if (isSubset) {
      dominated.push({
        test: candidate,
        kills: candidateKills,
        dominator: potential,
        dominatorKills: potentialProfile.size,
      })
      break // First match is closest dominator (sorted by kill count)
    }
  }
}

// ============================================================================
// Helpers
// ============================================================================

function groupByFile(tests: TestInfo[]): Map<string, TestInfo[]> {
  const grouped = new Map<string, TestInfo[]>()
  for (const t of tests) {
    const list = grouped.get(t.file)
    if (list) {
      list.push(t)
    } else {
      grouped.set(t.file, [t])
    }
  }
  return grouped
}

function printGrouped(tests: TestInfo[], extra?: (t: TestInfo) => string): void {
  const grouped = groupByFile(tests)
  const sortedFiles = [...grouped.keys()].sort()
  for (const file of sortedFiles) {
    const fileTests = grouped.get(file)!
    console.log(`  ${file}:`)
    for (const t of fileTests) {
      const suffix = extra ? extra(t) : ''
      console.log(`    - ${t.name}${suffix}`)
    }
  }
}

// ============================================================================
// Output
// ============================================================================

console.log(`\n${'='.repeat(70)}`)
console.log(`  DEADWEIGHT TEST ANALYSIS`)
console.log(`${'='.repeat(70)}`)

console.log(`\n--- SUMMARY ---`)
console.log(`Total tests in stryker scope: ${testRegistry.size}`)
console.log(`Total mutants: ${totalMutants} (${killedMutants} killed, ${survivedMutants} survived, ${noCoverageMutants} no coverage)`)
console.log(`  Tier 1 (Killers):       ${tier1.length} tests`)
console.log(`  Tier 2 (Coverage-only): ${tier2.length} tests`)
console.log(`  Tier 3 (Ghosts):        ${tier3.length} tests`)
console.log(`\nExcluded from stryker scope:`)
for (const ex of EXCLUDED_FROM_STRYKER) {
  console.log(`  - ${ex}`)
}

// Tier 3: Ghosts
console.log(`\n${'='.repeat(70)}`)
console.log(`  TIER 3: GHOST TESTS (${tier3.length})`)
console.log(`  These tests never executed any mutated code.`)
console.log(`${'='.repeat(70)}\n`)

if (tier3.length === 0) {
  console.log('  (none)')
} else {
  printGrouped(tier3)
}

// Tier 2: Coverage-only
console.log(`\n${'='.repeat(70)}`)
console.log(`  TIER 2: COVERAGE-ONLY TESTS (${tier2.length})`)
console.log(`  Executed mutated code but never caught a mutation.`)
if (noBailDetected) {
  console.log(`  With disableBail, these results are exact.`)
} else {
  console.log(`  NOTE: First-kill bias inflates this tier. Many may be genuinely useful`)
  console.log(`  but another test ran first and got credit for the kill.`)
}
console.log(`${'='.repeat(70)}\n`)

if (tier2.length === 0) {
  console.log('  (none)')
} else {
  printGrouped(tier2)
}

// Tier 1: Low unique kills
const zeroUniqueKills = tier1.filter(t => (uniqueKillCountByTest.get(t.id) ?? 0) === 0)
zeroUniqueKills.sort((a, b) => (killCountByTest.get(a.id) ?? 0) - (killCountByTest.get(b.id) ?? 0))

console.log(`\n${'='.repeat(70)}`)
console.log(`  TIER 1: TESTS WITH ZERO UNIQUE KILLS (${zeroUniqueKills.length} of ${tier1.length} killers)`)
console.log(`  These tests killed mutants, but every mutant they killed was also`)
console.log(`  killed by another test. Possible redundancy candidates.`)
if (noBailDetected) {
  console.log(`  With disableBail, these counts are exact.`)
} else {
  console.log(`  NOTE: First-kill bias means this is an upper bound — some tests`)
  console.log(`  listed here may have unique kills that weren't recorded.`)
}
console.log(`${'='.repeat(70)}\n`)

if (zeroUniqueKills.length === 0) {
  console.log('  (none)')
} else {
  printGrouped(zeroUniqueKills, (t) => {
    const kills = killCountByTest.get(t.id) ?? 0
    return ` (${kills} total kills, 0 unique)`
  })
}

// Dominated tests
console.log(`\n${'='.repeat(70)}`)
console.log(`  DOMINATED TESTS (${dominated.length} of ${candidates.length} zero-unique-kill tests)`)
console.log(`  Test A's kill set is a strict subset of test B's.`)
console.log(`  Removing A loses zero mutation coverage.`)
console.log(`${'='.repeat(70)}\n`)

if (dominated.length === 0) {
  console.log('  (none)')
} else {
  const domGrouped = groupByFile(dominated.map(d => d.test))
  const domSortedFiles = [...domGrouped.keys()].sort()
  const domByTestId = new Map(dominated.map(d => [d.test.id, d]))

  console.log(`  Summary: ${dominated.length} dominated across ${domSortedFiles.length} test file(s)\n`)

  for (const file of domSortedFiles) {
    const fileTests = domGrouped.get(file)!
    console.log(`  ${file}: (${fileTests.length} dominated)`)
    for (const t of fileTests) {
      const info = domByTestId.get(t.id)!
      const fileSuffix = info.dominator.file !== file ? ` [${info.dominator.file}]` : ''
      console.log(`    - ${t.name} (${info.kills} kills)`)
      console.log(`      \u2190 ${info.dominator.name} (${info.dominatorKills} kills)${fileSuffix}`)
    }
  }
}

console.log('')
