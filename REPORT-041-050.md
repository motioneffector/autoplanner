# REPORT-041-050: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #41-50 as specified in REPORT-SPEC.md.

---

## Violation #41: tests/12-relational-constraints.test.ts:76

**Test Name:** `add constraint returns ID`

**Violation Line:**
```typescript
expect(typeof result.value.id).toBe('string');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `addConstraint` returns a valid ID. The specification at notes/testing-spec-12-relational-constraints.md:84 defines `addConstraint(constraint: RelationalConstraint): ConstraintId`.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Two series are created (lines 65-66)
2. A `mustBeBefore` constraint is added between them (lines 68-72)
3. The result indicates success (line 74)
4. The returned ID is a string (line 76)
5. The ID matches a non-empty pattern (line 78)

**Why does this specific test matter?**

Constraint IDs are essential for:
- Retrieving constraints via `getConstraint`
- Removing constraints via `removeConstraint`
- Managing the constraint system

**What are the consequences if this test is wrong or weak?**

The `typeof ... toBe('string')` assertion is weak because:
1. It only verifies the type, not that the ID is valid
2. It doesn't verify the constraint was actually created
3. An empty string would pass
4. A random string unrelated to any constraint would pass
5. The ID might not be retrievable via `getConstraint`

It could pass when:
- `addConstraint` returns a random string but doesn't persist
- The ID doesn't map to any actual constraint
- The constraint system is broken

**Why does getting it right matter?**

For medically fragile people:
- Constraints enforce safety rules (e.g., medication A before medication B)
- If IDs are invalid, constraints can't be managed
- Care coordination relies on constraint integrity

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **addConstraint Signature** - notes/testing-spec-12-relational-constraints.md:84 defines `addConstraint(constraint: RelationalConstraint): ConstraintId`

2. **ConstraintId Type** - notes/testing-spec-12-relational-constraints.md:15 shows `id: ConstraintId` is part of the RelationalConstraint type

3. **Test Plan Reference** - notes/test-plan-12.md:19 states "add constraint returns ID | addConstraint | ID returned | -"

4. **getConstraint Signature** - notes/testing-spec-12-relational-constraints.md:85 defines `getConstraint(id: ConstraintId): RelationalConstraint | null` - uses the returned ID

5. **removeConstraint Signature** - notes/testing-spec-12-relational-constraints.md:87 defines `removeConstraint(id: ConstraintId): void` - uses the returned ID

6. **API Surface** - notes/api-surface.md:148-156 shows public API for constraints returning ConstraintId

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('add constraint returns ID', async () => {
  const seriesA = await createTestSeries('A');
  const seriesB = await createTestSeries('B');

  const result = await addConstraint(adapter, {
    type: 'mustBeBefore',
    source: { type: 'seriesId', seriesId: seriesA },
    dest: { type: 'seriesId', seriesId: seriesB },
  });

  expect(result.ok).toBe(true);
  if (!result.ok) throw new Error('Setup failed');

  // Verify ID is a valid non-empty string
  expect(typeof result.value.id).toBe('string');
  expect(result.value.id.length).toBeGreaterThan(0);

  // CRITICAL: Verify the ID actually maps to the constraint
  const retrieved = await getConstraint(adapter, result.value.id);
  expect(retrieved).not.toBeNull();
  expect(retrieved!.id).toBe(result.value.id);
  expect(retrieved!.type).toBe('mustBeBefore');
  expect(retrieved!.source).toEqual({ type: 'seriesId', seriesId: seriesA });
  expect(retrieved!.dest).toEqual({ type: 'seriesId', seriesId: seriesB });

  // Verify constraint appears in getAllConstraints
  const allConstraints = await getAllConstraints(adapter);
  const found = allConstraints.find(c => c.id === result.value.id);
  expect(found).not.toBeUndefined();
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(result.ok).toBe(true)` - Operation succeeded
2. `expect(typeof result.value.id).toBe('string')` - ID is a string
3. `expect(result.value.id.length).toBeGreaterThan(0)` - ID is non-empty
4. `expect(retrieved).not.toBeNull()` - ID maps to a real constraint
5. `expect(retrieved!.id).toBe(result.value.id)` - ID is correct
6. `expect(retrieved!.type).toBe('mustBeBefore')` - Constraint data is correct
7. `expect(found).not.toBeUndefined()` - Appears in getAllConstraints

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the ID is retrievable via getConstraint
- Confirms the retrieved constraint has correct data
- Tests the ID appears in getAllConstraints
- Cannot pass if addConstraint doesn't persist
- Cannot pass if the ID is invalid

**What specific changes would transform this test into its ideal form?**

Add after line 78 (after the pattern match):
```typescript
// Verify the ID maps to the actual constraint
const retrieved = await getConstraint(adapter, result.value.id);
expect(retrieved).not.toBeNull();
expect(retrieved!.id).toBe(result.value.id);
expect(retrieved!.type).toBe('mustBeBefore');
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/12-relational-constraints.test.ts lines 60-109 to examine the exact violation at line 76 and full test context

3. **Search for addConstraint specification** - Used Grep tool with pattern `addConstraint|constraint.*returns.*ID|POST.*constraint|ConstraintId` in notes directory, finding:
   - testing-spec-12-relational-constraints.md:84: addConstraint signature
   - testing-spec-12-relational-constraints.md:85: getConstraint signature
   - test-plan-12.md:19: test plan reference

4. **Find specification file** - Used Glob tool with pattern `notes/testing-spec-12*.md` to find testing-spec-12-relational-constraints.md

5. **Read constraint specification** - Used Read tool on notes/testing-spec-12-relational-constraints.md lines 1-120 to find:
   - Lines 14-32: RelationalConstraint type definition
   - Lines 84-88: CRUD operation signatures
   - Lines 92-98: LAW 1-5 for constraint properties

6. **Read test plan** - Used Read tool on notes/test-plan-12.md lines 15-44 to find:
   - Line 19: "add constraint returns ID | addConstraint | ID returned | -"

---

## Violation #42: tests/12-relational-constraints.test.ts:187

**Test Name:** `delete constraint`

**Violation Line:**
```typescript
expect(adapter.getConstraints).toBeDefined();
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `deleteConstraint` (also called `removeConstraint`) actually removes a constraint. The specification at notes/testing-spec-12-relational-constraints.md:87 defines `removeConstraint(id: ConstraintId): void`.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Two series are created (lines 173-174)
2. A constraint is added (lines 176-180)
3. The constraint is deleted (line 184)
4. The constraint no longer appears in `getConstraints` (lines 188-190)
5. Direct lookup via `getConstraint` returns null (lines 192-193)

**Why does this specific test matter?**

Constraint deletion allows users to:
- Remove outdated constraints
- Correct mistakes
- Update scheduling rules

**What are the consequences if this test is wrong or weak?**

The `toBeDefined()` assertion at line 187 is weak because:
1. It only verifies `adapter.getConstraints` exists as a property
2. It doesn't verify the function works correctly
3. It doesn't verify the constraint was actually deleted
4. A method that always returns `[]` would pass
5. A method that returns stale data would pass

Note: The actual deletion verification happens at lines 188-193, but the `toBeDefined()` check is a weak assertion that adds no real test value.

It could pass when:
- `getConstraints` exists but doesn't work
- `deleteConstraint` didn't actually delete
- The method is broken

**Why does getting it right matter?**

For medically fragile people:
- Outdated constraints could cause scheduling conflicts
- Users need to modify care plans
- Constraint management must be reliable

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **removeConstraint Signature** - notes/testing-spec-12-relational-constraints.md:87 defines `removeConstraint(id: ConstraintId): void`

2. **Test Plan Reference** - notes/test-plan-12.md:35 states "delete constraint | add, delete | Removed | -"

3. **LAW 3** - notes/testing-spec-12-relational-constraints.md:95 states "LAW 3: Deleting series doesn't delete constraints (soft reference)" - contrasts with constraint deletion behavior

4. **Verification Strategy** - notes/testing-spec-12-relational-constraints.md:217 states "Create, read, delete constraints"

5. **getConstraint Signature** - notes/testing-spec-12-relational-constraints.md:85 defines `getConstraint(id: ConstraintId): RelationalConstraint | null` - used to verify deletion

6. **getAllConstraints Signature** - notes/testing-spec-12-relational-constraints.md:86 defines `getAllConstraints(): RelationalConstraint[]` - used to verify removal from collection

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('delete constraint', async () => {
  const seriesA = await createTestSeries('A');
  const seriesB = await createTestSeries('B');

  const createResult = await addConstraint(adapter, {
    type: 'mustBeBefore',
    source: { type: 'seriesId', seriesId: seriesA },
    dest: { type: 'seriesId', seriesId: seriesB },
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error('Setup failed');

  const constraintId = createResult.value.id;

  // Verify constraint exists before deletion
  const beforeDelete = await getConstraint(adapter, constraintId);
  expect(beforeDelete).not.toBeNull();
  expect(beforeDelete!.id).toBe(constraintId);
  expect(beforeDelete!.type).toBe('mustBeBefore');

  // Also verify in collection
  const allBefore = await getAllConstraints(adapter);
  expect(allBefore.map(c => c.id)).toContain(constraintId);

  // Delete the constraint
  const deleteResult = await deleteConstraint(adapter, constraintId);
  // If deleteConstraint returns a result, verify success
  // expect(deleteResult.ok).toBe(true);

  // Verify constraint is gone from direct lookup
  const afterDelete = await getConstraint(adapter, constraintId);
  expect(afterDelete).toBeNull();

  // Verify constraint is gone from collection
  const allAfter = await getAllConstraints(adapter);
  expect(allAfter.map(c => c.id)).not.toContain(constraintId);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(beforeDelete).not.toBeNull()` - Constraint exists
2. Pre-delete: `expect(beforeDelete!.type).toBe('mustBeBefore')` - Correct constraint
3. Pre-delete: `expect(allBefore.map(c => c.id)).toContain(constraintId)` - In collection
4. Post-delete: `expect(afterDelete).toBeNull()` - Gone from direct lookup
5. Post-delete: `expect(allAfter.map(c => c.id)).not.toContain(constraintId)` - Gone from collection

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies constraint exists before deletion
- Tests both direct lookup and collection after deletion
- Does not include meaningless `toBeDefined()` checks
- Cannot pass if deleteConstraint doesn't work
- Cannot pass if getConstraint or getAllConstraints are broken

**What specific changes would transform this test into its ideal form?**

Remove line 187:
```typescript
expect(adapter.getConstraints).toBeDefined();
```

Add after line 182 (after createResult check):
```typescript
// Verify constraint exists before deletion
const beforeDelete = await getConstraint(adapter, createResult.value.id);
expect(beforeDelete).not.toBeNull();
expect(beforeDelete!.type).toBe('mustBeBefore');
```

The test already has good verification at lines 188-193, just remove the weak `toBeDefined()` check.

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/12-relational-constraints.test.ts lines 170-219 to examine the exact violation at line 187 and full test context

3. **Search for delete constraint specification** - Used Grep tool with pattern `delete constraint|removeConstraint|DELETE.*constraint` in notes/testing-spec-12-relational-constraints.md, finding:
   - Line 87: removeConstraint signature
   - Line 95: LAW 3 about series delete vs constraint delete
   - Line 217: Verification strategy

4. **Search test plan reference** - Used Grep tool with pattern `delete constraint|removeConstraint|remove.*constraint` in notes/test-plan-12.md, finding:
   - Line 35: "delete constraint | add, delete | Removed | -"
   - Line 36: "series delete doesn't delete constraint"

---

## Violation #43: tests/12-relational-constraints.test.ts:193

**Test Name:** `delete constraint`

**Violation Line:**
```typescript
expect(constraint).toBe(null);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that after calling `deleteConstraint`, the constraint is no longer retrievable via `getConstraint`. The specification at notes/testing-spec-12-relational-constraints.md:85 defines `getConstraint(id: ConstraintId): RelationalConstraint | null`.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A constraint is created (lines 176-180)
2. The constraint is deleted (line 184)
3. After deletion, `getConstraint` returns null (line 193)

**Why does this specific test matter?**

After deletion, the constraint should not be retrievable. This confirms:
- The deletion was successful
- The ID no longer maps to any constraint
- The system is in a consistent state

**What are the consequences if this test is wrong or weak?**

The `toBe(null)` assertion is weak because:
1. It only verifies the result is null, not that the constraint existed before
2. It doesn't distinguish between "deleted" and "never existed"
3. Could pass if `addConstraint` never worked
4. Could pass if `getConstraint` always returns null
5. Doesn't verify the constraint's properties before deletion

It could pass when:
- The constraint was never created
- `getConstraint` is broken
- The ID was wrong from the start

**Why does getting it right matter?**

For medically fragile people:
- Constraint management affects care scheduling
- If deletion verification is wrong, users may think constraints are deleted when they aren't
- This could lead to scheduling conflicts

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **getConstraint Signature** - notes/testing-spec-12-relational-constraints.md:85 defines `getConstraint(id: ConstraintId): RelationalConstraint | null`

2. **removeConstraint Signature** - notes/testing-spec-12-relational-constraints.md:87 defines `removeConstraint(id: ConstraintId): void`

3. **Test Plan Reference** - notes/test-plan-12.md:35 states "delete constraint | add, delete | Removed | -"

4. **Return Type** - The signature shows `getConstraint` returns `RelationalConstraint | null`, so null is the expected return for a deleted constraint

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('delete constraint', async () => {
  const seriesA = await createTestSeries('A');
  const seriesB = await createTestSeries('B');

  const createResult = await addConstraint(adapter, {
    type: 'mustBeBefore',
    source: { type: 'seriesId', seriesId: seriesA },
    dest: { type: 'seriesId', seriesId: seriesB },
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error('Setup failed');

  const constraintId = createResult.value.id;

  // CRITICAL: Verify constraint exists and is retrievable BEFORE deletion
  const beforeDelete = await getConstraint(adapter, constraintId);
  expect(beforeDelete).not.toBeNull();
  expect(beforeDelete!.id).toBe(constraintId);
  expect(beforeDelete!.type).toBe('mustBeBefore');

  // Delete the constraint
  await deleteConstraint(adapter, constraintId);

  // Verify constraint is gone
  const afterDelete = await getConstraint(adapter, constraintId);
  expect(afterDelete).toBeNull();

  // Also verify not in collection
  const allConstraints = await getAllConstraints(adapter);
  expect(allConstraints.map(c => c.id)).not.toContain(constraintId);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(beforeDelete).not.toBeNull()` - Constraint exists
2. Pre-delete: `expect(beforeDelete!.id).toBe(constraintId)` - Correct ID
3. Pre-delete: `expect(beforeDelete!.type).toBe('mustBeBefore')` - Correct type
4. Post-delete: `expect(afterDelete).toBeNull()` - Now returns null
5. Post-delete: `expect(allConstraints.map(c => c.id)).not.toContain(constraintId)` - Gone from collection

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the constraint exists before deletion
- Confirms constraint properties before deletion
- Tests null return after deletion
- Tests collection exclusion after deletion
- Cannot pass if addConstraint doesn't work
- Cannot pass if getConstraint always returns null

**What specific changes would transform this test into its ideal form?**

Add after line 182 (after createResult check):
```typescript
// Verify constraint exists before deletion
const beforeDelete = await getConstraint(adapter, createResult.value.id);
expect(beforeDelete).not.toBeNull();
expect(beforeDelete!.id).toBe(createResult.value.id);
expect(beforeDelete!.type).toBe('mustBeBefore');
```

Replace line 193:
```typescript
expect(constraint).toBe(null);
```

With:
```typescript
expect(constraint).toBeNull();
```

(Note: `toBeNull()` is slightly more semantic than `toBe(null)`)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/12-relational-constraints.test.ts lines 170-199 to examine the exact violation at line 193 and full test context

3. **Search for getConstraint null behavior** - Used Grep tool with pattern `getConstraint.*null|returns.*null|delete.*verify|deletion.*verification` in notes/testing-spec-12-relational-constraints.md, finding:
   - Line 85: getConstraint signature showing `RelationalConstraint | null` return type

---

## Violation #44: tests/12-relational-constraints.test.ts:978

**Test Name:** `violation includes description`

**Violation Line:**
```typescript
expect(typeof violations[0].description).toBe('string');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `ConstraintViolation` objects include a meaningful `description` field. The specification at notes/testing-spec-12-relational-constraints.md:157 defines `description: string` as part of the ConstraintViolation type.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Series A is scheduled at 11:00 (line 961)
2. Series B is scheduled at 09:00 (line 967)
3. A `mustBeBefore` constraint from A to B is checked (lines 972-976)
4. Since A is at 11:00 and B is at 09:00, this violates mustBeBefore (A should be before B)
5. The violation has a `description` property that is a string (line 978)
6. The description contains meaningful content (line 980)

**Why does this specific test matter?**

Constraint violation descriptions help users understand:
- What constraint was violated
- Which instances are in conflict
- Why the schedule is invalid

**What are the consequences if this test is wrong or weak?**

The `typeof ... toBe('string')` assertion is weak because:
1. It only verifies the type, not the content
2. An empty string would pass
3. A meaningless string like "x" would pass
4. Doesn't verify the description accurately describes the violation
5. Doesn't verify it mentions the series involved

It could pass when:
- The description is empty
- The description is meaningless
- The description is wrong

**Why does getting it right matter?**

For medically fragile people:
- Clear violation descriptions help caregivers understand scheduling conflicts
- Vague descriptions could lead to confusion
- Users need to know exactly what's wrong to fix it

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **ConstraintViolation Type** - notes/testing-spec-12-relational-constraints.md:153-158 defines:
   ```
   type ConstraintViolation = {
     constraintId: ConstraintId
     sourceInstance: Instance
     destInstance: Instance
     description: string
   }
   ```

2. **LAW 13** - notes/testing-spec-12-relational-constraints.md:164 states "LAW 13: Violation identifies which instances conflict"

3. **Test Plan Reference** - notes/test-plan-12.md:144 states "violation includes description | violation | Human-readable description | LAW 13"

4. **getConstraintViolations** - Function used to check for constraint violations

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('violation includes description', async () => {
  const resultA = await createSeries(adapter, {
    title: 'A',
    startDate: parseDate('2024-01-01'),
    pattern: { type: 'daily' },
    time: parseDateTime('2024-01-01T11:00:00'),  // 11:00
  });
  const resultB = await createSeries(adapter, {
    title: 'B',
    startDate: parseDate('2024-01-01'),
    pattern: { type: 'daily' },
    time: parseDateTime('2024-01-01T09:00:00'),  // 09:00
  });

  if (!resultA.ok || !resultB.ok) throw new Error('Failed to create series');

  // A at 11:00 must be before B at 09:00 - this is violated
  const violations = await getConstraintViolations(adapter, {
    type: 'mustBeBefore',
    source: { type: 'seriesId', seriesId: resultA.value.id },
    dest: { type: 'seriesId', seriesId: resultB.value.id },
  }, { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') });

  // Should have exactly one violation for this day
  expect(violations).toHaveLength(1);

  const violation = violations[0];

  // LAW 13: Violation identifies which instances conflict
  expect(violation.sourceInstance).toBeDefined();
  expect(violation.destInstance).toBeDefined();

  // Description must be a non-empty string
  expect(typeof violation.description).toBe('string');
  expect(violation.description.length).toBeGreaterThan(0);

  // Description should mention the constraint type or the series involved
  // At minimum, it should contain some identifying information
  expect(violation.description).toMatch(/before|11:00|09:00|A|B/i);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(violations).toHaveLength(1)` - Exactly one violation
2. `expect(violation.sourceInstance).toBeDefined()` - Source instance identified
3. `expect(violation.destInstance).toBeDefined()` - Dest instance identified
4. `expect(typeof violation.description).toBe('string')` - Type is string
5. `expect(violation.description.length).toBeGreaterThan(0)` - Non-empty
6. `expect(violation.description).toMatch(/before|A|B/)` - Contains meaningful content

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies there is exactly one violation
- Confirms source and dest instances are identified
- Tests description is non-empty
- Tests description contains meaningful content related to the violation
- Cannot pass with an empty description
- Cannot pass with a meaningless string

**What specific changes would transform this test into its ideal form?**

Add before line 978:
```typescript
// Verify we have exactly one violation
expect(violations).toHaveLength(1);
```

Add after line 978:
```typescript
// Verify description is non-empty
expect(violations[0].description.length).toBeGreaterThan(0);

// Verify description contains meaningful content about the violation
expect(violations[0].description).toMatch(/before|11:00|09:00/i);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/12-relational-constraints.test.ts lines 945-984 to examine the exact violation at line 978 and full test context

3. **Search for violation description specification** - Used Grep tool with pattern `violation.*description|description.*string|ConstraintViolation|getConstraintViolations` in notes/testing-spec-12-relational-constraints.md, finding:
   - Line 153: type ConstraintViolation = {
   - Line 157: description: string

4. **Read ConstraintViolation type** - Used Read tool on notes/testing-spec-12-relational-constraints.md lines 148-187 to find:
   - Lines 153-158: ConstraintViolation type definition
   - Line 164: LAW 13: Violation identifies which instances conflict

5. **Search test plan reference** - Used Grep tool with pattern `violation includes description|description.*string|violation.*content` in notes/test-plan-12.md, finding:
   - Line 144: "violation includes description | violation | Human-readable description | LAW 13"

---

## Violation #45: tests/12-relational-constraints.test.ts:1110

**Test Name:** `INV 1: withinMinutes only for mustBeWithin`

**Violation Line:**
```typescript
expect(constraint).not.toHaveProperty('withinMinutes');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies INV 1 from the constraints specification: "withinMinutes specified iff type = 'mustBeWithin'" (notes/testing-spec-12-relational-constraints.md:195). The `withinMinutes` field should only exist for `mustBeWithin` type constraints.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A `mustBeBefore` constraint is created with `withinMinutes: 30` (lines 1098-1103)
2. This is cast as `any` to bypass TypeScript checks (line 1103)
3. If the operation succeeds, the stored constraint should NOT have `withinMinutes` (line 1110)
4. The system should either ignore the invalid field or strip it

**Why does this specific test matter?**

Type-specific fields ensure data integrity:
- `withinMinutes` only makes sense for `mustBeWithin` constraints
- Storing it for other types could cause confusion or bugs
- The invariant prevents invalid constraint states

**What are the consequences if this test is wrong or weak?**

The `not.toHaveProperty('withinMinutes')` assertion is weak because:
1. It only checks property absence, not that the constraint was properly created
2. Doesn't verify the constraint type was preserved
3. Doesn't verify other constraint properties are correct
4. Could pass if the entire constraint was corrupted

It could pass when:
- The constraint is malformed
- `getConstraint` returns a different constraint
- The constraint is missing other required properties

**Why does getting it right matter?**

For medically fragile people:
- Constraint integrity affects scheduling logic
- Invalid fields could cause unpredictable behavior
- Care schedules must be based on valid data

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **INV 1** - notes/testing-spec-12-relational-constraints.md:195 states "INV 1: withinMinutes specified iff type = 'mustBeWithin'"

2. **withinMinutes Field** - notes/testing-spec-12-relational-constraints.md:19 defines `withinMinutes?: number     // for 'mustBeWithin' only`

3. **INV 2** - notes/testing-spec-12-relational-constraints.md:196 states "INV 2: withinMinutes >= 0 (note: 0 means 'must be adjacent' per B2)"

4. **Test Plan Reference** - notes/test-plan-12.md:170 states "INV 1 | withinMinutes only for mustBeWithin | Add mustBeBefore with withinMinutes"

5. **mustBeWithin Semantics** - notes/testing-spec-12-relational-constraints.md:74-76 defines `mustBeWithin(source, dest, minutes)` semantics

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('INV 1: withinMinutes only for mustBeWithin', async () => {
  const seriesA = await createTestSeries('A');
  const seriesB = await createTestSeries('B');

  // Attempt to create mustBeBefore with withinMinutes (invalid combination)
  const result = await addConstraint(adapter, {
    type: 'mustBeBefore',
    source: { type: 'seriesId', seriesId: seriesA },
    dest: { type: 'seriesId', seriesId: seriesB },
    withinMinutes: 30,
  } as any);

  // Either the system rejects it, or it strips the invalid field
  if (result.ok) {
    const constraint = await getConstraint(adapter, result.value.id);
    expect(constraint).not.toBeNull();

    // Verify the constraint was stored correctly
    expect(constraint!.id).toBe(result.value.id);
    expect(constraint!.type).toBe('mustBeBefore');
    expect(constraint!.source).toEqual({ type: 'seriesId', seriesId: seriesA });
    expect(constraint!.dest).toEqual({ type: 'seriesId', seriesId: seriesB });

    // INV 1: withinMinutes should NOT be present for mustBeBefore
    expect(constraint).not.toHaveProperty('withinMinutes');
    expect((constraint as any).withinMinutes).toBeUndefined();

    // Verify constraint appears in list
    const allConstraints = await getAllConstraints(adapter);
    expect(allConstraints.find(c => c.id === result.value.id)).toBeDefined();
  } else {
    // If system rejects, verify it's for the right reason
    expect(result.error.type).toMatch(/invalid|withinMinutes/i);
  }
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(constraint).not.toBeNull()` - Constraint was retrieved
2. `expect(constraint!.id).toBe(result.value.id)` - Correct constraint
3. `expect(constraint!.type).toBe('mustBeBefore')` - Type preserved
4. `expect(constraint!.source).toEqual(...)` - Source preserved
5. `expect(constraint!.dest).toEqual(...)` - Dest preserved
6. `expect(constraint).not.toHaveProperty('withinMinutes')` - Invalid field absent
7. `expect((constraint as any).withinMinutes).toBeUndefined()` - Double-check

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the constraint was stored correctly
- Confirms all valid properties are present
- Tests the property absence with multiple methods
- Handles both success and rejection cases
- Cannot pass if the constraint is corrupted
- Cannot pass if the wrong constraint is returned

**What specific changes would transform this test into its ideal form?**

Add before line 1110:
```typescript
expect(constraint).not.toBeNull();
expect(constraint!.id).toBe(result.value.id);
expect(constraint!.source).toEqual({ type: 'seriesId', seriesId: seriesA });
expect(constraint!.dest).toEqual({ type: 'seriesId', seriesId: seriesB });
```

Add after line 1110:
```typescript
// Double-check with explicit undefined check
expect((constraint as any).withinMinutes).toBeUndefined();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/12-relational-constraints.test.ts lines 1085-1119 to examine the exact violation at line 1110 and full test context

3. **Search for withinMinutes and INV 1** - Used Grep tool with pattern `withinMinutes|INV.*1|mustBeWithin.*only` in notes/testing-spec-12-relational-constraints.md, finding:
   - Line 19: withinMinutes?: number // for 'mustBeWithin' only
   - Line 195: INV 1: withinMinutes specified iff type = 'mustBeWithin'
   - Line 196: INV 2: withinMinutes >= 0

4. **Search test plan reference** - Used Grep tool with pattern `INV 1|withinMinutes only|mustBeWithin.*only` in notes/test-plan-12.md, finding:
   - Line 170: "INV 1 | withinMinutes only for mustBeWithin | Add mustBeBefore with withinMinutes"

5. **Read test plan invariants section** - Used Read tool on notes/test-plan-12.md lines 165-184 to find:
   - Line 170: INV 1 test description
   - Line 171: INV 2 test description
   - Line 172: INV 3 test description

---

## Violation #46: tests/13-reflow-algorithm.test.ts:163

**Test Name:** `cancelled excluded - cancelled instance not generated`

**Violation Line:**
```typescript
expect(result).toHaveLength(0); // Cancelled instances correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 3 from the reflow algorithm specification: "Cancelled instances excluded" (notes/testing-spec-13-reflow-algorithm.md:100). When an instance is cancelled, it should not be generated during the instance generation phase of reflow.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created with a cancelled flag (line 159)
2. When `generateInstances` is called (line 161)
3. The result should have length 0 (line 163)
4. The cancelled instance is excluded from generation

**Why does this specific test matter?**

Cancelled instances should never appear in schedules:
- Users cancel instances intentionally
- Including them would defeat the purpose of cancellation
- The reflow algorithm must respect cancellations

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the series was actually set up correctly
3. It doesn't verify that non-cancelled instances WOULD be generated
4. Could pass if `generateInstances` always returns `[]`
5. Could pass if the series setup is wrong

It could pass when:
- `generateInstances` is broken
- The series has no patterns
- The input is malformed
- The date range doesn't include any instances

**Why does getting it right matter?**

For medically fragile people:
- Cancelled care tasks should never appear
- Caregivers shouldn't be shown cancelled tasks
- The schedule must accurately reflect what's active

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 3** - notes/testing-spec-13-reflow-algorithm.md:100 states "LAW 3: Cancelled instances excluded"

2. **Test Plan Reference** - notes/test-plan-13.md:23 states "cancelled excluded | cancel one instance | Instance not generated | LAW 3"

3. **generateInstances Signature** - notes/testing-spec-13-reflow-algorithm.md:50 defines `generateInstances(series: Series[], range: DateRange): RawInstance[]`

4. **Algorithm Line 72** - notes/testing-spec-13-reflow-algorithm.md:72 shows `if isCancelled(s.id, d): continue` in the generation algorithm

5. **Instance Exceptions LAW 1** - notes/testing-spec-09-instance-exceptions.md:50 states "LAW 1: Cancelled instance excluded from getSchedule results"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('cancelled excluded - cancelled instance not generated', () => {
  // First, verify non-cancelled instance IS generated
  const nonCancelledInput = createReflowInput([createBasicSeries('A', { cancelled: false })]);
  const nonCancelledResult = generateInstances(nonCancelledInput);
  expect(nonCancelledResult.length).toBeGreaterThan(0);
  expect(nonCancelledResult[0].seriesId).toBe(seriesId('A'));

  // Now verify cancelled instance is NOT generated
  const cancelledInput = createReflowInput([createBasicSeries('A', { cancelled: true })]);
  const cancelledResult = generateInstances(cancelledInput);

  // LAW 3: Cancelled instances excluded
  expect(cancelledResult).toHaveLength(0);

  // Double-check: no instances with this series ID
  expect(cancelledResult.filter(i => i.seriesId === seriesId('A'))).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-test: `expect(nonCancelledResult.length).toBeGreaterThan(0)` - Non-cancelled generates
2. Pre-test: `expect(nonCancelledResult[0].seriesId).toBe(seriesId('A'))` - Correct series
3. Post-cancel: `expect(cancelledResult).toHaveLength(0)` - Cancelled excluded
4. Post-cancel: `expect(cancelledResult.filter(...)).toEqual([])` - No instances for series

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- First verifies that non-cancelled instances ARE generated
- Then verifies cancelled instances are NOT generated
- Tests the contrast between cancelled and non-cancelled
- Cannot pass if `generateInstances` always returns []
- Cannot pass if the series setup is wrong

**What specific changes would transform this test into its ideal form?**

Add before line 159:
```typescript
// First verify non-cancelled instance is generated
const nonCancelledInput = createReflowInput([createBasicSeries('A', { cancelled: false })]);
const nonCancelledResult = generateInstances(nonCancelledInput);
expect(nonCancelledResult.length).toBeGreaterThan(0);
expect(nonCancelledResult[0].seriesId).toBe(seriesId('A'));
```

Replace line 163:
```typescript
expect(result).toHaveLength(0);
```

With:
```typescript
expect(result).toHaveLength(0);
expect(result.filter(i => i.seriesId === seriesId('A'))).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 145-194 to examine the exact violation at line 163 and full test context

3. **Find specification file** - Used Glob tool with pattern `notes/testing-spec-13*.md` to find testing-spec-13-reflow-algorithm.md

4. **Search for cancelled instance specification** - Used Grep tool with pattern `cancelled.*excluded|cancelled.*instance|exclude.*cancelled|generateInstances` in notes directory, finding many references

5. **Read reflow algorithm specification** - Used Read tool on notes/testing-spec-13-reflow-algorithm.md lines 40-99 to find:
   - Line 50: generateInstances signature
   - Line 72: isCancelled check in algorithm
   - Lines 98-100: LAW 1-3

6. **Search for LAW 3** - Used Grep tool with pattern `LAW 3|cancelled.*excluded|exclude.*cancelled` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 100: LAW 3: Cancelled instances excluded

7. **Read test plan** - Used Read tool on notes/test-plan-13.md lines 19-38 to find:
   - Line 23: "cancelled excluded | cancel one instance | Instance not generated | LAW 3"

---

## Violation #47: tests/13-reflow-algorithm.test.ts:225

**Test Name:** `pattern inactive when condition false - instances not generated`

**Violation Line:**
```typescript
expect(result).toHaveLength(0); // Condition false - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies the condition evaluation logic in the reflow algorithm. According to notes/testing-spec-13-reflow-algorithm.md:87-92, patterns with unsatisfied conditions should not generate instances.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created with `conditionSatisfied: false` (line 220)
2. When `generateInstances` is called (line 223)
3. The result should have length 0 (line 225)
4. Inactive patterns don't generate instances

**Why does this specific test matter?**

Conditional patterns allow users to:
- Have patterns that only activate under certain conditions
- Control when series instances are generated
- Support complex scheduling rules

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the condition was actually evaluated
3. It doesn't verify that the same series WITH a true condition WOULD generate
4. Could pass if `generateInstances` always returns `[]`
5. Could pass if the series setup is wrong

It could pass when:
- `generateInstances` is broken
- The series has no patterns at all
- The input is malformed

**Why does getting it right matter?**

For medically fragile people:
- Conditional patterns control when care tasks appear
- Wrong evaluation could show tasks that shouldn't appear
- Or hide tasks that should appear

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Condition Evaluation Algorithm** - notes/testing-spec-13-reflow-algorithm.md:87-92 shows:
   ```
   for each pattern p in s.patterns:
     if p.conditionId ≠ null:
       condition = getCondition(p.conditionId)
       if not evaluateCondition(condition, completionStore, today):
         // pattern not active, skip its instances
   ```

2. **LAW 5** - notes/testing-spec-13-reflow-algorithm.md:102 states "LAW 5: Conditions evaluated as of current date"

3. **Test Plan Reference** - notes/test-plan-13.md:33 states "pattern inactive when condition false | condition not satisfied | Instances not generated"

4. **Contrast Test** - The previous test at lines 208-216 shows "pattern active when condition true - instances generated" which uses `conditionSatisfied: true`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('pattern inactive when condition false - instances not generated', () => {
  // First, verify condition=true DOES generate instances
  const activeInput = createReflowInput([
    createBasicSeries('A', { conditionSatisfied: true }),
  ]);
  const activeResult = generateInstances(activeInput);
  expect(activeResult.length).toBeGreaterThan(0);
  expect(activeResult[0].seriesId).toBe(seriesId('A'));

  // Now verify condition=false does NOT generate instances
  const inactiveInput = createReflowInput([
    createBasicSeries('A', { conditionSatisfied: false }),
  ]);
  const inactiveResult = generateInstances(inactiveInput);

  // LAW 5: Condition evaluated, pattern inactive
  expect(inactiveResult).toHaveLength(0);
  expect(inactiveResult.filter(i => i.seriesId === seriesId('A'))).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-test (condition=true): `expect(activeResult.length).toBeGreaterThan(0)` - Active generates
2. Pre-test: `expect(activeResult[0].seriesId).toBe(seriesId('A'))` - Correct series
3. Post-test (condition=false): `expect(inactiveResult).toHaveLength(0)` - Inactive doesn't generate
4. Post-test: `expect(inactiveResult.filter(...)).toEqual([])` - No instances for series

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- First verifies that condition=true DOES generate instances
- Then verifies that condition=false does NOT
- Tests the contrast between active and inactive
- Cannot pass if `generateInstances` always returns []
- Cannot pass if conditions are ignored

**What specific changes would transform this test into its ideal form?**

Add before line 218:
```typescript
// First verify active condition generates instances
const activeInput = createReflowInput([
  createBasicSeries('A', { conditionSatisfied: true }),
]);
const activeResult = generateInstances(activeInput);
expect(activeResult.length).toBeGreaterThan(0);
```

Replace line 225:
```typescript
expect(result).toHaveLength(0);
```

With:
```typescript
expect(result).toHaveLength(0);
expect(result.filter(i => i.seriesId === seriesId('A'))).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 205-249 to examine the exact violation at line 225 and full test context

3. **Search for condition evaluation specification** - Used Grep tool with pattern `condition.*false|inactive.*condition|pattern.*inactive|LAW 5|condition.*evaluation` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 102: LAW 5: Conditions evaluated as of current date

4. **Search test plan reference** - Used Grep tool with pattern `pattern inactive|condition false|inactive.*condition|not generated` in notes/test-plan-13.md, finding:
   - Line 33: "pattern inactive when condition false | condition not satisfied | Instances not generated"

5. **Read condition evaluation section** - Used Read tool on notes/testing-spec-13-reflow-algorithm.md lines 82-111 to find:
   - Lines 87-92: Condition evaluation algorithm
   - Line 102: LAW 5

---

## Violation #48: tests/13-reflow-algorithm.test.ts:288

**Test Name:** `domain bounded by wiggle days - daysBefore=1 daysAfter=1 gives 3 days`

**Violation Line:**
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 7 from the reflow algorithm specification: "Flexible domain bounded by wiggle config" (notes/testing-spec-13-reflow-algorithm.md:207). With daysBefore=1 and daysAfter=1, the domain should span 3 days (the day before, the day of, and the day after).

**What functionality or behavior is it verifying?**

The test verifies that:
1. An instance is created with `daysBefore: 1` and `daysAfter: 1` (lines 280-281)
2. Ideal time is Jan 15 at 09:00 (line 279)
3. `computeDomains` is called (line 285)
4. The domain is non-empty (line 288)
5. The domain spans exactly 3 days: Jan 14, 15, 16 (lines 291-292)

**Why does this specific test matter?**

Wiggle days allow flexible scheduling:
- Users can move tasks earlier or later
- The domain defines where the task CAN be scheduled
- daysBefore=1, daysAfter=1 means the task can be ±1 day from its ideal

**What are the consequences if this test is wrong or weak?**

The `toBeGreaterThan(0)` assertion is weak because:
1. It only verifies the domain is non-empty
2. It doesn't verify the domain has the correct size
3. It doesn't verify the domain contains the correct dates
4. Could pass with just 1 slot

Note: The stronger assertion at lines 291-292 (`expect(days.size).toBe(3)`) makes this violation less severe, but the weak assertion at line 288 still adds no real test value.

**Why does getting it right matter?**

For medically fragile people:
- Wiggle days provide scheduling flexibility
- Incorrect domain size could constrain or over-expand options
- Users need predictable behavior

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 7** - notes/testing-spec-13-reflow-algorithm.md:207 states "LAW 7: Flexible domain bounded by wiggle config"

2. **computeDomains Signature** - notes/testing-spec-13-reflow-algorithm.md:167 defines `computeDomains(instances: RawInstance[]): Map<InstanceKey, TimeSlot[]>`

3. **Domain Calculation Algorithm** - notes/testing-spec-13-reflow-algorithm.md:179-184:
   ```
   domain(flexible instance) =
     let validDays = [instance.instanceDate - wiggle.daysBefore,
                      instance.instanceDate + wiggle.daysAfter]
     let validTimes = wiggle.timeWindow ?? [instance.idealTime, instance.idealTime]
     discretize(validDays × validTimes, granularity=5min)
   ```

4. **Test Plan Reference** - notes/test-plan-13.md:51 states "domain bounded by wiggle days | daysBefore=1, daysAfter=1 | 3 days of slots | LAW 7"

5. **LAW 8** - notes/testing-spec-13-reflow-algorithm.md:208 states "LAW 8: Domain discretized to 5-minute increments (configurable)"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('domain bounded by wiggle days - daysBefore=1 daysAfter=1 gives 3 days', () => {
  const instances = [
    {
      seriesId: seriesId('A'),
      fixed: false,
      idealTime: datetime('2025-01-15T09:00:00'),
      daysBefore: 1,
      daysAfter: 1,
    },
  ] as Instance[];

  const domains = computeDomains(instances);
  const domain = domains.get(instances[0]);

  // Domain must exist
  expect(domain).toBeDefined();
  expect(domain).not.toBeNull();

  // LAW 7: Domain should span exactly 3 days (Jan 14, 15, 16)
  const days = new Set(domain!.map((dt) => dt.substring(0, 10)));
  expect(days.size).toBe(3);

  // Verify the exact days
  expect(days.has('2025-01-14')).toBe(true);
  expect(days.has('2025-01-15')).toBe(true);
  expect(days.has('2025-01-16')).toBe(true);

  // Verify no other days
  days.forEach(day => {
    expect(['2025-01-14', '2025-01-15', '2025-01-16']).toContain(day);
  });

  // LAW 8: Slots should be at 5-minute granularity (optional verification)
  domain!.forEach(slot => {
    const minutes = parseInt(slot.substring(14, 16));
    expect(minutes % 5).toBe(0);
  });
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(domain).toBeDefined()` - Domain exists
2. `expect(days.size).toBe(3)` - Exactly 3 days
3. `expect(days.has('2025-01-14')).toBe(true)` - Day before included
4. `expect(days.has('2025-01-15')).toBe(true)` - Ideal day included
5. `expect(days.has('2025-01-16')).toBe(true)` - Day after included
6. `expect(minutes % 5).toBe(0)` - 5-minute granularity (LAW 8)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Removes the weak `toBeGreaterThan(0)` check
- Verifies exact days are present
- Verifies no unexpected days are present
- Optionally verifies granularity
- Cannot pass with wrong domain

**What specific changes would transform this test into its ideal form?**

Remove line 288:
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

Add after line 292:
```typescript
// Verify the exact days
expect(days.has('2025-01-14')).toBe(true);
expect(days.has('2025-01-15')).toBe(true);
expect(days.has('2025-01-16')).toBe(true);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 270-314 to examine the exact violation at line 288 and full test context

3. **Search for domain specification** - Used Grep tool with pattern `computeDomains|domain.*bounded|wiggle.*days|daysBefore|daysAfter` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 167: computeDomains signature
   - Lines 180-181: validDays calculation
   - Line 207: LAW 7: Flexible domain bounded by wiggle config

4. **Search test plan reference** - Used Grep tool with pattern `domain bounded|wiggle days|3 days|daysBefore.*daysAfter` in notes/test-plan-13.md, finding:
   - Line 51: "domain bounded by wiggle days | daysBefore=1, daysAfter=1 | 3 days of slots | LAW 7"

5. **Read domain computation specification** - Used Read tool on notes/testing-spec-13-reflow-algorithm.md lines 160-219 to find:
   - Lines 167: computeDomains signature
   - Lines 179-185: Domain calculation algorithm
   - Lines 206-209: LAW 6-9 properties

---

## Violation #49: tests/13-reflow-algorithm.test.ts:308

**Test Name:** `domain bounded by time window - only those hours`

**Violation Line:**
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 7 from the reflow algorithm specification: "Flexible domain bounded by wiggle config" (notes/testing-spec-13-reflow-algorithm.md:207). Specifically, it tests that the time window restricts slots to only hours within the window.

**What functionality or behavior is it verifying?**

The test verifies that:
1. An instance is created with timeWindow 08:00-10:00 (line 301)
2. `computeDomains` is called (line 305)
3. The domain is non-empty (line 308)
4. All slots in the domain have hours between 8 and 10 (lines 311-315)

**Why does this specific test matter?**

Time windows allow users to:
- Restrict scheduling to specific hours
- Ensure tasks happen during appropriate times
- Control when flexible tasks can be scheduled

**What are the consequences if this test is wrong or weak?**

The `toBeGreaterThan(0)` assertion is weak because:
1. It only verifies the domain is non-empty
2. It doesn't verify the domain size is reasonable
3. It doesn't verify all expected hours are covered
4. Could pass with just 1 slot

Note: The stronger assertions at lines 311-315 verify the hour bounds, making this violation less severe.

**Why does getting it right matter?**

For medically fragile people:
- Time windows constrain when tasks can happen
- Medications may need to be given during specific hours
- Incorrect windows could schedule care at wrong times

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 7** - notes/testing-spec-13-reflow-algorithm.md:207 states "LAW 7: Flexible domain bounded by wiggle config"

2. **Domain Calculation Algorithm** - notes/testing-spec-13-reflow-algorithm.md:182-184:
   ```
   let validTimes = wiggle.timeWindow ?? [instance.idealTime, instance.idealTime]
   discretize(validDays × validTimes, granularity=5min)
   ```

3. **Test Plan Reference** - notes/test-plan-13.md:52 states "domain bounded by time window | timeWindow 08:00-10:00 | Only those hours | LAW 7"

4. **computeDomains Signature** - notes/testing-spec-13-reflow-algorithm.md:167 defines `computeDomains(instances: RawInstance[]): Map<InstanceKey, TimeSlot[]>`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('domain bounded by time window - only those hours', () => {
  const instances = [
    {
      seriesId: seriesId('A'),
      fixed: false,
      idealTime: datetime('2025-01-15T09:00:00'),
      timeWindow: { start: time('08:00'), end: time('10:00') },
    },
  ] as Instance[];

  const domains = computeDomains(instances);
  const domain = domains.get(instances[0]);

  // Domain must exist
  expect(domain).toBeDefined();
  expect(domain).not.toBeNull();

  // Domain should have slots (not just rely on toBeGreaterThan)
  expect(domain!.length).toBeGreaterThanOrEqual(1);

  // LAW 7: All slots should be within the time window
  domain!.forEach((dt) => {
    const hour = parseInt(dt.substring(11, 13));
    const minute = parseInt(dt.substring(14, 16));
    const timeInMinutes = hour * 60 + minute;

    // 08:00 = 480 minutes, 10:00 = 600 minutes
    expect(timeInMinutes).toBeGreaterThanOrEqual(480);
    expect(timeInMinutes).toBeLessThanOrEqual(600);
  });

  // Verify the window is actually used (should have slots at 08:xx, 09:xx, and 10:xx)
  const hours = new Set(domain!.map(dt => parseInt(dt.substring(11, 13))));
  expect(hours.has(8)).toBe(true);
  expect(hours.has(9)).toBe(true);
  // 10:00 exactly might or might not be included depending on boundary handling
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(domain).toBeDefined()` - Domain exists
2. `expect(domain!.length).toBeGreaterThanOrEqual(1)` - Has slots
3. `expect(timeInMinutes).toBeGreaterThanOrEqual(480)` - After 08:00
4. `expect(timeInMinutes).toBeLessThanOrEqual(600)` - Before 10:00
5. `expect(hours.has(8)).toBe(true)` - Hour 8 covered
6. `expect(hours.has(9)).toBe(true)` - Hour 9 covered

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific hours are present
- Tests boundary cases precisely
- Verifies the window is actually constraining
- Cannot pass with wrong time slots

**What specific changes would transform this test into its ideal form?**

Remove line 308 (or replace with more specific check):
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

Add after line 315:
```typescript
// Verify specific hours are covered
const hours = new Set(domain!.map(dt => parseInt(dt.substring(11, 13))));
expect(hours.has(8)).toBe(true);
expect(hours.has(9)).toBe(true);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 293-337 to examine the exact violation at line 308 and full test context

3. **Search for timeWindow specification** - Used Grep tool with pattern `timeWindow|time.*window|validTimes|bounded.*time` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 182: validTimes = wiggle.timeWindow
   - Line 184: discretize algorithm

---

## Violation #50: tests/13-reflow-algorithm.test.ts:331

**Test Name:** `domain discretized - 5-minute increments`

**Violation Line:**
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 8 from the reflow algorithm specification: "Domain discretized to 5-minute increments (configurable)" (notes/testing-spec-13-reflow-algorithm.md:208). All time slots in a domain should be at 5-minute boundaries.

**What functionality or behavior is it verifying?**

The test verifies that:
1. An instance is created with a 1-hour time window (09:00-10:00) (lines 323-324)
2. `computeDomains` is called (line 328)
3. The domain is non-empty (line 331)
4. All slots have minutes divisible by 5 (lines 334-336)

**Why does this specific test matter?**

Discretization reduces the search space:
- Without discretization, there would be infinite possible times
- 5-minute increments provide reasonable precision
- The reflow algorithm needs finite domains

**What are the consequences if this test is wrong or weak?**

The `toBeGreaterThan(0)` assertion is weak because:
1. It only verifies the domain is non-empty
2. It doesn't verify the domain has a reasonable number of slots
3. It doesn't verify that discretization actually happened
4. Could pass with just 1 slot

Note: The stronger assertions at lines 334-336 verify the 5-minute divisibility.

**Why does getting it right matter?**

For medically fragile people:
- Discretization affects scheduling precision
- Too coarse could miss good options
- Too fine could make the problem intractable

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 8** - notes/testing-spec-13-reflow-algorithm.md:208 states "LAW 8: Domain discretized to 5-minute increments (configurable)"

2. **Discretization in Algorithm** - notes/testing-spec-13-reflow-algorithm.md:184: `discretize(validDays × validTimes, granularity=5min)`

3. **Test Plan Reference** - notes/test-plan-13.md:53 states "domain discretized | any flexible | 5-minute increments | LAW 8"

4. **computeDomains Signature** - notes/testing-spec-13-reflow-algorithm.md:167 defines `computeDomains(instances: RawInstance[]): Map<InstanceKey, TimeSlot[]>`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('domain discretized - 5-minute increments', () => {
  const instances = [
    {
      seriesId: seriesId('A'),
      fixed: false,
      idealTime: datetime('2025-01-15T09:00:00'),
      timeWindow: { start: time('09:00'), end: time('10:00') },
    },
  ] as Instance[];

  const domains = computeDomains(instances);
  const domain = domains.get(instances[0]);

  expect(domain).toBeDefined();
  expect(domain).not.toBeNull();

  // For a 1-hour window at 5-min granularity, expect 13 slots (09:00, 09:05, ..., 10:00)
  // Or 12 slots if end is exclusive (09:00, 09:05, ..., 09:55)
  expect(domain!.length).toBeGreaterThanOrEqual(12);
  expect(domain!.length).toBeLessThanOrEqual(13);

  // LAW 8: All slots should have minutes divisible by 5
  domain!.forEach((dt) => {
    const minutes = parseInt(dt.substring(14, 16));
    expect(minutes % 5).toBe(0);
  });

  // Verify specific expected slots exist
  const minuteSet = new Set(domain!.map(dt => dt.substring(14, 16)));
  expect(minuteSet.has('00')).toBe(true);
  expect(minuteSet.has('05')).toBe(true);
  expect(minuteSet.has('10')).toBe(true);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(domain).toBeDefined()` - Domain exists
2. `expect(domain!.length).toBeGreaterThanOrEqual(12)` - Reasonable slot count
3. `expect(minutes % 5).toBe(0)` - All at 5-min boundaries
4. `expect(minuteSet.has('00')).toBe(true)` - Expected slots present

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies expected slot count
- Tests that specific slots exist
- Verifies all slots are at 5-minute increments
- Cannot pass with just 1 slot
- Cannot pass without discretization

**What specific changes would transform this test into its ideal form?**

Replace line 331:
```typescript
expect(domain!.length).toBeGreaterThan(0);
```

With:
```typescript
// 1-hour window at 5-min granularity = ~12-13 slots
expect(domain!.length).toBeGreaterThanOrEqual(12);
expect(domain!.length).toBeLessThanOrEqual(13);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/13-reflow-algorithm.test.ts lines 316-355 to examine the exact violation at line 331 and full test context

3. **Search for discretization specification** - Used Grep tool with pattern `discretize|5-minute|LAW 8|granularity` in notes/testing-spec-13-reflow-algorithm.md, finding:
   - Line 184: discretize algorithm with granularity=5min
   - Line 208: LAW 8: Domain discretized to 5-minute increments

4. **Search test plan reference** - Used Grep tool with pattern `discretized|5-minute|increment|LAW 8` in notes/test-plan-13.md, finding:
   - Line 53: "domain discretized | any flexible | 5-minute increments | LAW 8"

---
