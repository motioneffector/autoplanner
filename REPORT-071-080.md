# REPORT-071-080: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #71-80 as specified in REPORT-SPEC.md.

---

## Violation #71: tests/16-integration.test.ts:302

**Test Name:** `conditions update immediately after completion`

**Violation Line:**
```typescript
expect(weightsBefore).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This integration test verifies that conditions update immediately when completions are logged. Before 7 walks are logged, no weight training instances should appear. After logging 7 walks, weight training instances appear immediately.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Before meeting the condition (7 walks), no weight instances appear (lines 299-302)
2. After logging 7 walks, weight instances appear (lines 304-314)
3. The schedule update is immediate, not delayed

**Why does this specific test matter?**

Immediate condition updates are essential:
- Caregivers need real-time schedule updates
- Delayed updates could show stale schedules
- Progression must be reflected immediately

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the weight series exists
3. Could pass if weight series wasn't created
4. Doesn't verify the condition is actually blocking

**Why does getting it right matter?**

For medically fragile people:
- Care schedules must reflect current state
- Delayed updates could miss important tasks
- Real-time accuracy is critical

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:27-28 describes:
   - Step 1: "Initial state | Walks every other day, no weights"
   - Step 2: "Log 7 walks | Pattern transitions to daily, weights appear | PROP 1, PROP 3, PROP 4"

2. **State Machine** - notes/test-plan-16.md:17-21 defines state transitions:
   - Deconditioned: < 7 walks, no weights
   - Conditioning: >= 7 walks, weights appear

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('conditions update immediately after completion', async () => {
  // Verify weight series exists but is condition-blocked
  const weightSeries = await planner.getSeries(weightSeriesId);
  expect(weightSeries).toBeDefined();

  const scheduleBefore = await planner.getSchedule(date('2025-01-15'), date('2025-01-21'));
  const weightsBefore = scheduleBefore.instances.filter((i) => i.seriesId === weightSeriesId);

  // Verify no weight instances before condition is met
  expect(weightsBefore).toHaveLength(0);
  expect(weightsBefore).toEqual([]);

  // Log 7 walks to meet condition
  for (let i = 1; i <= 7; i++) {
    await planner.logCompletion(walkSeriesId, date(`2025-01-${String(i * 2).padStart(2, '0')}`));
  }

  const scheduleAfter = await planner.getSchedule(date('2025-01-15'), date('2025-01-21'));
  const weightsAfter = scheduleAfter.instances.filter((i) => i.seriesId === weightSeriesId);

  // Verify weights appear immediately after condition is met
  expect(weightsAfter).toHaveLength(1);
  expect(weightsAfter.map((i) => i.date)).toEqual([date('2025-01-20')]);
  expect(weightsAfter[0].seriesId).toBe(weightSeriesId);
  expect(weightsAfter[0].time).toContain('08:00');
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(weightSeries).toBeDefined()` - Series exists
2. `expect(weightsBefore).toHaveLength(0)` - No weights before
3. `expect(weightsBefore).toEqual([])` - Empty array
4. `expect(weightsAfter).toHaveLength(1)` - One weight after
5. `expect(weightsAfter[0].seriesId).toBe(weightSeriesId)` - Correct series

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies weight series exists
- Verifies no weights before condition
- Verifies weights appear after condition
- Uses both length and equality checks
- Cannot pass if series doesn't exist

**What specific changes would transform this test into its ideal form?**

Add before line 299:
```typescript
// Verify weight series exists
const weightSeries = await planner.getSeries(weightSeriesId);
expect(weightSeries).toBeDefined();
```

Replace line 302:
```typescript
expect(weightsBefore).toEqual([]);
```

With:
```typescript
expect(weightsBefore).toHaveLength(0);
expect(weightsBefore).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 280-339 to examine the exact violation at line 302 and full test context

3. **Read test plan** - Used Read tool on notes/test-plan-16.md lines 1-80 to find:
   - Lines 17-21: State machine definition
   - Lines 27-28: Test steps 1-2 describing initial state and condition transition

---

## Violation #72: tests/16-integration.test.ts:321

**Test Name:** `multiple state transitions work correctly`

**Violation Line:**
```typescript
expect(initialWeights).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies the complete state machine progression: Deconditioned → Conditioning → Conditioned. It tests that multiple state transitions work correctly in sequence.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Initial state (Deconditioned): no weight instances (lines 318-321)
2. After 7 walks (Conditioning): weights appear Mon/Fri (lines 323-332)
3. After 4 weights (Conditioned): weights appear Mon/Wed/Fri (lines 334-348)

**Why does this specific test matter?**

State machine progression is the core exercise scenario:
- Users progress from deconditioned to conditioned
- Each state has different schedules
- Transitions must work correctly in sequence

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the weight series exists
3. Could pass if weight series wasn't created
4. Doesn't verify the condition is actually blocking

**Why does getting it right matter?**

For medically fragile people:
- Progressive exercise programs require correct staging
- Wrong state could lead to inappropriate exercise levels
- State transitions must be reliable

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **State Machine** - notes/test-plan-16.md:17-21 defines:
   - Deconditioned: < 7 walks, no weights
   - Conditioning: >= 7 walks, Mon/Fri weights
   - Conditioned: >= 4 weights, Mon/Wed/Fri weights

2. **Test Methodology** - notes/test-plan-16.md:279 states "Test state transitions by logging completions and verifying schedule changes"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('multiple state transitions work correctly', async () => {
  // Verify weight series exists
  const weightSeries = await planner.getSeries(weightSeriesId);
  expect(weightSeries).toBeDefined();

  // Start deconditioned - no weight training instances yet
  let schedule = await planner.getSchedule(date('2025-01-01'), date('2025-01-07'));
  const initialWeights = schedule.instances.filter((i) => i.seriesId === weightSeriesId);
  expect(initialWeights).toHaveLength(0);
  expect(initialWeights).toEqual([]);

  // Move to conditioning
  for (let i = 1; i <= 7; i++) {
    await planner.logCompletion(walkSeriesId, date(`2025-01-${String(i * 2).padStart(2, '0')}`));
  }

  schedule = await planner.getSchedule(date('2025-01-15'), date('2025-01-21'));
  const conditioningWeights = schedule.instances.filter((i) => i.seriesId === weightSeriesId);
  expect(conditioningWeights).toHaveLength(1);
  expect(conditioningWeights.map((i) => i.date)).toEqual([date('2025-01-20')]);

  // Move to conditioned
  for (let i = 0; i < 4; i++) {
    await planner.logCompletion(weightSeriesId, date(`2025-01-${String(20 + i * 3).padStart(2, '0')}`));
  }

  schedule = await planner.getSchedule(date('2025-02-01'), date('2025-02-07'));
  const weights = schedule.instances.filter((i) => i.seriesId === weightSeriesId);
  expect(weights).toHaveLength(3);
  expect(weights.map((i) => i.date)).toEqual([
    date('2025-02-03'), date('2025-02-05'), date('2025-02-07'),
  ]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(weightSeries).toBeDefined()` - Series exists
2. `expect(initialWeights).toHaveLength(0)` - No weights initially
3. `expect(initialWeights).toEqual([])` - Empty array
4. `expect(conditioningWeights).toHaveLength(1)` - One weight in conditioning
5. `expect(weights).toHaveLength(3)` - Three weights when conditioned

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies weight series exists first
- Verifies each state has correct weight count
- Uses both length and equality checks
- Cannot pass if series doesn't exist

**What specific changes would transform this test into its ideal form?**

Add before line 319:
```typescript
// Verify weight series exists
const weightSeries = await planner.getSeries(weightSeriesId);
expect(weightSeries).toBeDefined();
```

Replace line 321:
```typescript
expect(initialWeights).toEqual([]);
```

With:
```typescript
expect(initialWeights).toHaveLength(0);
expect(initialWeights).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 315-364 to examine the exact violation at line 321 and full test context

3. **Search for state transition test plan** - Used Grep tool with pattern `state transition|multiple.*transition|transition.*correct` in notes/test-plan-16.md, finding:
   - Line 279: "Test state transitions by logging completions and verifying schedule changes"

---

## Violation #73: tests/16-integration.test.ts:402

**Test Name:** `PROP 5: cycling preserved across pattern deactivation/reactivation`

**Violation Line:**
```typescript
expect(weightsDeactivated).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies PROP 5: that the cycling index is preserved when a pattern is deactivated and later reactivated. If cycling was at "Workout B", it should stay at "B" after reactivation, not reset to "A".

**What functionality or behavior is it verifying?**

The test verifies that:
1. Initial condition met, cycling advances to B (lines 385-394)
2. Walk count window slides, weights deactivate (lines 396-402)
3. After reactivation, cycling is still at B (lines 404-412)

**Why does this specific test matter?**

Cycling preservation is critical:
- Users expect to continue where they left off
- Resetting would repeat workouts unnecessarily
- Exercise variation depends on correct cycling

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the deactivation reason
3. Could pass if weights were never created
4. Doesn't verify the condition actually changed

**Why does getting it right matter?**

For medically fragile people:
- Exercise variety is important for health
- Repeating the same workout could cause overuse injuries
- Cycling must be reliable across state changes

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **PROP 5 Reference** - notes/test-plan-16.md:32 states "6 | Check cycling | Cycling index preserved (PROP 5) | PROP 5"

2. **State Machine** - notes/test-plan-16.md:17-21 defines the state transitions that affect pattern activation

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('PROP 5: cycling preserved across pattern deactivation/reactivation', async () => {
  // Step 1: Meet initial condition
  for (let i = 1; i <= 7; i++) {
    await planner.logCompletion(walkSeriesId, date(`2025-01-${String(i * 2).padStart(2, '0')}`));
  }

  // Step 2: Advance cycling to B
  await planner.logCompletion(weightSeriesId, date('2025-01-20'));

  // Verify cycling is at B
  let schedule = await planner.getSchedule(date('2025-01-24'), date('2025-01-25'));
  let weightInstance = schedule.instances.find((i) => i.seriesId === weightSeriesId);
  expect(weightInstance?.title).toContain('Workout B');

  // Step 3: Deactivate by sliding window
  schedule = await planner.getSchedule(date('2025-02-15'), date('2025-02-21'));
  const weightsDeactivated = schedule.instances.filter((i) => i.seriesId === weightSeriesId);

  // Weights pattern should be inactive
  expect(weightsDeactivated).toHaveLength(0);
  expect(weightsDeactivated).toEqual([]);

  // Step 4: Reactivate by logging 7 new walks
  for (let i = 1; i <= 7; i++) {
    await planner.logCompletion(walkSeriesId, date(`2025-02-${String(i * 2).padStart(2, '0')}`));
  }

  // Step 5: Verify cycling is still at B (not reset to A)
  schedule = await planner.getSchedule(date('2025-02-17'), date('2025-02-21'));
  weightInstance = schedule.instances.find((i) => i.seriesId === weightSeriesId);
  expect(weightInstance).toBeDefined();
  expect(weightInstance?.title).toContain('Workout B');
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(weightInstance?.title).toContain('Workout B')` - Initially at B
2. `expect(weightsDeactivated).toHaveLength(0)` - Deactivated
3. `expect(weightsDeactivated).toEqual([])` - Empty array
4. `expect(weightInstance).toBeDefined()` - Reactivated
5. `expect(weightInstance?.title).toContain('Workout B')` - Still at B

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies cycling state before deactivation
- Verifies deactivation with length and equality
- Verifies reactivation occurred
- Verifies cycling state after reactivation
- Cannot pass if cycling was reset

**What specific changes would transform this test into its ideal form?**

Replace line 402:
```typescript
expect(weightsDeactivated).toEqual([]);
```

With:
```typescript
expect(weightsDeactivated).toHaveLength(0);
expect(weightsDeactivated).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 385-434 to examine the exact violation at line 402 and full test context

3. **Search for PROP 5 test plan** - Used Grep tool with pattern `PROP 5|cycling preserved|deactivation|reactivation` in notes/test-plan-16.md, finding:
   - Line 32: "6 | Check cycling | Cycling index preserved (PROP 5) | PROP 5"

---

## Violation #74: tests/16-integration.test.ts:918

**Test Name:** `remove cantBeNextTo - heavy can be adjacent`

**Violation Line:**
```typescript
expect(constraintViolations).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that when a `cantBeNextTo` constraint is removed, the constraint no longer causes violations. After removal, heavy workouts can be scheduled adjacent without generating conflicts.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Two heavy workouts are created on adjacent days (lines 897-906)
2. A cantBeNextTo constraint for 'heavy' tag is added (lines 908-911)
3. The constraint is removed (line 913)
4. No constraint violations exist after removal (lines 915-918)

**Why does this specific test matter?**

Constraint removal must be complete:
- Removed constraints should not generate violations
- Users should be able to modify their constraint sets
- Stale constraints could incorrectly restrict schedules

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify violations existed BEFORE removal
3. Could pass if getConflicts is broken
4. Doesn't verify the constraint was actually added

**Why does getting it right matter?**

For medically fragile people:
- Care constraints must be modifiable
- Removing a constraint should have immediate effect
- Stale constraints could prevent valid schedules

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:98 states "3 | Remove cantBeNextTo | Heavy can be adjacent"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('remove cantBeNextTo - heavy can be adjacent', async () => {
  // Create two heavy workouts on adjacent days
  const heavy1Id = await planner.createSeries({
    title: 'Heavy Workout 1',
    patterns: [{ type: 'weekly', daysOfWeek: [1], time: time('09:00') }],
    tags: ['heavy'],
  });
  const heavy2Id = await planner.createSeries({
    title: 'Heavy Workout 2',
    patterns: [{ type: 'weekly', daysOfWeek: [2], time: time('09:00') }],
    tags: ['heavy'],
  });

  const constraintId = await planner.addConstraint({
    type: 'cantBeNextTo',
    target: { type: 'tag', tag: 'heavy' },
  });

  // Verify constraint violation exists before removal
  const conflictsBefore = await planner.getConflicts();
  const violationsBefore = conflictsBefore.filter((c) => c.type === 'constraintViolation');
  expect(violationsBefore.length).toBeGreaterThan(0);

  await planner.removeConstraint(constraintId);

  // Verify no violations after removal
  const conflictsAfter = await planner.getConflicts();
  const violationsAfter = conflictsAfter.filter((c) => c.type === 'constraintViolation');
  expect(violationsAfter).toHaveLength(0);
  expect(violationsAfter).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(violationsBefore.length).toBeGreaterThan(0)` - Violations before
2. `expect(violationsAfter).toHaveLength(0)` - No violations after
3. `expect(violationsAfter).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies violations exist before removal
- Verifies violations are gone after removal
- Uses both length and equality checks
- Cannot pass if constraint wasn't added

**What specific changes would transform this test into its ideal form?**

Add before line 913:
```typescript
// Verify constraint violation exists before removal
const conflictsBefore = await planner.getConflicts();
const violationsBefore = conflictsBefore.filter((c) => c.type === 'constraintViolation');
expect(violationsBefore.length).toBeGreaterThan(0);
```

Replace line 918:
```typescript
expect(constraintViolations).toEqual([]);
```

With:
```typescript
expect(constraintViolations).toHaveLength(0);
expect(constraintViolations).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 900-949 to examine the exact violation at line 918 and full test context

3. **Search for cantBeNextTo test plan** - Used Grep tool with pattern `cantBeNextTo|remove.*constraint|constraint.*removal` in notes/test-plan-16.md, finding:
   - Line 98: "3 | Remove cantBeNextTo | Heavy can be adjacent"

---

## Violation #75: tests/16-integration.test.ts:1160

**Test Name:** `all-day excluded from reflow - no time conflicts`

**Violation Line:**
```typescript
expect(allDayTimedConflicts).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that all-day events are excluded from time-based conflict detection. An all-day event should not generate time conflicts with timed events since they represent different temporal concepts.

**What functionality or behavior is it verifying?**

The test verifies that:
1. An all-day event is created (lines 1142-1145)
2. A timed event (09:00, 60min, fixed) is created (lines 1147-1150)
3. Getting conflicts returns no conflicts between all-day and timed (lines 1155-1160)

**Why does this specific test matter?**

All-day events must be handled specially:
- They span the entire day, not a specific time slot
- Including them in time conflict detection is meaningless
- They should be excluded from reflow algorithms

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify all-day and timed events were created
3. Could pass if getConflicts is broken
4. Doesn't verify that TIME conflicts would be detected

**Why does getting it right matter?**

For medically fragile people:
- All-day events (like "Doctor appointment") are common
- They shouldn't conflict with hourly tasks
- Incorrect conflict detection could disrupt scheduling

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:137 states "all-day excluded from reflow | All-day instance | No time conflicts"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('all-day excluded from reflow - no time conflicts', async () => {
  const planner = await createTestPlanner();

  const allDayId = await planner.createSeries({
    title: 'All Day Event',
    patterns: [{ type: 'daily', allDay: true }],
  });

  const timedId = await planner.createSeries({
    title: 'Timed Event',
    patterns: [{ type: 'daily', time: time('09:00'), duration: minutes(60), fixed: true }],
  });

  // Verify both series exist
  const allDaySeries = await planner.getSeries(allDayId);
  expect(allDaySeries).toBeDefined();
  expect(allDaySeries?.patterns[0].allDay).toBe(true);

  const timedSeries = await planner.getSeries(timedId);
  expect(timedSeries).toBeDefined();
  expect(timedSeries?.patterns[0].time).toBe(time('09:00'));

  const conflicts = await planner.getConflicts();

  // All-day should not conflict with timed events
  const allDayTimedConflicts = conflicts.filter((c) =>
    c.instances?.some((i) => i.seriesId === allDayId) &&
    c.instances?.some((i) => i.seriesId === timedId)
  );

  expect(allDayTimedConflicts).toHaveLength(0);
  expect(allDayTimedConflicts).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(allDaySeries?.patterns[0].allDay).toBe(true)` - All-day created
2. `expect(timedSeries?.patterns[0].time).toBe(...)` - Timed created
3. `expect(allDayTimedConflicts).toHaveLength(0)` - No conflicts
4. `expect(allDayTimedConflicts).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies both series are created with correct properties
- Verifies no conflicts between all-day and timed
- Uses both length and equality checks
- Cannot pass if series weren't created

**What specific changes would transform this test into its ideal form?**

Add after line 1150:
```typescript
// Verify both series exist
const allDaySeries = await planner.getSeries(allDayId);
expect(allDaySeries?.patterns[0].allDay).toBe(true);
const timedSeries = await planner.getSeries(timedId);
expect(timedSeries?.patterns[0].time).toBe(time('09:00'));
```

Replace line 1160:
```typescript
expect(allDayTimedConflicts).toEqual([]);
```

With:
```typescript
expect(allDayTimedConflicts).toHaveLength(0);
expect(allDayTimedConflicts).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1140-1189 to examine the exact violation at line 1160 and full test context

3. **Search for all-day test plan** - Used Grep tool with pattern `all-day|allDay|excluded.*reflow|time conflict` in notes/test-plan-16.md, finding:
   - Line 136: "all-day reminder timing | Event on 15th, 60 min before | Fires 23:00 on 14th"
   - Line 137: "all-day excluded from reflow | All-day instance | No time conflicts"

---

## Violation #76: tests/16-integration.test.ts:1191

**Test Name:** `12:55 - no pending reminders`

**Violation Line:**
```typescript
expect(seriesReminders).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that at 12:55, no reminders have been triggered for a task scheduled at 14:00 with 60-minute and 10-minute reminder offsets. The 60-min reminder triggers at 13:00, so at 12:55 no reminders should be pending.

**What functionality or behavior is it verifying?**

The test verifies that:
1. getPendingReminders returns empty before any reminder window opens (line 1188)
2. The 60-minute reminder (triggers at 13:00) is not pending at 12:55 (line 1191)
3. The 10-minute reminder (triggers at 13:50) is not pending at 12:55 (line 1191)
4. Reminders only become pending when their offset time is reached

**Why does this specific test matter?**

Reminder timing precision is critical:
- Premature reminders would be annoying and confusing
- The system must respect the configured offset times exactly
- Users rely on reminders arriving at the expected time

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the series has reminders configured
3. Could pass if getPendingReminders is broken
4. Doesn't verify the task at 14:00 exists

**Why does getting it right matter?**

For medically fragile people:
- Medication reminders must fire at the correct time
- Premature reminders could cause confusion
- Missing or early reminders could disrupt care schedules

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:147 states "12:55 | No pending reminders"

2. **Reminder Scenario Context** - The test is part of "7. Reminder Timing Scenario" (tests/16-integration.test.ts:1162-1230) which tests:
   - 12:55: No pending reminders (line 1187)
   - 13:00: Prepare (60 min) pending (line 1194)
   - After ack: Prepare not pending (line 1199)
   - 13:50: Urgent (10 min) pending (line 1217)
   - After complete: Reminders for next instance (line 1222)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('12:55 - no pending reminders', async () => {
  // Verify task exists at 14:00 with reminder configuration
  const series = await planner.getSeries(seriesIdValue);
  expect(series).toBeDefined();
  expect(series?.reminderOffsets).toContain(60); // 60 min before = 13:00
  expect(series?.reminderOffsets).toContain(10); // 10 min before = 13:50

  // Verify task instance exists on this day
  const schedule = await planner.getSchedule(date('2025-01-15'), date('2025-01-15'));
  const taskInstance = schedule.instances.find((i) => i.seriesId === seriesIdValue);
  expect(taskInstance).toBeDefined();
  expect(taskInstance?.time).toBe(time('14:00'));

  const reminders = await planner.getPendingReminders(datetime('2025-01-15T12:55:00'));
  const seriesReminders = reminders.filter((r) => r.seriesId === seriesIdValue);

  // Neither the 60-min (13:00) nor 10-min (13:50) reminder has triggered yet at 12:55
  expect(seriesReminders).toHaveLength(0);
  expect(seriesReminders).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(series?.reminderOffsets).toContain(60)` - 60-min reminder configured
2. `expect(series?.reminderOffsets).toContain(10)` - 10-min reminder configured
3. `expect(taskInstance?.time).toBe(time('14:00'))` - Task at 14:00
4. `expect(seriesReminders).toHaveLength(0)` - No reminders pending
5. `expect(seriesReminders).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the series exists with reminder configuration
- Verifies the task instance exists at 14:00
- Verifies no reminders pending before trigger time
- Uses both length and equality checks
- Cannot pass if series or reminders don't exist

**What specific changes would transform this test into its ideal form?**

Add before line 1188:
```typescript
// Verify task exists at 14:00 with reminders
const series = await planner.getSeries(seriesIdValue);
expect(series?.reminderOffsets).toContain(60);
expect(series?.reminderOffsets).toContain(10);
```

Replace line 1191:
```typescript
expect(seriesReminders).toEqual([]);
```

With:
```typescript
expect(seriesReminders).toHaveLength(0);
expect(seriesReminders).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1185-1234 to examine the exact violation at line 1191 and full test context including surrounding tests in the reminder timing scenario

3. **Search for test plan reference** - Used Grep tool with pattern `12:55|no pending reminders|reminder timing` in notes/test-plan-16.md, finding:
   - Line 147: "12:55 | No pending reminders"

---

## Violation #77: tests/16-integration.test.ts:1214

**Test Name:** `after ack - prepare not pending`

**Violation Line:**
```typescript
expect(seriesRemindersAfter.length).toBe(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that after acknowledging a reminder, it no longer appears in the pending reminders list for that specific instance. The 60-minute "prepare" reminder was acknowledged at 13:05, and at 13:10 it should no longer be pending.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Get pending reminders at 13:00 to find the prepare reminder (lines 1200-1201)
2. Acknowledge the reminder at 13:05 (lines 1203-1205)
3. At 13:10, the acknowledged reminder is not pending (lines 1207-1214)
4. The 10-min reminder hasn't triggered yet (13:50 > 13:10) so it's not pending either

**Why does this specific test matter?**

Reminder acknowledgment is essential:
- Acknowledged reminders shouldn't keep notifying users
- Users expect reminders to stop after acknowledgment
- Repeated reminders would be annoying and distracting

**What are the consequences if this test is wrong or weak?**

The `.toBe(0)` assertion is weak because:
1. It only verifies the count is zero
2. Doesn't verify the acknowledgment actually happened
3. Could pass if getPendingReminders is broken
4. Doesn't verify the reminder was pending BEFORE ack

**Why does getting it right matter?**

For medically fragile people:
- Reminder spam could cause alert fatigue
- Acknowledged tasks shouldn't keep notifying
- Caregivers need clear signal when tasks are noted

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:149 states "After ack | 'prepare' not pending"

2. **Reminder Scenario Context** - The test is part of "7. Reminder Timing Scenario" (tests/16-integration.test.ts:1162-1230) which tests the complete reminder lifecycle:
   - 12:55: No pending reminders (line 1187)
   - 13:00: Prepare (60 min) pending (line 1194)
   - After ack: Prepare not pending (line 1199) - THIS TEST
   - 13:50: Urgent (10 min) pending (line 1217)
   - After complete: Reminders for next instance (line 1222)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('after ack - prepare not pending', async () => {
  // Verify prepare reminder is pending at 13:00
  const reminders = await planner.getPendingReminders(datetime('2025-01-15T13:00:00'));
  const prepareReminder = reminders.find((r) => r.seriesId === seriesIdValue);
  expect(prepareReminder).toBeDefined();
  expect(prepareReminder?.offsetMinutes).toBe(60);

  // Acknowledge the reminder
  const ackResult = await planner.acknowledgeReminder(prepareReminder!.id, datetime('2025-01-15T13:05:00'));
  expect(ackResult.success).toBe(true);

  // Verify prepare reminder is NOT pending after acknowledgment
  const remindersAfter = await planner.getPendingReminders(datetime('2025-01-15T13:10:00'));
  const seriesRemindersAfter = remindersAfter.filter((r) =>
    r.seriesId === seriesIdValue && r.instanceDate === date('2025-01-15')
  );

  // At 13:10: prepare (acked), urgent (13:50) not triggered yet
  expect(seriesRemindersAfter).toHaveLength(0);
  expect(seriesRemindersAfter.length).toBe(0);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(prepareReminder).toBeDefined()` - Reminder existed before ack
2. `expect(prepareReminder?.offsetMinutes).toBe(60)` - Correct reminder type
3. `expect(ackResult.success).toBe(true)` - Acknowledgment succeeded
4. `expect(seriesRemindersAfter).toHaveLength(0)` - No reminders after ack
5. `expect(seriesRemindersAfter.length).toBe(0)` - Count verification

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the reminder existed BEFORE acknowledgment
- Verifies the acknowledgment succeeded
- Verifies no reminders pending AFTER acknowledgment
- Uses both length property and toHaveLength matcher
- Cannot pass if reminder wasn't originally pending

**What specific changes would transform this test into its ideal form?**

Add after line 1201:
```typescript
expect(prepareReminder).toBeDefined();
expect(prepareReminder?.offsetMinutes).toBe(60);
```

Replace line 1214:
```typescript
expect(seriesRemindersAfter.length).toBe(0);
```

With:
```typescript
expect(seriesRemindersAfter).toHaveLength(0);
expect(seriesRemindersAfter.length).toBe(0);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1195-1234 to examine the exact violation at line 1214 and full test context including surrounding tests in the reminder timing scenario

3. **Search for test plan reference** - Used Grep tool with pattern `13:10|Reminder Timing|pending` in notes/test-plan-16.md, finding:
   - Line 149: "After ack | 'prepare' not pending"

---

## Violation #78: tests/16-integration.test.ts:1258

**Test Name:** `cancel Monday - that Monday not in schedule`

**Violation Line:**
```typescript
expect(instancesOnCancelledDate).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that when an instance is cancelled, it no longer appears in the schedule for that specific date. The weekly Monday meeting on 2025-01-20 is cancelled, and the schedule should not contain that instance.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Cancel the instance for Monday 2025-01-20 (line 1250)
2. Get the schedule for that date range (line 1252)
3. Filter for instances of this series on the cancelled date (lines 1255-1257)
4. The filtered result is empty (line 1258)

**Why does this specific test matter?**

Instance cancellation is essential:
- Users need to cancel specific occurrences without affecting the pattern
- Cancelled instances must not appear in the schedule
- Cancellation is a common use case (holidays, sick days, etc.)

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the instance WAS scheduled before cancellation
3. Could pass if the series wasn't created
4. Doesn't verify the cancellation was recorded

**Why does getting it right matter?**

For medically fragile people:
- Cancelled appointments must not appear on the schedule
- Caregivers should not prepare for cancelled events
- Schedule accuracy is critical for planning

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:161 states "Cancel Monday | That Monday not in schedule"

2. **Instance Exception Scenario Context** - The test is part of "8. Instance Exception Scenario" (tests/16-integration.test.ts:1232-1330) which tests:
   - Cancel Monday - that Monday not in schedule (line 1249) - THIS TEST
   - Check other Mondays - still scheduled (line 1263)
   - Reschedule to Tuesday - instance on Tuesday (line 1279)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('cancel Monday - that Monday not in schedule', async () => {
  // First verify instance EXISTS before cancellation
  const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));
  const instanceBefore = scheduleBefore.instances.find((i) =>
    i.seriesId === seriesIdValue && i.date === date('2025-01-20')
  );
  expect(instanceBefore).toBeDefined();
  expect(instanceBefore?.title).toBe('Weekly Meeting');
  expect(instanceBefore?.time).toContain('09:00');

  // Cancel the instance
  await planner.cancelInstance(seriesIdValue, date('2025-01-20'));

  // Verify instance no longer exists
  const schedule = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));
  const instancesOnCancelledDate = schedule.instances.filter(
    (i) => i.seriesId === seriesIdValue && i.date === date('2025-01-20')
  );

  expect(instancesOnCancelledDate).toHaveLength(0);
  expect(instancesOnCancelledDate).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(instanceBefore).toBeDefined()` - Instance existed before cancellation
2. `expect(instanceBefore?.title).toBe('Weekly Meeting')` - Correct instance
3. `expect(instancesOnCancelledDate).toHaveLength(0)` - No instances after cancellation
4. `expect(instancesOnCancelledDate).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the instance existed BEFORE cancellation
- Verifies the instance is gone AFTER cancellation
- Uses both length and equality checks
- Cannot pass if instance never existed

**What specific changes would transform this test into its ideal form?**

Add before line 1250:
```typescript
// Verify instance exists before cancellation
const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));
const instanceBefore = scheduleBefore.instances.find((i) =>
  i.seriesId === seriesIdValue && i.date === date('2025-01-20')
);
expect(instanceBefore).toBeDefined();
expect(instanceBefore?.title).toBe('Weekly Meeting');
```

Replace line 1258:
```typescript
expect(instancesOnCancelledDate).toEqual([]);
```

With:
```typescript
expect(instancesOnCancelledDate).toHaveLength(0);
expect(instancesOnCancelledDate).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1230-1279 to examine the exact violation at line 1258 and full test context including the Instance Exception Scenario setup and surrounding tests

3. **Search for test plan reference** - Used Grep tool with pattern `cancel Monday|instance exception|not in schedule` in notes/test-plan-16.md, finding:
   - Line 161: "Cancel Monday | That Monday not in schedule"

---

## Violation #79: tests/16-integration.test.ts:1260

**Test Name:** `cancel Monday - that Monday not in schedule` (second assertion)

**Violation Line:**
```typescript
expect(schedule.instances.filter((i) => i.date === date('2025-01-20'))).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion (the second in the test) verifies that after cancelling the Monday instance, NO instances of ANY series exist on that cancelled date. This is a broader check than line 1258 which only checked for this specific series.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Cancel the instance for Monday 2025-01-20 (line 1250)
2. Get the schedule for that date range (line 1252)
3. Filter ALL instances for the cancelled date (line 1260)
4. The entire schedule for that date is empty

**Why does this specific test matter?**

This broader check ensures:
- The cancellation affects the overall schedule
- No orphaned instances remain on the date
- The schedule view correctly reflects cancellations

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify instances existed before cancellation
3. Could pass if no series were ever created
4. Doesn't verify what instances should remain on OTHER dates

**Why does getting it right matter?**

For medically fragile people:
- Empty schedule days must truly be empty
- No phantom tasks should appear on cancelled dates
- Caregivers need accurate daily views

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:161 states "Cancel Monday | That Monday not in schedule"

2. **Context in Test** - This is the second assertion in the same test that started at line 1249. The first assertion (line 1258) checked only this series; this one (line 1260) verifies no instances at all on that date.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('cancel Monday - that Monday not in schedule', async () => {
  // First verify instance EXISTS before cancellation
  const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));
  const allInstancesBefore = scheduleBefore.instances.filter((i) => i.date === date('2025-01-20'));
  expect(allInstancesBefore).toHaveLength(1);
  expect(allInstancesBefore[0].seriesId).toBe(seriesIdValue);

  // Cancel the instance
  await planner.cancelInstance(seriesIdValue, date('2025-01-20'));

  // Verify NO instances exist on that date
  const schedule = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));

  // Series-specific check
  const instancesOnCancelledDate = schedule.instances.filter(
    (i) => i.seriesId === seriesIdValue && i.date === date('2025-01-20')
  );
  expect(instancesOnCancelledDate).toHaveLength(0);
  expect(instancesOnCancelledDate).toEqual([]);

  // Broader check - no instances at all on that date
  const allInstancesOnDate = schedule.instances.filter((i) => i.date === date('2025-01-20'));
  expect(allInstancesOnDate).toHaveLength(0);
  expect(allInstancesOnDate).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(allInstancesBefore).toHaveLength(1)` - One instance before cancellation
2. `expect(allInstancesBefore[0].seriesId).toBe(seriesIdValue)` - Correct instance
3. `expect(allInstancesOnDate).toHaveLength(0)` - No instances after cancellation
4. `expect(allInstancesOnDate).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies instances existed BEFORE cancellation
- Verifies the correct instance was present
- Verifies no instances AFTER cancellation
- Uses both length and equality checks
- Cannot pass if instance never existed

**What specific changes would transform this test into its ideal form?**

Add before line 1250:
```typescript
// Verify instance exists before cancellation
const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-21'));
const allInstancesBefore = scheduleBefore.instances.filter((i) => i.date === date('2025-01-20'));
expect(allInstancesBefore).toHaveLength(1);
```

Replace line 1260:
```typescript
expect(schedule.instances.filter((i) => i.date === date('2025-01-20'))).toEqual([]);
```

With:
```typescript
const allInstancesOnDate = schedule.instances.filter((i) => i.date === date('2025-01-20'));
expect(allInstancesOnDate).toHaveLength(0);
expect(allInstancesOnDate).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1245-1279 to examine the exact violation at line 1260 and full test context including both assertions in this test

3. **Search for test plan reference** - Used Grep tool with pattern `Cancel Monday|instance exception|not in schedule` in notes/test-plan-16.md, finding:
   - Line 161: "Cancel Monday | That Monday not in schedule"

---

## Violation #80: tests/16-integration.test.ts:1298

**Test Name:** `check original Monday - slot free`

**Violation Line:**
```typescript
expect(instancesOnOriginalDate).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that after rescheduling an instance from Monday to Tuesday, the original Monday date no longer contains the instance. The instance should only exist on its new date (Tuesday), not both dates.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Reschedule the Monday instance to Tuesday at 14:00 (line 1290)
2. Get the schedule covering both dates (line 1292)
3. Filter for instances of this series on the ORIGINAL date (lines 1295-1297)
4. The original Monday slot is now empty (line 1298)
5. The instance now exists on Tuesday (lines 1300-1308)

**Why does this specific test matter?**

Rescheduling must be atomic:
- Instance should only exist at new time
- Original slot should be freed
- No duplicate instances should exist

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the instance WAS at the original time
3. Could pass if reschedule failed entirely
4. Doesn't verify the instance moved vs. being deleted

**Why does getting it right matter?**

For medically fragile people:
- Rescheduled tasks must appear at new time only
- Duplicate tasks could cause confusion
- Caregivers need accurate schedule after rescheduling

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:164 states "Check original Monday | Slot free"

2. **Instance Exception Scenario Context** - The test is part of "8. Instance Exception Scenario" (tests/16-integration.test.ts:1232-1310) which tests:
   - Cancel Monday (line 1249)
   - Check other Mondays (line 1263)
   - Reschedule to Tuesday (line 1279)
   - Check original Monday - slot free (line 1289) - THIS TEST

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('check original Monday - slot free', async () => {
  // First verify instance EXISTS on Monday before reschedule
  const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-22'));
  const instanceBefore = scheduleBefore.instances.find((i) =>
    i.seriesId === seriesIdValue && i.date === date('2025-01-20')
  );
  expect(instanceBefore).toBeDefined();
  expect(instanceBefore?.time).toContain('09:00');

  // Reschedule to Tuesday
  await planner.rescheduleInstance(seriesIdValue, date('2025-01-20'), datetime('2025-01-21T14:00:00'));

  const schedule = await planner.getSchedule(date('2025-01-20'), date('2025-01-22'));

  // Original Monday should be empty
  const instancesOnOriginalDate = schedule.instances.filter((i) =>
    i.seriesId === seriesIdValue && i.date === date('2025-01-20')
  );
  expect(instancesOnOriginalDate).toHaveLength(0);
  expect(instancesOnOriginalDate).toEqual([]);

  // Instance should be on Tuesday at new time
  const rescheduledInstance = schedule.instances.find((i) =>
    i.seriesId === seriesIdValue && i.date === date('2025-01-21')
  );
  expect(rescheduledInstance).toBeDefined();
  expect(rescheduledInstance?.time).toContain('14:00');
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(instanceBefore).toBeDefined()` - Instance existed before reschedule
2. `expect(instanceBefore?.time).toContain('09:00')` - Original time verified
3. `expect(instancesOnOriginalDate).toHaveLength(0)` - Original slot empty
4. `expect(instancesOnOriginalDate).toEqual([])` - Empty array
5. `expect(rescheduledInstance).toBeDefined()` - Instance moved to new date
6. `expect(rescheduledInstance?.time).toContain('14:00')` - New time verified

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the instance existed BEFORE rescheduling
- Verifies the original slot is empty AFTER rescheduling
- Verifies the instance moved to the new date
- Uses both length and equality checks
- Cannot pass if instance never existed

**What specific changes would transform this test into its ideal form?**

Add before line 1290:
```typescript
// Verify instance exists on Monday before reschedule
const scheduleBefore = await planner.getSchedule(date('2025-01-20'), date('2025-01-22'));
const instanceBefore = scheduleBefore.instances.find((i) =>
  i.seriesId === seriesIdValue && i.date === date('2025-01-20')
);
expect(instanceBefore).toBeDefined();
expect(instanceBefore?.time).toContain('09:00');
```

Replace line 1298:
```typescript
expect(instancesOnOriginalDate).toEqual([]);
```

With:
```typescript
expect(instancesOnOriginalDate).toHaveLength(0);
expect(instancesOnOriginalDate).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 1275-1324 to examine the exact violation at line 1298 and full test context including the reschedule operations and verification

3. **Search for test plan reference** - Used Grep tool with pattern `original Monday|slot free|reschedule` in notes/test-plan-16.md, finding:
   - Line 164: "Check original Monday | Slot free"

---

