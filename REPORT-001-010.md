# REPORT-001-010: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #1-10 as specified in REPORT-SPEC.md.

---

## Violation #1: tests/04-adapter.test.ts:396

**Test Name:** `delete cascades patterns`

**Violation Line:**
```typescript
expect(patternsBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 17 of the adapter interface specification: "deleteSeries cascades to patterns: getPatternsBySeries(id) = []" (notes/testing-spec-04-adapter.md:145). The test creates a series, creates a pattern belonging to that series, then deletes the series and verifies the pattern was also deleted via cascade.

**What functionality or behavior is it verifying?**

The test verifies two behaviors:
1. That a pattern can be created and associated with a series
2. That when a series is deleted, all patterns belonging to that series are automatically deleted (cascade deletion)

**Why does this specific test matter?**

Cascade deletion is critical for data integrity. In life-critical software for caretaker robots, if a care schedule (series) is deleted but its associated patterns remain as orphans, the system could:
- Attempt to execute patterns for non-existent series, causing crashes
- Accumulate orphan data corrupting the database
- Present misleading information to caregivers about schedules that no longer exist

**What are the consequences if this test is wrong or weak?**

If the assertion is weak (as it currently is), the test could pass even when:
- The pattern returned is a different pattern than the one created
- The pattern has corrupted data
- The mock adapter returns arbitrary data instead of the actual created pattern

**Why does getting it right matter?**

For medically fragile people depending on this software, a silently failing cascade deletion could mean missed medications, missed safety checks, or accumulating database corruption that eventually causes system-wide failures.

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Adapter Interface Definition** - notes/adapter-interface.md:24 defines `deleteSeries(id: string): void` with the comment "DB throws if completions exist or has linked children (RESTRICT)". This shows series deletion has protection against some cascade types but deliberately cascades to patterns.

2. **Specification Law** - notes/testing-spec-04-adapter.md:145 explicitly states "LAW 17: deleteSeries cascades to patterns: getPatternsBySeries(id) = []"

3. **Pattern Creation** - notes/adapter-interface.md:27-29 shows the pattern operations:
   ```typescript
   createPattern(pattern: PatternRow): void
   getPattern(id: string): PatternRow | null
   getPatternsBySeries(seriesId: string): PatternRow[]
   ```

4. **PatternRow Structure** - notes/adapter-interface.md:150-160 defines the PatternRow interface:
   ```typescript
   interface PatternRow {
     id: string
     series_id: string
     condition_id: string | null
     is_exception: number  // 0 or 1
     type: string
     n: number | null
     day: number | null
     month: number | null
     weekday: string | null
   }
   ```

5. **Usage in SQLite Adapter Tests** - tests/15-sqlite-adapter.test.ts:318-327 uses getPatternsBySeries to verify cascade deletion in the SQLite implementation, showing this is a real production concern.

6. **Usage in Pattern CRUD Property Tests** - tests/fuzz/properties/pattern-crud.test.ts:149-155 similarly tests pattern deletion with patterns being retrieved by series.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify not just the count but the actual identity and properties of the pattern before deletion:

```typescript
it('delete cascades patterns', async () => {
  await adapter.createSeries({
    id: 'series-1',
    title: 'Test',
    createdAt: '2024-01-15T10:00:00' as LocalDateTime,
  })
  await adapter.createPattern({
    id: 'pattern-1',
    seriesId: 'series-1',
    type: 'daily',
    conditionId: null,
  })

  // Verify pattern exists with correct properties before deletion
  const patternsBefore = await adapter.getPatternsBySeries('series-1')
  expect(patternsBefore).toHaveLength(1)
  expect(patternsBefore[0]).toMatchObject({
    id: 'pattern-1',
    seriesId: 'series-1',
    type: 'daily',
    conditionId: null,
  })

  await adapter.deleteSeries('series-1')

  const patternsAfter = await adapter.getPatternsBySeries('series-1')
  expect(patternsAfter).toEqual([])
})
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(patternsBefore).toHaveLength(1)` - Verify exactly one pattern exists
2. `expect(patternsBefore[0]).toMatchObject({...})` - Verify the pattern has the expected identity and properties
3. `expect(patternsAfter).toEqual([])` - Verify cascade deletion worked (already present)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the actual pattern object, not just its existence
- Confirms the pattern's id matches what was created
- Confirms the pattern's seriesId references the correct series
- Confirms the pattern's type is correct
- Uses `toMatchObject` to verify structure while allowing for additional adapter-added fields

**What specific changes would transform this test into its ideal form?**

Replace line 396:
```typescript
expect(patternsBefore.length).toBe(1)
```

With:
```typescript
expect(patternsBefore).toHaveLength(1)
expect(patternsBefore[0]).toMatchObject({
  id: 'pattern-1',
  seriesId: 'series-1',
  type: 'daily',
  conditionId: null,
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md to understand the analysis requirements

2. **Read the test file** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1-50 to understand the test file structure and imports

3. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 380-440 to examine the exact test with the violation

4. **Search for adapter implementation** - Used Glob tool with pattern `**/adapter*.ts` and `src/**/*.ts` to locate adapter source files

5. **Search for source files** - Used Bash `find` command to list all TypeScript files in the project excluding node_modules

6. **Search for createMockAdapter definition** - Used Grep tool with pattern `export.*createMockAdapter|function createMockAdapter` to find where the mock adapter is defined (found at tests/14-public-api.test.ts:66-79)

7. **Search for getPatternsBySeries usage** - Used Grep tool with pattern `getPatternsBySeries` across the codebase, finding usage in:
   - tests/04-adapter.test.ts:395, 398, 486, 517, 2002, 2049
   - tests/05-series-crud.test.ts:1035
   - tests/15-sqlite-adapter.test.ts:318, 327, 747, 911, 943, 973, 1152, 1296, 1377, 1395
   - notes/testing-spec-04-adapter.md:145, 155
   - notes/adapter-interface.md:29

8. **Read testing specification** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 140-180 to find LAW 17 definition

9. **Read adapter interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 1-80 to understand the interface contract

10. **Search for Pattern type definition** - Used Grep tool with pattern `type Pattern|interface Pattern|PatternRow` to find type definitions

11. **Read PatternRow interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 148-172 to get the PatternRow structure

12. **Read Pattern type shapes** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/type-shapes.md lines 15-45 to understand Pattern type variants

---

## Violation #2: tests/04-adapter.test.ts:399

**Test Name:** `delete cascades patterns`

**Violation Line:**
```typescript
expect(patterns).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion is the core verification of LAW 17 from the adapter specification: "deleteSeries cascades to patterns: getPatternsBySeries(id) = []" (notes/testing-spec-04-adapter.md:145). It verifies that after deleting a series, all patterns belonging to that series have been automatically removed via cascade deletion.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `deleteSeries('series-1')` is called
2. The call to `getPatternsBySeries('series-1')` returns an empty array
3. No patterns remain associated with the deleted series

**Why does this specific test matter?**

Cascade deletion to patterns is essential for data integrity. Patterns define when scheduled tasks occur. If patterns survive their parent series being deleted:
- Orphan patterns could cause the scheduler to attempt invalid operations
- Database foreign key constraints could be violated in production
- The system could present phantom schedules to caregivers

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- The `getPatternsBySeries` function is broken and always returns `[]`
- The series was never created (so there were never any patterns)
- The pattern was never created successfully
- A different bug caused the pattern to be deleted before `deleteSeries` was called

**Why does getting it right matter?**

For medically fragile people, orphan patterns could cause:
- Duplicate medication reminders if patterns become disconnected from completions
- Missed care tasks if the system enters an inconsistent state
- System crashes when processing orphan patterns with no parent series

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Specification Law** - notes/testing-spec-04-adapter.md:145 defines "LAW 17: deleteSeries cascades to patterns: getPatternsBySeries(id) = []"

2. **Additional Cascade Law** - notes/testing-spec-04-adapter.md:167 states "LAW 20: Series deletion cascades to patterns" as an additional explicit requirement

3. **Adapter Interface** - notes/adapter-interface.md:24 documents `deleteSeries(id: string): void` with the comment "DB throws if completions exist or has linked children (RESTRICT)" - showing cascade to patterns is deliberate while other relationships are protected

4. **getPatternsBySeries Method** - notes/adapter-interface.md:29 defines `getPatternsBySeries(seriesId: string): PatternRow[]` - the method used to verify cascade deletion

5. **getPattern Method** - notes/adapter-interface.md:28 defines `getPattern(id: string): PatternRow | null` - an alternative method that could provide stronger verification by checking specific pattern IDs

6. **SQLite Adapter Cascade Test** - tests/15-sqlite-adapter.test.ts:324-328 shows the SQLite implementation also tests cascade deletion:
   ```typescript
   // Delete series - patterns should cascade
   await adapter.deleteSeries(seriesId('test-1'));
   const patternsAfter = await adapter.getPatternsBySeries(seriesId('test-1'));
   expect(patternsAfter).toHaveLength(0);
   ```

7. **SQLite Pre-deletion Verification** - tests/15-sqlite-adapter.test.ts:318-322 shows stronger pre-deletion verification:
   ```typescript
   const patterns = await adapter.getPatternsBySeries(seriesId('test-1'));
   expect(patterns[0].id).toBe(patternId('p1'));
   expect(patterns[0].seriesId).toBe(seriesId('test-1'));
   expect(patterns[0].type).toBe('daily');
   ```

8. **Property Tests** - REPORT.md:538 lists property test "Property #253: deleteSeries cascades to patterns" at tests/fuzz/properties/series.test.ts:647

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively by checking both the list-based query AND the specific pattern by ID:

```typescript
it('delete cascades patterns', async () => {
  await adapter.createSeries({
    id: 'series-1',
    title: 'Test',
    createdAt: '2024-01-15T10:00:00' as LocalDateTime,
  })
  await adapter.createPattern({
    id: 'pattern-1',
    seriesId: 'series-1',
    type: 'daily',
    conditionId: null,
  })

  // Verify pattern exists with correct properties before deletion
  const patternsBefore = await adapter.getPatternsBySeries('series-1')
  expect(patternsBefore).toHaveLength(1)
  expect(patternsBefore[0]).toMatchObject({
    id: 'pattern-1',
    seriesId: 'series-1',
    type: 'daily',
  })

  // Also verify via direct lookup
  const patternBefore = await adapter.getPattern('pattern-1')
  expect(patternBefore).not.toBeNull()

  await adapter.deleteSeries('series-1')

  // Verify cascade via list query
  const patternsAfter = await adapter.getPatternsBySeries('series-1')
  expect(patternsAfter).toEqual([])

  // Verify cascade via direct lookup - the specific pattern no longer exists
  const patternAfter = await adapter.getPattern('pattern-1')
  expect(patternAfter).toBeNull()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(patternsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(patternsBefore[0]).toMatchObject({...})` - Verify identity
3. Pre-deletion: `expect(patternBefore).not.toBeNull()` - Direct lookup confirms existence
4. Post-deletion: `expect(patternsAfter).toEqual([])` - List is empty
5. Post-deletion: `expect(patternAfter).toBeNull()` - Direct lookup confirms specific pattern deleted

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the specific pattern ('pattern-1') exists before deletion
- Verifies the specific pattern is gone after deletion (not just that the list is empty)
- Uses `getPattern` for definitive single-record verification
- Cannot pass if getPatternsBySeries is broken and always returns []
- Cannot pass if the pattern was never created

**What specific changes would transform this test into its ideal form?**

Add after line 399:
```typescript
// Also verify the specific pattern no longer exists
const deletedPattern = await adapter.getPattern('pattern-1')
expect(deletedPattern).toBeNull()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 380-410 to examine the exact violation at line 399

3. **Search for deleteSeries usage** - Used Grep tool with pattern `deleteSeries` across /home/legion/Documents/RealmScribe/libs/autoplanner, finding 40+ references including:
   - tests/05-series-crud.test.ts:16, 753, 957, 969, 975, 996, 1021, 1034, 1056, 1069
   - tests/14-public-api.test.ts:74, 360, 367, 579, 595, 1203, 1215, 1656
   - tests/11-links.test.ts:26, 819
   - REPORT.md:538-553 (property tests)
   - notes/testing-spec-04-adapter.md:142-145

4. **Read testing specification** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 140-175 to find LAW 17 and LAW 20 definitions

5. **Search for toEqual([]) usage** - Used Grep tool with pattern `toEqual\(\[\]\)` in tests/04-adapter.test.ts, finding 10 occurrences at lines 275, 399, 431, 506, 561, 920, 940, 1061, 1493, 1541

6. **Read adapter interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 20-40 to understand deleteSeries, getPattern, and getPatternsBySeries method signatures

7. **Search for getPattern usage** - Used Grep tool with pattern `getPattern\(` across tests directory, finding:
   - tests/04-adapter.test.ts:457
   - tests/fuzz/properties/pattern-crud.test.ts:40, 135, 154

8. **Read SQLite adapter cascade test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 315-345 to see how production adapter tests handle cascade deletion verification

9. **Read getPattern test usage** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 450-480 to see how getPattern is used elsewhere in the test file

---

## Violation #3: tests/04-adapter.test.ts:506

**Test Name:** `delete pattern cascades weekdays`

**Violation Line:**
```typescript
expect(weekdays).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 19 and LAW 23 from the adapter specification: "Pattern deletion cascades to pattern_weekday entries" (notes/testing-spec-04-adapter.md:166-167) and "Pattern deletion cascades to weekdays" (notes/testing-spec-04-adapter.md:184). When a pattern is deleted, all associated weekday entries must also be deleted.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Weekday entries can be associated with a pattern via `setPatternWeekdays`
2. Those entries can be retrieved via `getPatternWeekdays`
3. When the pattern is deleted via `deletePattern`, all associated weekday entries are automatically removed

**Why does this specific test matter?**

Weekday entries define on which days of the week a pattern-based task should be scheduled. The `{ type: 'weekdays', days: Weekday[] }` pattern type (notes/type-shapes.md:29) relies on these entries. If weekday entries survive their parent pattern being deleted:
- Orphan weekday records accumulate in the database
- Future queries may return stale data
- Memory and storage are wasted on unused records

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getPatternWeekdays` is broken and always returns `[]`
- The weekdays were never set successfully
- A different bug caused the weekdays to be deleted before `deletePattern` was called
- The pattern was never created

**Why does getting it right matter?**

For medically fragile people, orphan weekday records could:
- Cause scheduling confusion if multiple patterns share similar configurations
- Lead to database constraint violations as orphan records accumulate
- Eventually cause performance degradation from table bloat

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 19** - notes/testing-spec-04-adapter.md:166 states "LAW 19: Pattern deletion cascades to pattern_weekday entries"

2. **LAW 23** - notes/testing-spec-04-adapter.md:184 states "LAW 23: Pattern deletion cascades to weekdays"

3. **Adapter Interface - setPatternWeekdays** - notes/adapter-interface.md:35 defines `setPatternWeekdays(patternId: string, weekdays: Weekday[]): void  // replaces all`

4. **Adapter Interface - getPatternWeekdays** - notes/adapter-interface.md:36 defines `getPatternWeekdays(patternId: string): Weekday[]`

5. **Adapter Interface - getAllPatternWeekdays** - notes/adapter-interface.md:37 defines `getAllPatternWeekdays(): PatternWeekdayRow[]  // for bulk loading`

6. **PatternWeekdayRow Structure** - notes/adapter-interface.md:162-165 defines:
   ```typescript
   interface PatternWeekdayRow {
     pattern_id: string
     weekday: string
   }
   ```

7. **Pattern Type with Weekdays** - notes/type-shapes.md:29 defines `{ type: 'weekdays', days: Weekday[] }` pattern type that uses weekday entries

8. **Weekday Type** - notes/type-shapes.md:38 defines `type Weekday = 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat' | 'sun'`

9. **getAllPatternWeekdays Usage** - tests/04-adapter.test.ts:574-581 shows how `getAllPatternWeekdays` can verify pattern-weekday associations:
   ```typescript
   const all = await adapter.getAllPatternWeekdays()
   const pattern1Weekdays = all.filter((w) => w.patternId === 'pattern-1')
   expect(pattern1Weekdays.map((w) => w.weekday).sort()).toEqual(['mon', 'wed'])
   ```

10. **deletePattern Method** - notes/adapter-interface.md:32 defines `deletePattern(id: string): void`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both pattern-specific and global queries:

```typescript
it('delete pattern cascades weekdays', async () => {
  await adapter.createPattern({
    id: 'pattern-1',
    seriesId: 'series-1',
    type: 'weekdays',
    conditionId: null,
  } as Pattern)
  await adapter.setPatternWeekdays('pattern-1', ['mon', 'wed', 'fri'])

  // Verify weekdays exist with correct values before deletion
  const weekdaysBefore = await adapter.getPatternWeekdays('pattern-1')
  expect(weekdaysBefore).toEqual(['mon', 'wed', 'fri'])

  // Also verify via global query
  const allBefore = await adapter.getAllPatternWeekdays()
  const pattern1WeekdaysBefore = allBefore.filter(w => w.patternId === 'pattern-1')
  expect(pattern1WeekdaysBefore).toHaveLength(3)

  await adapter.deletePattern('pattern-1')

  // Verify cascade via pattern-specific query
  const weekdaysAfter = await adapter.getPatternWeekdays('pattern-1')
  expect(weekdaysAfter).toEqual([])

  // Verify cascade via global query - no entries for deleted pattern
  const allAfter = await adapter.getAllPatternWeekdays()
  const pattern1WeekdaysAfter = allAfter.filter(w => w.patternId === 'pattern-1')
  expect(pattern1WeekdaysAfter).toHaveLength(0)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(weekdaysBefore).toEqual(['mon', 'wed', 'fri'])` - Verify specific weekdays
2. Pre-deletion: `expect(pattern1WeekdaysBefore).toHaveLength(3)` - Verify via global query
3. Post-deletion: `expect(weekdaysAfter).toEqual([])` - Pattern-specific query empty
4. Post-deletion: `expect(pattern1WeekdaysAfter).toHaveLength(0)` - Global query confirms deletion

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific weekday values before deletion (already done at line 503)
- Verifies via global query that records exist before deletion
- Confirms cascade via both pattern-specific and global queries
- Cannot pass if `getPatternWeekdays` always returns []
- Cannot pass if weekdays were never created

**What specific changes would transform this test into its ideal form?**

Add after line 506:
```typescript
// Also verify via global query that records are gone
const allWeekdays = await adapter.getAllPatternWeekdays()
const pattern1Weekdays = allWeekdays.filter(w => w.patternId === 'pattern-1')
expect(pattern1Weekdays).toHaveLength(0)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 490-530 to examine the exact violation at line 506

3. **Search for weekday operations** - Used Grep tool with pattern `getPatternWeekdays|setPatternWeekdays` across the codebase, finding:
   - tests/04-adapter.test.ts:500, 502, 505, 542, 543, 548, 549, 550, 555, 557, 560, 571, 572, 2045, 2051
   - tests/15-sqlite-adapter.test.ts:768
   - notes/adapter-interface.md:35, 36
   - notes/testing-spec-04-adapter.md:175, 176, 182, 183

4. **Read testing specification** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 160-200 to find LAW 19 and LAW 23 definitions

5. **Read adapter interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 32-57 to understand deletePattern, setPatternWeekdays, getPatternWeekdays, and getAllPatternWeekdays method signatures

6. **Search for deletePattern usage** - Used Grep tool with pattern `deletePattern` across the codebase, finding:
   - notes/adapter-interface.md:32
   - notes/testing-spec-04-adapter.md:158
   - tests/04-adapter.test.ts:504, 559
   - tests/fuzz/properties/pattern-crud.test.ts:44, 143, 152, 180

7. **Search for getAllPatternWeekdays usage** - Used Grep tool with pattern `getAllPatternWeekdays` finding usage at:
   - notes/adapter-interface.md:37
   - notes/testing-spec-04-adapter.md:177
   - tests/04-adapter.test.ts:574

8. **Read PatternWeekdayRow structure** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 160-175 to understand the PatternWeekdayRow interface

9. **Read getAllPatternWeekdays test usage** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 568-583 to see how getAllPatternWeekdays is used to verify pattern-weekday associations

10. **Search for weekday type definition** - Used Grep tool with pattern `weekday|Weekday` in notes/type-shapes.md, finding Weekday type definition at line 38 and weekday-based pattern types at lines 23, 28-36

---

## Violation #4: tests/04-adapter.test.ts:561

**Test Name:** `pattern delete cascades weekdays`

**Violation Line:**
```typescript
expect(weekdays).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 23 from the adapter specification: "Pattern deletion cascades to weekdays" (notes/testing-spec-04-adapter.md:184). When a pattern is deleted, all associated weekday entries must also be deleted. This test is in the "Pattern Weekday Operations" describe block (tests/04-adapter.test.ts:526).

**What functionality or behavior is it verifying?**

The test verifies that:
1. Weekday entries can be set for a pattern via `setPatternWeekdays`
2. When the pattern is deleted via `deletePattern`, the weekday entries are automatically removed
3. Subsequent calls to `getPatternWeekdays` for the deleted pattern return an empty array

**Why does this specific test matter?**

Weekday entries determine on which days a scheduled task should occur. The `{ type: 'weekdays', days: Weekday[] }` pattern type relies on these entries. If weekday entries survive their parent pattern:
- Database integrity is compromised with orphan records
- Future pattern creations might inherit stale data
- Storage bloat accumulates over time

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getPatternWeekdays` is broken and always returns `[]`
- The weekdays were never set successfully in the first place
- A different bug caused the weekdays to be deleted before `deletePattern` was called
- The pattern deletion failed silently but the query still returns empty

**Why does getting it right matter?**

For medically fragile people, data integrity failures could:
- Cause phantom schedules to appear or disappear unexpectedly
- Lead to database corruption over time
- Eventually cause scheduling errors when orphan records interfere

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 23** - notes/testing-spec-04-adapter.md:184 states "LAW 23: Pattern deletion cascades to weekdays"

2. **LAW 19** - notes/testing-spec-04-adapter.md:166 states "LAW 19: Pattern deletion cascades to pattern_weekday entries" (same behavior, different wording)

3. **Test Plan Reference** - notes/test-plan-04.md:87 specifies test "pattern delete cascades" with expected result "Weekdays gone" and "LAW 23" verification

4. **Adapter Interface - deletePattern** - notes/adapter-interface.md:32 defines `deletePattern(id: string): void`

5. **Adapter Interface - setPatternWeekdays** - notes/adapter-interface.md:35 defines `setPatternWeekdays(patternId: string, weekdays: Weekday[]): void  // replaces all`

6. **Adapter Interface - getPatternWeekdays** - notes/adapter-interface.md:36 defines `getPatternWeekdays(patternId: string): Weekday[]`

7. **Adapter Interface - getAllPatternWeekdays** - notes/adapter-interface.md:37 defines `getAllPatternWeekdays(): PatternWeekdayRow[]  // for bulk loading`

8. **Test beforeEach Setup** - tests/04-adapter.test.ts:527-538 shows the beforeEach creates a series and pattern with type 'weekdays':
   ```typescript
   await adapter.createSeries({
     id: 'series-1',
     title: 'Test',
     createdAt: '2024-01-15T10:00:00' as LocalDateTime,
   })
   await adapter.createPattern({
     id: 'pattern-1',
     seriesId: 'series-1',
     type: 'weekdays',
     conditionId: null,
   } as Pattern)
   ```

9. **getAllPatternWeekdays Test** - tests/04-adapter.test.ts:574-581 shows how `getAllPatternWeekdays` can verify pattern-weekday associations globally

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both pattern-specific and global queries:

```typescript
it('pattern delete cascades weekdays', async () => {
  await adapter.setPatternWeekdays('pattern-1', ['mon', 'wed'])

  // Verify weekdays exist with correct values before deletion
  const weekdaysBefore = await adapter.getPatternWeekdays('pattern-1')
  expect(weekdaysBefore).toEqual(['mon', 'wed'])

  // Also verify via global query that records exist
  const allBefore = await adapter.getAllPatternWeekdays()
  const pattern1Before = allBefore.filter(w => w.patternId === 'pattern-1')
  expect(pattern1Before).toHaveLength(2)
  expect(pattern1Before.map(w => w.weekday).sort()).toEqual(['mon', 'wed'])

  await adapter.deletePattern('pattern-1')

  // Verify cascade via pattern-specific query
  const weekdaysAfter = await adapter.getPatternWeekdays('pattern-1')
  expect(weekdaysAfter).toEqual([])

  // Verify cascade via global query - no entries for deleted pattern
  const allAfter = await adapter.getAllPatternWeekdays()
  const pattern1After = allAfter.filter(w => w.patternId === 'pattern-1')
  expect(pattern1After).toHaveLength(0)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(weekdaysBefore).toEqual(['mon', 'wed'])` - Verify specific weekdays (already done)
2. Pre-deletion: `expect(pattern1Before).toHaveLength(2)` - Verify via global query
3. Post-deletion: `expect(weekdaysAfter).toEqual([])` - Pattern-specific query empty
4. Post-deletion: `expect(pattern1After).toHaveLength(0)` - Global query confirms deletion

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific weekday values before deletion (already done at line 558)
- Verifies via global query (`getAllPatternWeekdays`) that records exist before deletion
- Confirms cascade via both pattern-specific and global queries
- Cannot pass if `getPatternWeekdays` always returns []
- Cannot pass if weekdays were never created

**What specific changes would transform this test into its ideal form?**

Add before and after the deletion:
```typescript
// Before deletion - verify via global query
const allBefore = await adapter.getAllPatternWeekdays()
const pattern1Before = allBefore.filter(w => w.patternId === 'pattern-1')
expect(pattern1Before).toHaveLength(2)

// ... existing deletePattern call ...

// After line 561 - verify via global query that records are gone
const allAfter = await adapter.getAllPatternWeekdays()
const pattern1After = allAfter.filter(w => w.patternId === 'pattern-1')
expect(pattern1After).toHaveLength(0)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 550-585 to examine the exact violation at line 561

3. **Read the beforeEach setup** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 520-555 to understand the test context and setup in the 'Pattern Weekday Operations' describe block

4. **Search for cascade laws** - Used Grep tool with pattern `pattern.*cascade.*weekday|weekday.*cascade|LAW 19|LAW 23` (case insensitive) across notes directory, finding:
   - notes/testing-spec-04-adapter.md:166 - "LAW 19: Pattern deletion cascades to pattern_weekday entries"
   - notes/testing-spec-04-adapter.md:184 - "LAW 23: Pattern deletion cascades to weekdays"
   - notes/test-plan-04.md:74, 87 - Test plan references to cascade tests

5. **Read testing specification** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 163-193 to understand LAW 19, LAW 23 and pattern weekday operation specifications

6. **Read test plan** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/test-plan-04.md lines 70-95 to see the official test plan for pattern weekday operations

7. **Read adapter interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 30-50 to understand deletePattern, setPatternWeekdays, getPatternWeekdays, and getAllPatternWeekdays method signatures

8. **Search for getAllPatternWeekdays usage** - Used Grep tool with pattern `getAllPatternWeekdays` across the codebase, finding usage at:
   - tests/04-adapter.test.ts:574
   - notes/adapter-interface.md:37
   - notes/testing-spec-04-adapter.md:177

---

## Violation #5: tests/04-adapter.test.ts:917

**Test Name:** `config delete cascades items`

**Violation Line:**
```typescript
expect(itemsBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 35 from the adapter specification: "Config deletion cascades to items" (notes/testing-spec-04-adapter.md:246). When a cycling config is deleted (by setting it to null via `setCyclingConfig`), all associated cycling items must also be deleted.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Cycling items can be created for a cycling config
2. When the config is deleted via `setCyclingConfig('series-1', null)`, the items are automatically removed
3. Subsequent calls to `getCyclingItems` return an empty array

**Why does this specific test matter?**

Cycling items define the rotation schedule for recurring tasks (e.g., rotating between different care activities). If cycling items survive their parent config being deleted:
- Orphan items accumulate in the database
- Future config creations might inherit stale items
- System may behave unpredictably when encountering orphan data

**What are the consequences if this test is wrong or weak?**

The `length` check only verifies that 1 item exists, not what item it is. The assertion could pass when:
- The wrong item is returned (different title, duration, position)
- A corrupted item is returned
- An item from a different config is returned
- The `getCyclingItems` function returns arbitrary data

**Why does getting it right matter?**

For medically fragile people, orphan cycling items could:
- Cause incorrect rotation of care activities
- Present phantom schedules to caregivers
- Lead to database integrity issues over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 35** - notes/testing-spec-04-adapter.md:246 states "LAW 35: Config deletion cascades to items"

2. **Adapter Interface - setCyclingConfig** - notes/adapter-interface.md:53 defines `setCyclingConfig(seriesId: string, config: CyclingConfigRow | null): void  // null removes`

3. **Adapter Interface - getCyclingItems** - notes/adapter-interface.md:60 defines `getCyclingItems(configId: string): CyclingItemRow[]  // ordered by position`

4. **Adapter Interface - setCyclingItems** - notes/adapter-interface.md:59 defines `setCyclingItems(configId: string, items: CyclingItemRow[]): void  // replaces all`

5. **Adapter Interface - getAllCyclingItems** - notes/adapter-interface.md:61 defines `getAllCyclingItems(): CyclingItemRow[]`

6. **CyclingItemRow Structure** - notes/adapter-interface.md:198-204 defines:
   ```typescript
   interface CyclingItemRow {
     id: string
     cycling_config_id: string
     position: number
     title: string
     description: string | null
   }
   ```

7. **LAW 33** - notes/testing-spec-04-adapter.md:244 states "LAW 33: setCyclingItems replaces all items"

8. **LAW 34** - notes/testing-spec-04-adapter.md:245 states "LAW 34: getCyclingItems returns items ordered by position"

9. **Strong Assertions in Other Tests** - tests/04-adapter.test.ts:861-865 shows how other tests properly verify cycling items:
   ```typescript
   expect(result.map((r) => r.title)).toEqual(['A', 'B'])
   expect(result[0].duration).toBe(30)
   expect(result[0].position).toBe(0)
   ```

10. **LAW 36** - notes/testing-spec-04-adapter.md:247 states "LAW 36: Series deletion cascades to cycling config" (shows cascade chain)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the item's actual properties before deletion:

```typescript
it('config delete cascades items', async () => {
  await adapter.setCyclingConfig('series-1', {
    seriesId: 'series-1',
    currentIndex: 0,
    gapLeap: true,
  })
  await adapter.setCyclingItems('series-1', [
    { seriesId: 'series-1', position: 0, title: 'A', duration: 30 },
  ])

  // Verify items exist with correct properties before clearing config
  const itemsBefore = await adapter.getCyclingItems('series-1')
  expect(itemsBefore).toHaveLength(1)
  expect(itemsBefore[0]).toMatchObject({
    title: 'A',
    position: 0,
    duration: 30,
  })

  await adapter.setCyclingConfig('series-1', null)

  const items = await adapter.getCyclingItems('series-1')
  expect(items).toEqual([])
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(itemsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(itemsBefore[0]).toMatchObject({title: 'A', position: 0, duration: 30})` - Verify actual data
3. Post-deletion: `expect(items).toEqual([])` - Verify cascade deletion (already present)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the specific item exists with correct properties before deletion
- Confirms title, position, and duration match what was set
- Cannot pass if getCyclingItems returns wrong items
- Cannot pass if items were never created

**What specific changes would transform this test into its ideal form?**

Replace line 917:
```typescript
expect(itemsBefore.length).toBe(1)
```

With:
```typescript
expect(itemsBefore).toHaveLength(1)
expect(itemsBefore[0]).toMatchObject({
  title: 'A',
  position: 0,
  duration: 30,
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 900-944 to examine the exact violation at line 917

3. **Search for cycling config operations** - Used Grep tool with pattern `setCyclingConfig|getCyclingConfig|CyclingConfig` across notes directory, finding:
   - notes/testing-spec-04-adapter.md:231-233
   - notes/adapter-interface.md:52-56
   - notes/adapter-interface.md:190

4. **Search for cycling items operations** - Used Grep tool with pattern `setCyclingItems|getCyclingItems|CyclingItem` across notes directory, finding:
   - notes/testing-spec-04-adapter.md:236-238, 244-246
   - notes/adapter-interface.md:58-61, 198
   - notes/test-plan-04.md:134

5. **Search for cascade laws** - Used Grep tool with pattern `config.*cascade.*item|item.*cascade|cycling.*delete|LAW 3[0-9]` (case insensitive) across notes directory, finding LAW 35 at notes/testing-spec-04-adapter.md:246

6. **Read testing specification for cycling** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 228-263 to understand cycling operation laws

7. **Read CyclingItemRow interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 195-210 to understand the CyclingItemRow structure

8. **Search for getAllCyclingItems usage** - Used Grep tool with pattern `getAllCyclingItems` across the codebase, finding interface definitions at notes/adapter-interface.md:61 and notes/testing-spec-04-adapter.md:238

9. **Read other cycling tests for comparison** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 860-905 to see how other tests properly verify cycling items with strong assertions

---

## Violation #6: tests/04-adapter.test.ts:920

**Test Name:** `config delete cascades items`

**Violation Line:**
```typescript
expect(items).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion is the core verification of LAW 35: "Config deletion cascades to items" (notes/testing-spec-04-adapter.md:246). It verifies that after a cycling config is deleted by setting it to null via `setCyclingConfig('series-1', null)`, all associated cycling items have been automatically removed from the database.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `setCyclingConfig('series-1', null)` is called
2. The call to `getCyclingItems('series-1')` returns an empty array
3. The cycling items no longer exist for the deleted config

**Why does this specific test matter?**

This test validates database cascade behavior defined at the schema level (notes/schema.md:69): `cycling_config_id TEXT NOT NULL REFERENCES cycling_config(id) ON DELETE CASCADE`. If this cascade fails, orphan cycling items would remain in the database.

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getCyclingItems` is broken and always returns `[]`
- The items were never created successfully
- A different bug caused the items to be deleted before `setCyclingConfig(null)` was called
- The config deletion failed but the query still returns empty

**Why does getting it right matter?**

For medically fragile people, database integrity failures in cycling configurations could:
- Cause incorrect rotation of care activities
- Lead to phantom schedules appearing or disappearing
- Eventually cause cascade failures in the scheduling system

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 35** - notes/testing-spec-04-adapter.md:246 states "LAW 35: Config deletion cascades to items"

2. **Test Plan Reference** - notes/test-plan-04.md:137 specifies test "config delete cascades items" with expected result "Items deleted" and "LAW 35" verification

3. **Database Schema** - notes/schema.md:69 shows the foreign key constraint:
   ```sql
   cycling_config_id TEXT NOT NULL REFERENCES cycling_config(id) ON DELETE CASCADE
   ```

4. **Schema Design Rationale** - notes/schema.md:269 states "cycling_item | CASCADE | Items meaningless without config"

5. **Adapter Interface - setCyclingConfig** - notes/adapter-interface.md:53 defines `setCyclingConfig(seriesId: string, config: CyclingConfigRow | null): void  // null removes`

6. **Adapter Interface - getCyclingItems** - notes/adapter-interface.md:60 defines `getCyclingItems(configId: string): CyclingItemRow[]  // ordered by position`

7. **Adapter Interface - getAllCyclingItems** - notes/adapter-interface.md:61 defines `getAllCyclingItems(): CyclingItemRow[]` - could be used for stronger verification

8. **LAW 33** - notes/testing-spec-04-adapter.md:244 states "LAW 33: setCyclingItems replaces all items"

9. **LAW 34** - notes/testing-spec-04-adapter.md:245 states "LAW 34: getCyclingItems returns items ordered by position"

10. **Cascade Chain** - notes/testing-spec-04-adapter.md:247 states "LAW 36: Series deletion cascades to cycling config" showing the full cascade chain: Series → Config → Items

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both config-specific and global queries:

```typescript
it('config delete cascades items', async () => {
  await adapter.setCyclingConfig('series-1', {
    seriesId: 'series-1',
    currentIndex: 0,
    gapLeap: true,
  })
  await adapter.setCyclingItems('series-1', [
    { seriesId: 'series-1', position: 0, title: 'A', duration: 30 },
  ])

  // Verify items exist with correct properties before clearing config
  const itemsBefore = await adapter.getCyclingItems('series-1')
  expect(itemsBefore).toHaveLength(1)
  expect(itemsBefore[0]).toMatchObject({
    title: 'A',
    position: 0,
    duration: 30,
  })

  // Also verify via global query that the item exists
  const allItemsBefore = await adapter.getAllCyclingItems()
  const series1ItemsBefore = allItemsBefore.filter(i => i.cyclingConfigId === 'series-1')
  expect(series1ItemsBefore).toHaveLength(1)

  await adapter.setCyclingConfig('series-1', null)

  // Verify cascade via config-specific query
  const items = await adapter.getCyclingItems('series-1')
  expect(items).toEqual([])

  // Verify cascade via global query - no items for deleted config
  const allItemsAfter = await adapter.getAllCyclingItems()
  const series1ItemsAfter = allItemsAfter.filter(i => i.cyclingConfigId === 'series-1')
  expect(series1ItemsAfter).toHaveLength(0)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(itemsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(itemsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: `expect(series1ItemsBefore).toHaveLength(1)` - Verify via global query
4. Post-deletion: `expect(items).toEqual([])` - Config-specific query empty
5. Post-deletion: `expect(series1ItemsAfter).toHaveLength(0)` - Global query confirms cascade

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific item properties before deletion
- Confirms items exist via global query before deletion
- Verifies cascade via both config-specific and global queries
- Cannot pass if `getCyclingItems` always returns []
- Cannot pass if items were never created

**What specific changes would transform this test into its ideal form?**

Add after line 920:
```typescript
// Also verify via global query that items are gone
const allItems = await adapter.getAllCyclingItems()
const series1Items = allItems.filter(i => i.cyclingConfigId === 'series-1')
expect(series1Items).toHaveLength(0)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 903-942 to examine the exact violation at line 920

3. **Search for cycling config and cascade laws** - Used Grep tool with pattern `setCyclingConfig|LAW 35|config.*cascade|cascade.*item` (case insensitive) across notes directory, finding:
   - notes/testing-spec-04-adapter.md:246 - "LAW 35: Config deletion cascades to items"
   - notes/test-plan-04.md:137 - Test plan entry
   - notes/adapter-interface.md:53 - setCyclingConfig signature
   - notes/schema.md:69 - ON DELETE CASCADE constraint

4. **Read testing specification for cycling** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 240-265 to understand cycling operation laws including LAW 32-36

5. **Read adapter interface for cycling items** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 55-75 to understand setCyclingItems, getCyclingItems, and getAllCyclingItems method signatures

6. **Read database schema** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/schema.md lines 63-77 to examine the cycling_item table definition and ON DELETE CASCADE constraint

---

## Violation #7: tests/04-adapter.test.ts:934

**Test Name:** `series delete cascades config and items`

**Violation Line:**
```typescript
expect(itemsBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies the cascade chain: LAW 36 "Series deletion cascades to cycling config" (notes/testing-spec-04-adapter.md:247) combined with LAW 35 "Config deletion cascades to items" (notes/testing-spec-04-adapter.md:246). When a series is deleted, the cycling config is deleted, which then cascades to delete all cycling items.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Cycling config and items can be created for a series
2. When the series is deleted via `deleteSeries`, the cascade chain removes both the config and items
3. The series no longer appears in `getAllSeries`
4. The items no longer appear in `getCyclingItems`

**Why does this specific test matter?**

This test validates multi-level cascade deletion. If the cascade chain fails at any level, orphan data would remain in the database. This is critical for maintaining referential integrity across the entire scheduling system.

**What are the consequences if this test is wrong or weak?**

The `length` check only verifies that 1 item exists, not what item it is. The assertion could pass when:
- The wrong item is returned
- An item from a different series is returned
- The `getCyclingItems` function returns arbitrary data
- The item has corrupted properties

**Why does getting it right matter?**

For medically fragile people, cascade deletion failures could:
- Leave orphan cycling items causing phantom schedules
- Lead to database integrity violations
- Eventually cause system-wide scheduling failures

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 36** - notes/testing-spec-04-adapter.md:247 states "LAW 36: Series deletion cascades to cycling config"

2. **LAW 35** - notes/testing-spec-04-adapter.md:246 states "LAW 35: Config deletion cascades to items"

3. **Cascade Chain** - The combined laws create a cascade: Series → Config → Items

4. **Test Plan Reference** - notes/test-plan-04.md:138 specifies test "series delete cascades config" with "LAW 36"

5. **Adapter Interface - deleteSeries** - notes/adapter-interface.md:24 defines `deleteSeries(id: string): void  // DB throws if completions exist or has linked children (RESTRICT)`

6. **Adapter Interface - getCyclingItems** - notes/adapter-interface.md:60 defines `getCyclingItems(configId: string): CyclingItemRow[]  // ordered by position`

7. **Adapter Interface - getAllCyclingItems** - notes/adapter-interface.md:61 defines `getAllCyclingItems(): CyclingItemRow[]`

8. **CyclingItemRow Interface** - notes/adapter-interface.md:198-204 defines:
   ```typescript
   interface CyclingItemRow {
     id: string
     cycling_config_id: string
     position: number
     title: string
     description: string | null
   }
   ```

9. **LAW 34** - notes/testing-spec-04-adapter.md:245 states "LAW 34: getCyclingItems returns items ordered by position"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the item's actual properties before deletion:

```typescript
it('series delete cascades config and items', async () => {
  await adapter.setCyclingConfig('series-1', {
    seriesId: 'series-1',
    currentIndex: 0,
    gapLeap: true,
  })
  await adapter.setCyclingItems('series-1', [
    { seriesId: 'series-1', position: 0, title: 'A', duration: 30 },
  ])

  // Verify items exist with correct properties before deletion
  const itemsBefore = await adapter.getCyclingItems('series-1')
  expect(itemsBefore).toHaveLength(1)
  expect(itemsBefore[0]).toMatchObject({
    title: 'A',
    position: 0,
    duration: 30,
  })

  await adapter.deleteSeries('series-1')

  // Verify series was deleted
  const allSeries = await adapter.getAllSeries()
  expect(allSeries.map(s => s.id)).not.toContain('series-1')

  // Verify cascade deleted items
  const items = await adapter.getCyclingItems('series-1')
  expect(items).toEqual([])
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(itemsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(itemsBefore[0]).toMatchObject({title: 'A', position: 0, duration: 30})` - Verify actual data
3. Post-deletion: `expect(allSeries.map(s => s.id)).not.toContain('series-1')` - Series deleted (already present)
4. Post-deletion: `expect(items).toEqual([])` - Items cascade deleted (already present)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the specific item exists with correct properties before deletion
- Confirms title, position, and duration match what was set
- Cannot pass if getCyclingItems returns wrong items
- Cannot pass if items were never created

**What specific changes would transform this test into its ideal form?**

Replace line 934:
```typescript
expect(itemsBefore.length).toBe(1)
```

With:
```typescript
expect(itemsBefore).toHaveLength(1)
expect(itemsBefore[0]).toMatchObject({
  title: 'A',
  position: 0,
  duration: 30,
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 920-955 to examine the exact violation at line 934

3. **Search for series cascade laws** - Used Grep tool with pattern `series.*delete.*cascade|deleteSeries.*cascade|LAW 36` (case insensitive) across notes directory, finding:
   - notes/testing-spec-04-adapter.md:247 - "LAW 36: Series deletion cascades to cycling config"
   - notes/fuzz-testing-task-list.md:176-182 - Property test references
   - notes/test-plan-04.md:138 - Test plan entry

4. **Read testing specification for cycling** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 240-260 to understand cycling operation laws including LAW 32-36 and the cascade chain

5. **Search for getCyclingItems interface** - Used Grep tool with pattern `getCyclingItems|getAllCyclingItems` in notes/adapter-interface.md, finding definitions at lines 60-61

6. **Read CyclingItemRow interface** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 198-207 to understand the CyclingItemRow structure

---

## Violation #8: tests/04-adapter.test.ts:940

**Test Name:** `series delete cascades config and items`

**Violation Line:**
```typescript
expect(items).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion verifies the final result of the cascade chain: LAW 36 "Series deletion cascades to cycling config" combined with LAW 35 "Config deletion cascades to items" (notes/testing-spec-04-adapter.md:246-247). After a series is deleted, all associated cycling items should be automatically removed via the cascade.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `deleteSeries('series-1')` is called
2. The cycling items that were associated with the series's cycling config no longer exist
3. `getCyclingItems('series-1')` returns an empty array

**Why does this specific test matter?**

This test validates the multi-level database cascade: Series → CyclingConfig → CyclingItems. The database schema (notes/schema.md:69) defines `cycling_config_id TEXT NOT NULL REFERENCES cycling_config(id) ON DELETE CASCADE`, ensuring items are automatically deleted when their parent config is deleted.

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getCyclingItems` is broken and always returns `[]`
- The items were never created successfully in the first place
- A different bug deleted the items before `deleteSeries` was called
- The cascade failed but the query returns empty for another reason

**Why does getting it right matter?**

For medically fragile people, cascade deletion failures could:
- Leave orphan cycling items causing phantom schedules
- Lead to database integrity violations over time
- Eventually cause system-wide scheduling failures when orphan data accumulates

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 36** - notes/testing-spec-04-adapter.md:247 states "LAW 36: Series deletion cascades to cycling config"

2. **LAW 35** - notes/testing-spec-04-adapter.md:246 states "LAW 35: Config deletion cascades to items"

3. **Cascade Chain** - The combined laws create a cascade: Series → Config → Items

4. **Adapter Interface - deleteSeries** - notes/adapter-interface.md:24 defines `deleteSeries(id: string): void  // DB throws if completions exist or has linked children (RESTRICT)`

5. **Adapter Interface - getCyclingItems** - notes/adapter-interface.md:60 defines `getCyclingItems(configId: string): CyclingItemRow[]  // ordered by position`

6. **Adapter Interface - getAllCyclingItems** - notes/adapter-interface.md:61 defines `getAllCyclingItems(): CyclingItemRow[]`

7. **Database Schema - CyclingItem** - notes/schema.md:67-76 defines:
   ```sql
   CREATE TABLE cycling_item (
     id TEXT PRIMARY KEY,
     cycling_config_id TEXT NOT NULL REFERENCES cycling_config(id) ON DELETE CASCADE,
     position INTEGER NOT NULL,
     title TEXT NOT NULL,
     description TEXT,
     UNIQUE (cycling_config_id, position)
   );
   ```

8. **Schema Design Rationale** - notes/schema.md:269 states "cycling_item | CASCADE | Items meaningless without config"

9. **CyclingItemRow Interface** - notes/adapter-interface.md:198-204 defines:
   ```typescript
   interface CyclingItemRow {
     id: string
     cycling_config_id: string
     position: number
     title: string
     description: string | null
   }
   ```

10. **LAW 34** - notes/testing-spec-04-adapter.md:245 states "LAW 34: getCyclingItems returns items ordered by position"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both config-specific and global queries:

```typescript
it('series delete cascades config and items', async () => {
  await adapter.setCyclingConfig('series-1', {
    seriesId: 'series-1',
    currentIndex: 0,
    gapLeap: true,
  })
  await adapter.setCyclingItems('series-1', [
    { seriesId: 'series-1', position: 0, title: 'A', duration: 30 },
  ])

  // Verify items exist with correct properties before deletion
  const itemsBefore = await adapter.getCyclingItems('series-1')
  expect(itemsBefore).toHaveLength(1)
  expect(itemsBefore[0]).toMatchObject({
    title: 'A',
    position: 0,
    duration: 30,
  })

  // Verify via global query that the item exists
  const allItemsBefore = await adapter.getAllCyclingItems()
  const series1ItemsBefore = allItemsBefore.filter(i => i.cyclingConfigId === 'series-1')
  expect(series1ItemsBefore).toHaveLength(1)

  await adapter.deleteSeries('series-1')

  // Verify series was deleted
  const allSeries = await adapter.getAllSeries()
  expect(allSeries.map(s => s.id)).not.toContain('series-1')

  // Verify cascade via config-specific query
  const items = await adapter.getCyclingItems('series-1')
  expect(items).toEqual([])

  // Verify cascade via global query - no items for deleted config
  const allItemsAfter = await adapter.getAllCyclingItems()
  const series1ItemsAfter = allItemsAfter.filter(i => i.cyclingConfigId === 'series-1')
  expect(series1ItemsAfter).toHaveLength(0)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(itemsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(itemsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: `expect(series1ItemsBefore).toHaveLength(1)` - Verify via global query
4. Post-deletion: `expect(allSeries.map(s => s.id)).not.toContain('series-1')` - Series deleted (already present)
5. Post-deletion: `expect(items).toEqual([])` - Config-specific query empty (already present)
6. Post-deletion: `expect(series1ItemsAfter).toHaveLength(0)` - Global query confirms cascade

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific item properties before deletion
- Confirms items exist via global query before deletion
- Verifies cascade via both config-specific and global queries
- Cannot pass if `getCyclingItems` always returns []
- Cannot pass if items were never created

**What specific changes would transform this test into its ideal form?**

Add after line 940:
```typescript
// Also verify via global query that items are gone
const allItems = await adapter.getAllCyclingItems()
const series1Items = allItems.filter(i => i.cyclingConfigId === 'series-1')
expect(series1Items).toHaveLength(0)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 920-970 to examine the exact violation at line 940

3. **Search for deleteSeries method** - Used Grep tool with pattern `deleteSeries` across the codebase, finding 28 files including:
   - notes/adapter-interface.md:24 - Method signature
   - notes/testing-spec-04-adapter.md:145 - LAW 17
   - notes/fuzz-testing-task-list.md:176-182 - Property test references

4. **Search for cascade laws** - Used Grep tool with pattern `LAW.*(series|Series).*delete|delete.*series.*cascade` (case insensitive) across notes directory, finding:
   - notes/testing-spec-04-adapter.md:145 - LAW 17
   - notes/testing-spec-04-adapter.md:247 - LAW 36
   - notes/fuzz-testing-task-list.md:175-182 - Property tests for cascade

5. **Search for cycling cascade laws** - Used Grep tool with pattern `LAW.*(cycling|Cycling).*cascade|cascade.*cycling|LAW 3[456]` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 245: LAW 34 - getCyclingItems returns items ordered by position
   - Line 246: LAW 35 - Config deletion cascades to items
   - Line 247: LAW 36 - Series deletion cascades to cycling config

6. **Read testing specification for cycling** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 225-265 to understand cycling operation laws

7. **Search for getCyclingItems usage** - Used Grep tool with pattern `getCyclingItems` across *.ts files, finding:
   - tests/04-adapter.test.ts:860, 881, 900, 916, 919, 933, 939
   - tests/15-sqlite-adapter.test.ts:713

8. **Search for getAllCyclingItems usage** - Used Grep tool with pattern `getAllCyclingItems` across *.ts files - no matches found in test code, only in interface definitions

9. **Search for CyclingItem in schema** - Used Grep tool with pattern `cycling_item|CyclingItem|FOREIGN KEY.*cycling` (case insensitive) in notes/schema.md, finding:
   - Line 63-76: CREATE TABLE cycling_item with ON DELETE CASCADE
   - Line 269: Schema design rationale

10. **Read CyclingItemRow interface** - Used Grep tool with pattern `CyclingItemRow|interface.*CyclingItem` in notes/adapter-interface.md, finding interface definition at lines 198-204

11. **Read database schema** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/schema.md lines 63-77 to examine the cycling_item table definition and ON DELETE CASCADE constraint

---

## Violation #9: tests/04-adapter.test.ts:1058

**Test Name:** `series delete cascades exceptions`

**Violation Line:**
```typescript
expect(exceptionsBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 39 from the adapter specification: "Series deletion cascades to exceptions" (notes/testing-spec-04-adapter.md:266). When a series is deleted, all instance exceptions (cancellations, reschedulings) associated with that series should be automatically removed from the database.

**What functionality or behavior is it verifying?**

The test verifies that:
1. An instance exception can be created and associated with a series
2. The exception exists before series deletion
3. When `deleteSeries('series-1')` is called, the exception is automatically deleted via cascade
4. `getExceptionsBySeries` returns an empty array after deletion

**Why does this specific test matter?**

Instance exceptions represent schedule modifications (cancelled or rescheduled occurrences). If exceptions survive their parent series being deleted:
- Orphan exception data accumulates in the database
- The scheduling system may encounter exceptions referencing non-existent series
- Database integrity violations could cascade into system failures

**What are the consequences if this test is wrong or weak?**

The `length` check only verifies that 1 exception exists, not what exception it is. The assertion could pass when:
- A different exception is returned (wrong id, type, date)
- An exception from a different series is returned
- The `getExceptionsBySeries` function returns arbitrary data
- The exception has corrupted properties

**Why does getting it right matter?**

For medically fragile people, orphan instance exceptions could:
- Cause the scheduler to process phantom cancellations or reschedulings
- Present misleading information to caregivers about schedule changes
- Lead to database corruption over time as orphan data accumulates

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 39** - notes/testing-spec-04-adapter.md:266 states "LAW 39: Series deletion cascades to exceptions"

2. **LAW 37** - notes/testing-spec-04-adapter.md:264 states "LAW 37: At most one exception per (seriesId, instanceDate)"

3. **LAW 38** - notes/testing-spec-04-adapter.md:265 states "LAW 38: Second exception for same key throws DuplicateKeyError or updates"

4. **Adapter Interface - getInstanceExceptionsBySeries** - notes/adapter-interface.md:66 defines `getInstanceExceptionsBySeries(seriesId: string): InstanceExceptionRow[]`

5. **Adapter Interface - createInstanceException** - notes/adapter-interface.md:64 defines `createInstanceException(exception: InstanceExceptionRow): void`

6. **InstanceExceptionRow Interface** - notes/adapter-interface.md:206-213 defines:
   ```typescript
   interface InstanceExceptionRow {
     id: string
     series_id: string
     instance_date: string  // ISO date
     type: string  // 'cancelled' | 'rescheduled'
     new_time: string | null  // ISO datetime
     created_at: string
   }
   ```

7. **Database Schema - instance_exception** - notes/schema.md:145-155 defines:
   ```sql
   CREATE TABLE instance_exception (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     type TEXT NOT NULL CHECK (type IN ('cancelled', 'rescheduled')),
     new_time TEXT,
     created_at TEXT NOT NULL,
     UNIQUE (series_id, instance_date)
   );
   ```

8. **Schema Design Rationale** - notes/schema.md:273 states "instance_exception | CASCADE | Exceptions meaningless without series"

9. **Exception Operations in Spec** - notes/testing-spec-04-adapter.md:255-259 defines the exception operations interface

10. **getInstanceExceptionsInRange** - notes/adapter-interface.md:67 defines `getInstanceExceptionsInRange(startDate: string, endDate: string): InstanceExceptionRow[]` - could be used for cross-verification

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the exception's actual properties before deletion:

```typescript
it('series delete cascades exceptions', async () => {
  await adapter.createInstanceException({
    id: 'exc-1',
    seriesId: 'series-1',
    originalDate: '2024-01-15' as LocalDate,
    type: 'cancel',
  })

  // Verify exception exists with correct properties before deletion
  const exceptionsBefore = await adapter.getExceptionsBySeries('series-1')
  expect(exceptionsBefore).toHaveLength(1)
  expect(exceptionsBefore[0]).toMatchObject({
    id: 'exc-1',
    seriesId: 'series-1',
    originalDate: '2024-01-15',
    type: 'cancel',
  })

  // Also verify via range query
  const rangeExceptionsBefore = await adapter.getInstanceExceptionsInRange(
    '2024-01-01' as LocalDate,
    '2024-01-31' as LocalDate
  )
  expect(rangeExceptionsBefore.find(e => e.id === 'exc-1')).toBeDefined()

  await adapter.deleteSeries('series-1')

  // Verify cascade via series-specific query
  const exceptions = await adapter.getExceptionsBySeries('series-1')
  expect(exceptions).toEqual([])

  // Verify cascade via range query
  const rangeExceptionsAfter = await adapter.getInstanceExceptionsInRange(
    '2024-01-01' as LocalDate,
    '2024-01-31' as LocalDate
  )
  expect(rangeExceptionsAfter.find(e => e.id === 'exc-1')).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(exceptionsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(exceptionsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: Range query verification - Confirm via different API
4. Post-deletion: `expect(exceptions).toEqual([])` - Series-specific query empty (already present)
5. Post-deletion: Range query verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific exception properties before deletion (id, seriesId, type, date)
- Confirms exception exists via both series-specific and range queries
- Verifies cascade via both query methods
- Cannot pass if `getExceptionsBySeries` always returns []
- Cannot pass if exception was never created

**What specific changes would transform this test into its ideal form?**

Replace line 1058:
```typescript
expect(exceptionsBefore.length).toBe(1)
```

With:
```typescript
expect(exceptionsBefore).toHaveLength(1)
expect(exceptionsBefore[0]).toMatchObject({
  id: 'exc-1',
  seriesId: 'series-1',
  originalDate: '2024-01-15',
  type: 'cancel',
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1040-1090 to examine the exact violation at line 1058

3. **Search for exception methods in adapter interface** - Used Grep tool with pattern `getExceptionsBySeries|getInstanceExceptionsBySeries` in notes/adapter-interface.md, finding:
   - Line 66: getInstanceExceptionsBySeries signature

4. **Search for exception cascade laws** - Used Grep tool with pattern `InstanceException.*cascade|cascade.*exception|LAW.*exception` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 264: LAW 37 - uniqueness constraint
   - Line 265: LAW 38 - duplicate handling
   - Line 266: LAW 39 - cascade deletion

5. **Read testing specification for exceptions** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-04-adapter.md lines 252-282 to understand instance exception operation laws

6. **Search for InstanceExceptionRow interface** - Used Grep tool with pattern `InstanceExceptionRow|interface.*InstanceException` in notes/adapter-interface.md, finding interface definition at lines 206-213

7. **Search for exception schema** - Used Grep tool with pattern `instance_exception|REFERENCES.*series.*CASCADE` (case insensitive) in notes/schema.md, finding:
   - Lines 145-155: CREATE TABLE instance_exception with ON DELETE CASCADE
   - Line 273: Schema design rationale

8. **Read adapter interface for exception operations** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/adapter-interface.md lines 62-76 to understand all exception-related methods

9. **Search for getExceptionsBySeries usage in test file** - Used Grep tool with pattern `getExceptionsBySeries` in tests/04-adapter.test.ts, finding usage at lines 1000, 1045, 1057, 1060

10. **Search for createInstanceException usage** - Used Grep tool with pattern `createInstanceException|getInstanceException` in tests/04-adapter.test.ts, finding multiple usages including lines 959, 965, 970, 977, 988, 994, 1009, 1015, 1021, 1038, 1050

---

## Violation #10: tests/04-adapter.test.ts:1061

**Test Name:** `series delete cascades exceptions`

**Violation Line:**
```typescript
expect(exceptions).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion is the core verification of LAW 39: "Series deletion cascades to exceptions" (notes/testing-spec-04-adapter.md:266). It verifies that after a series is deleted, all instance exceptions that were associated with that series have been automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `deleteSeries('series-1')` is called
2. The instance exception 'exc-1' that was associated with 'series-1' no longer exists
3. `getExceptionsBySeries('series-1')` returns an empty array

**Why does this specific test matter?**

This test validates database cascade behavior defined at the schema level (notes/schema.md:147): `series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE`. If this cascade fails, orphan exceptions would remain in the database, potentially causing scheduling inconsistencies.

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getExceptionsBySeries` is broken and always returns `[]`
- The exception was never created successfully
- A different bug deleted the exception before `deleteSeries` was called
- The cascade failed but the query returns empty for another reason

**Why does getting it right matter?**

For medically fragile people, orphan instance exceptions could:
- Cause the scheduler to process phantom cancellations
- Present misleading information about schedule changes
- Lead to database integrity issues over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 39** - notes/testing-spec-04-adapter.md:266 states "LAW 39: Series deletion cascades to exceptions"

2. **Database Schema - instance_exception** - notes/schema.md:145-154 defines:
   ```sql
   CREATE TABLE instance_exception (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     type TEXT NOT NULL CHECK (type IN ('cancelled', 'rescheduled')),
     new_time TEXT,
     created_at TEXT NOT NULL,
     UNIQUE (series_id, instance_date)
   );
   ```

3. **Schema Design Rationale** - notes/schema.md:273 states "instance_exception | CASCADE | Exceptions meaningless without series"

4. **Adapter Interface - getInstanceExceptionsBySeries** - notes/adapter-interface.md:66 defines `getInstanceExceptionsBySeries(seriesId: string): InstanceExceptionRow[]`

5. **Adapter Interface - getInstanceExceptionsInRange** - notes/adapter-interface.md:67 defines `getInstanceExceptionsInRange(startDate: string, endDate: string): InstanceExceptionRow[]` - could be used for cross-verification

6. **InstanceExceptionRow Interface** - notes/adapter-interface.md:206-213 defines:
   ```typescript
   interface InstanceExceptionRow {
     id: string
     series_id: string
     instance_date: string  // ISO date
     type: string  // 'cancelled' | 'rescheduled'
     new_time: string | null  // ISO datetime
     created_at: string
   }
   ```

7. **LAW 37** - notes/testing-spec-04-adapter.md:264 states "LAW 37: At most one exception per (seriesId, instanceDate)" - defines uniqueness

8. **Adapter Interface - createInstanceException** - notes/adapter-interface.md:64 defines `createInstanceException(exception: InstanceExceptionRow): void`

9. **Adapter Interface - deleteInstanceException** - notes/adapter-interface.md:68 defines `deleteInstanceException(seriesId: string, instanceDate: string): void`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both series-specific and range queries:

```typescript
it('series delete cascades exceptions', async () => {
  await adapter.createInstanceException({
    id: 'exc-1',
    seriesId: 'series-1',
    originalDate: '2024-01-15' as LocalDate,
    type: 'cancel',
  })

  // Verify exception exists with correct properties before deletion
  const exceptionsBefore = await adapter.getExceptionsBySeries('series-1')
  expect(exceptionsBefore).toHaveLength(1)
  expect(exceptionsBefore[0]).toMatchObject({
    id: 'exc-1',
    seriesId: 'series-1',
    originalDate: '2024-01-15',
    type: 'cancel',
  })

  // Verify via range query
  const rangeExceptionsBefore = await adapter.getInstanceExceptionsInRange(
    '2024-01-01' as LocalDate,
    '2024-01-31' as LocalDate
  )
  expect(rangeExceptionsBefore.find(e => e.id === 'exc-1')).toBeDefined()

  await adapter.deleteSeries('series-1')

  // Verify cascade via series-specific query
  const exceptions = await adapter.getExceptionsBySeries('series-1')
  expect(exceptions).toEqual([])

  // Verify cascade via range query - exception should not exist
  const rangeExceptionsAfter = await adapter.getInstanceExceptionsInRange(
    '2024-01-01' as LocalDate,
    '2024-01-31' as LocalDate
  )
  expect(rangeExceptionsAfter.find(e => e.id === 'exc-1')).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(exceptionsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(exceptionsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: Range query verification - Confirm via different API
4. Post-deletion: `expect(exceptions).toEqual([])` - Series-specific empty (already present)
5. Post-deletion: Range query verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific exception properties before deletion
- Confirms exception exists via both series-specific and range queries
- Verifies cascade via both query methods
- Cannot pass if `getExceptionsBySeries` always returns []
- Cannot pass if exception was never created

**What specific changes would transform this test into its ideal form?**

Add after line 1061:
```typescript
// Also verify via range query that exception is gone
const rangeExceptions = await adapter.getInstanceExceptionsInRange(
  '2024-01-01' as LocalDate,
  '2024-01-31' as LocalDate
)
expect(rangeExceptions.find(e => e.id === 'exc-1')).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1045-1079 to examine the exact violation at line 1061

3. **Search for cascade law** - Used Grep tool with pattern `LAW 39|series.*delete.*cascade.*exception|exception.*cascade` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 266: LAW 39 - Series deletion cascades to exceptions

4. **Search for instance_exception schema** - Used Grep tool with pattern `instance_exception` in notes/schema.md, finding:
   - Lines 145-154: CREATE TABLE instance_exception with ON DELETE CASCADE
   - Line 273: Schema design rationale

5. **Search for InstanceExceptionRow interface** - Used Grep tool with pattern `interface InstanceExceptionRow` in notes/adapter-interface.md, finding interface definition at lines 206-213

6. **Search for exception methods** - Used Grep tool with pattern `InstanceException|Exception.*By` in notes/adapter-interface.md, finding:
   - Line 64: createInstanceException
   - Line 65: getInstanceException
   - Line 66: getInstanceExceptionsBySeries
   - Line 67: getInstanceExceptionsInRange
   - Line 68: deleteInstanceException

---

