# REPORT-061-070: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #61-70 as specified in REPORT-SPEC.md.

---

## Violation #61: tests/14-public-api.test.ts:707

**Test Name:** `errors have messages - descriptive string`

**Violation Line:**
```typescript
expect(typeof e.message).toBe('string');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 9: "All errors include descriptive message" (notes/testing-spec-14-public-api.md:210). It ensures that when an error is thrown, it contains a meaningful string message.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Creating a series with empty title throws an error (lines 700-705)
2. The error has a message property of type string (line 707)
3. The message contains the word "title" (line 708)

**Why does this specific test matter?**

Error messages are critical for debugging:
- They tell users/developers what went wrong
- They help diagnose issues quickly
- Without descriptive messages, errors are opaque

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is weak because:
1. It only confirms the type is string
2. An empty string `""` would pass
3. A meaningless string like `"error"` would pass
4. Doesn't verify the message is actually descriptive

Note: The subsequent assertion (line 708) provides stronger verification.

**Why does getting it right matter?**

For medically fragile people:
- Care errors need clear explanations
- Caregivers need to understand what went wrong
- Opaque errors could delay fixes

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 9** - notes/testing-spec-14-public-api.md:210 states "LAW 9: All errors include descriptive message"

2. **Test Plan Reference** - notes/test-plan-14.md:114 states "errors have messages | any error | Descriptive string | LAW 9"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('errors have messages - descriptive string', async () => {
  const planner = createAutoplanner(createValidConfig());

  try {
    await planner.createSeries({
      title: '',
      patterns: [{ type: 'daily', time: time('09:00') }],
    });
    expect.fail('Should have thrown');
  } catch (e: any) {
    // Error should be an instance of a known error type
    expect(e).toBeInstanceOf(ValidationError);

    // Message should exist and be non-empty
    expect(e.message).toBeDefined();
    expect(typeof e.message).toBe('string');
    expect(e.message.length).toBeGreaterThan(0);

    // Message should be descriptive (contains relevant context)
    expect(e.message).toContain('title');
    expect(e.message.toLowerCase()).toMatch(/empty|required|invalid/);
  }
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(e).toBeInstanceOf(ValidationError)` - Known error type
2. `expect(e.message).toBeDefined()` - Message exists
3. `expect(e.message.length).toBeGreaterThan(0)` - Non-empty
4. `expect(e.message).toContain('title')` - Relevant context
5. `expect(e.message.toLowerCase()).toMatch(/empty|required|invalid/)` - Describes the issue

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the error type
- Verifies message is non-empty
- Verifies message contains specific relevant content
- Cannot pass with empty or generic messages

**What specific changes would transform this test into its ideal form?**

Replace line 707:
```typescript
expect(typeof e.message).toBe('string');
```

With:
```typescript
expect(e.message).toBeDefined();
expect(typeof e.message).toBe('string');
expect(e.message.length).toBeGreaterThan(0);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/14-public-api.test.ts lines 690-739 to examine the exact violation at line 707 and full test context

3. **Search for error message spec** - Used Grep tool with pattern `error.*message|descriptive string|LAW.*error` in notes/testing-spec-14-public-api.md, finding:
   - Line 210: "LAW 9: All errors include descriptive message"

4. **Search for error message test plan** - Used Grep tool with pattern `error.*message|descriptive|LAW 9` in notes/test-plan-14.md, finding:
   - Line 114: "errors have messages | any error | Descriptive string | LAW 9"

---

## Violation #62: tests/14-public-api.test.ts:1289

**Test Name:** `unlinkSeries removes link - link removed`

**Violation Line:**
```typescript
expect(child).not.toHaveProperty('parentId');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `unlinkSeries` properly removes the parent-child relationship. After unlinking, the child series should no longer have a `parentId` property.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A parent series is created (lines 1268-1270)
2. A child series is created (lines 1271-1274)
3. They are linked (line 1275)
4. The link exists initially (lines 1277-1279)
5. unlinkSeries is called (line 1281)
6. The child still exists (lines 1283-1288)
7. The child no longer has a parentId property (line 1289)

**Why does this specific test matter?**

Unlinking series is a core operation:
- Decouples previously linked care chains
- Allows independent scheduling after unlinking
- Must remove the relationship completely

**What are the consequences if this test is wrong or weak?**

The `not.toHaveProperty('parentId')` assertion is weak because:
1. It only verifies the property doesn't exist
2. Doesn't verify the property was set to null vs removed
3. Could pass if the child was deleted entirely
4. Doesn't verify the child is otherwise intact

Note: The preceding assertion (lines 1285-1288) provides some verification of the child's state.

**Why does getting it right matter?**

For medically fragile people:
- Unlinked series must be truly independent
- Residual parent references could cause scheduling issues
- The link must be fully removed

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **API Definition** - notes/testing-spec-14-public-api.md:69 defines `unlinkSeries(childId: SeriesId): void`

2. **Operation Category** - notes/testing-spec-14-public-api.md:172 lists "linkSeries / unlinkSeries" as key operations

3. **Test Plan Reference** - notes/test-plan-14.md:205 states "unlinkSeries removes link | unlink | Link removed"

4. **Trigger Behavior** - notes/test-plan-14.md:75 states "unlinkSeries triggers | unlinkSeries | Yes | LAW 5"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('unlinkSeries removes link - link removed', async () => {
  const planner = createAutoplanner(createValidConfig());

  const parentId = await planner.createSeries({
    title: 'Parent',
    patterns: [{ type: 'daily', time: time('09:00') }],
  });
  const childId = await planner.createSeries({
    title: 'Child',
    patterns: [{ type: 'daily', time: time('10:00') }],
  });
  await planner.linkSeries(parentId, childId, { distance: 0 });

  // Verify link exists before unlinking
  const childBefore = await planner.getSeries(childId);
  expect(childBefore).toBeDefined();
  expect(childBefore?.parentId).toBe(parentId);

  await planner.unlinkSeries(childId);

  const child = await planner.getSeries(childId);

  // Child should still exist
  expect(child).toBeDefined();
  expect(child).not.toBeNull();
  expect(child?.id).toBe(childId);
  expect(child?.title).toBe('Child');

  // ParentId should be removed or null
  expect(child).not.toHaveProperty('parentId');
  // Or if it can be null:
  // expect(child?.parentId).toBeUndefined();

  // Parent should still exist and be unaffected
  const parent = await planner.getSeries(parentId);
  expect(parent).toBeDefined();
  expect(parent?.title).toBe('Parent');
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(childBefore?.parentId).toBe(parentId)` - Link exists before
2. `expect(child).toBeDefined()` - Child still exists
3. `expect(child?.id).toBe(childId)` - Same child
4. `expect(child).not.toHaveProperty('parentId')` - Link removed
5. `expect(parent).toBeDefined()` - Parent unaffected

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies link exists before unlinking
- Verifies child still exists after unlinking
- Verifies parent is unaffected
- Verifies the specific property is removed
- Cannot pass if child is deleted

**What specific changes would transform this test into its ideal form?**

Add after line 1283:
```typescript
// Child should still exist
expect(child).toBeDefined();
expect(child).not.toBeNull();
```

Add after line 1289:
```typescript
// Parent should be unaffected
const parent = await planner.getSeries(parentId);
expect(parent).toBeDefined();
expect(parent?.title).toBe('Parent');
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/14-public-api.test.ts lines 1270-1319 to examine the exact violation at line 1289 and full test context

3. **Search for unlinkSeries spec** - Used Grep tool with pattern `unlinkSeries|removes link|parentId.*null|LAW.*unlink` in notes/testing-spec-14-public-api.md, finding:
   - Line 69: "unlinkSeries(childId: SeriesId): void"
   - Line 172: "linkSeries / unlinkSeries"

4. **Search for unlinkSeries test plan** - Used Grep tool with pattern `unlinkSeries|removes link|link removed` in notes/test-plan-14.md, finding:
   - Line 75: "unlinkSeries triggers | unlinkSeries | Yes | LAW 5"
   - Line 205: "unlinkSeries removes link | unlink | Link removed"

---

## Violation #63: tests/14-public-api.test.ts:1431

**Test Name:** `deleteCompletion removes - completion gone`

**Violation Line:**
```typescript
expect(completions).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `deleteCompletion` properly removes a completion record. After deletion, the list of completions for the series should be empty.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created (lines 1422-1425)
2. A completion is logged (line 1427)
3. The completion is deleted (line 1428)
4. Getting completions returns an empty array (lines 1430-1431)

**Why does this specific test matter?**

Completion tracking is critical:
- Completions affect cycling and scheduling
- Deleting completions allows corrections
- Stale completions could cause incorrect behavior

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify a completion existed before deletion
3. Could pass if getCompletions is broken
4. Could pass if logCompletion failed silently

**Why does getting it right matter?**

For medically fragile people:
- Completion records track care history
- Incorrect deletion could lose care records
- Or failing to delete could cause false positives

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **API Definition** - notes/testing-spec-14-public-api.md:98 defines `deleteCompletion(id: CompletionId): void`

2. **Test Plan Reference** - notes/test-plan-14.md:228 states "deleteCompletion removes | delete | Completion gone"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('deleteCompletion removes - completion gone', async () => {
  const planner = createAutoplanner(createValidConfig());

  const id = await planner.createSeries({
    title: 'Test',
    patterns: [{ type: 'daily', time: time('09:00') }],
  });

  const completionId = await planner.logCompletion(id, date('2025-01-15'));

  // Verify completion exists before deletion
  const completionsBefore = await planner.getCompletions(id);
  expect(completionsBefore).toHaveLength(1);
  expect(completionsBefore[0].id).toBe(completionId);
  expect(completionsBefore[0].date).toEqual(date('2025-01-15'));

  await planner.deleteCompletion(completionId);

  // Verify completion is gone after deletion
  const completionsAfter = await planner.getCompletions(id);
  expect(completionsAfter).toHaveLength(0);
  expect(completionsAfter).toEqual([]);

  // Verify series still exists
  const series = await planner.getSeries(id);
  expect(series).toBeDefined();
  expect(series?.title).toBe('Test');
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(completionsBefore).toHaveLength(1)` - Completion exists before
2. `expect(completionsBefore[0].id).toBe(completionId)` - Correct completion
3. `expect(completionsAfter).toHaveLength(0)` - Deleted
4. `expect(completionsAfter).toEqual([])` - Empty array
5. `expect(series).toBeDefined()` - Series unaffected

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies completion exists before deletion
- Verifies completion has correct data
- Verifies deletion removes it
- Verifies series is unaffected
- Cannot pass if logCompletion fails

**What specific changes would transform this test into its ideal form?**

Add after line 1427:
```typescript
// Verify completion exists before deletion
const completionsBefore = await planner.getCompletions(id);
expect(completionsBefore).toHaveLength(1);
expect(completionsBefore[0].id).toBe(completionId);
```

Replace line 1431:
```typescript
expect(completions).toEqual([]);
```

With:
```typescript
expect(completions).toHaveLength(0);
expect(completions).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/14-public-api.test.ts lines 1410-1459 to examine the exact violation at line 1431 and full test context

3. **Search for deleteCompletion spec** - Used Grep tool with pattern `deleteCompletion|completion.*gone|removes.*completion` in notes/testing-spec-14-public-api.md, finding:
   - Line 98: "deleteCompletion(id: CompletionId): void"

4. **Search for deleteCompletion test plan** - Used Grep tool with pattern `deleteCompletion|completion.*gone|removes.*completion` in notes/test-plan-14.md, finding:
   - Line 228: "deleteCompletion removes | delete | Completion gone"

---

## Violation #64: tests/14-public-api.test.ts:1707

**Test Name:** `conditional pattern activation - condition changes pattern activates schedule updates`

**Violation Line:**
```typescript
expect(weekendInstances).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that conditional patterns (weekday-only) work correctly. When the condition is false (weekend), no instances should be generated for that pattern.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created with weekday-only condition (lines 1687-1696)
2. On a weekday (Wednesday), instances appear (lines 1698-1702)
3. On a weekend (Saturday), instances do NOT appear (lines 1704-1707)

**Why does this specific test matter?**

Conditional patterns are essential:
- Many care tasks are day-specific
- "Take on weekdays" must not generate weekend instances
- Incorrect conditions could cause missed or extra care

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify weekend dates are actually weekend
3. Could pass if getSchedule is broken
4. Doesn't verify weekday instances ARE generated

Note: The preceding assertions (lines 1700-1702) verify weekday instances exist.

**Why does getting it right matter?**

For medically fragile people:
- Care schedules must respect conditions
- Weekend medications must not be taken on weekdays (and vice versa)
- Wrong conditions could be dangerous

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-14.md:272 states "conditional pattern activation | condition changes→pattern activates | Schedule updates"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('conditional pattern activation - condition changes pattern activates schedule updates', async () => {
  const planner = createAutoplanner(createValidConfig());

  const id = await planner.createSeries({
    title: 'Weekday Only',
    patterns: [
      {
        type: 'daily',
        time: time('09:00'),
        condition: { type: 'weekday', days: [1, 2, 3, 4, 5] },
      },
    ],
  });

  // Verify series was created
  const series = await planner.getSeries(id);
  expect(series).toBeDefined();
  expect(series?.patterns[0].condition).toEqual({ type: 'weekday', days: [1, 2, 3, 4, 5] });

  // Wednesday (weekday = day 3) - should appear
  const weekdaySchedule = await planner.getSchedule(date('2025-01-15'), date('2025-01-16'));
  const weekdayInstances = weekdaySchedule.instances.filter((i) => i.seriesId === id);
  expect(weekdayInstances).toHaveLength(1);
  expect(weekdayInstances[0].seriesId).toBe(id);
  expect(weekdayInstances[0].title).toBe('Weekday Only');
  expect(weekdayInstances[0].date).toEqual(date('2025-01-15'));

  // Saturday (weekend = day 6) - should NOT appear
  const weekendSchedule = await planner.getSchedule(date('2025-01-18'), date('2025-01-19'));
  const weekendInstances = weekendSchedule.instances.filter((i) => i.seriesId === id);
  expect(weekendInstances).toHaveLength(0);
  expect(weekendInstances).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(series?.patterns[0].condition).toEqual(...)` - Condition set correctly
2. `expect(weekdayInstances).toHaveLength(1)` - Weekday has instance
3. `expect(weekdayInstances[0].date).toEqual(date('2025-01-15'))` - Correct date
4. `expect(weekendInstances).toHaveLength(0)` - Weekend has no instances
5. `expect(weekendInstances).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies condition is set correctly
- Verifies weekday instances exist with correct data
- Verifies weekend instances don't exist
- Uses both length and equality checks
- Cannot pass if condition is ignored

**What specific changes would transform this test into its ideal form?**

Add before line 1698:
```typescript
// Verify series was created with correct condition
const series = await planner.getSeries(id);
expect(series?.patterns[0].condition).toEqual({ type: 'weekday', days: [1, 2, 3, 4, 5] });
```

Replace lines 1700-1702:
```typescript
expect(weekdaySchedule.instances.some((i) => i.seriesId === id)).toBe(true);
```

With:
```typescript
const weekdayInstances = weekdaySchedule.instances.filter((i) => i.seriesId === id);
expect(weekdayInstances).toHaveLength(1);
expect(weekdayInstances[0].date).toEqual(date('2025-01-15'));
```

Replace line 1707:
```typescript
expect(weekendInstances).toEqual([]);
```

With:
```typescript
expect(weekendInstances).toHaveLength(0);
expect(weekendInstances).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/14-public-api.test.ts lines 1685-1734 to examine the exact violation at line 1707 and full test context

3. **Search for conditional pattern spec** - Used Grep tool with pattern `conditional pattern|pattern.*activ|condition.*pattern|schedule.*update` in notes/testing-spec-14-public-api.md - no matches found

4. **Search for conditional pattern test plan** - Used Grep tool with pattern `conditional|weekday|pattern.*activ` in notes/test-plan-14.md, finding:
   - Line 272: "conditional pattern activation | condition changes→pattern activates | Schedule updates"

---

## Violation #65: tests/15-sqlite-adapter.test.ts:328

**Test Name:** `CASCADE deletes dependents - delete parent removes children`

**Violation Line:**
```typescript
expect(patternsAfter).toHaveLength(0); // Cascade delete removes patterns
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 7: "CASCADE deletes dependent rows" (notes/testing-spec-15-sqlite-adapter.md:76). When a series is deleted, its dependent patterns should be automatically deleted via CASCADE.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created (lines 305-309)
2. A pattern is created referencing the series (lines 310-315)
3. Pattern exists before deletion (lines 317-322)
4. Series is deleted (line 325)
5. Patterns are automatically deleted via CASCADE (line 328)

**Why does this specific test matter?**

CASCADE delete is essential:
- Prevents orphaned records
- Maintains referential integrity
- Ensures data consistency

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. Doesn't verify the pattern existed before deletion
3. Could pass if pattern save failed
4. Could pass if getPatternsBySeries is broken

Note: The preceding assertions (lines 317-322) verify the pattern existed.

**Why does getting it right matter?**

For medically fragile people:
- Orphaned patterns could cause scheduling errors
- CASCADE ensures clean deletion
- Data integrity is critical

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 7** - notes/testing-spec-15-sqlite-adapter.md:76 states "LAW 7: CASCADE deletes dependent rows"

2. **Test Plan Reference** - notes/test-plan-15.md:57 states "CASCADE deletes dependents | delete parent | Dependents gone | LAW 7"

3. **Cascade Order** - notes/testing-spec-15-sqlite-adapter.md:211 states "LAW 20: Cascade respects foreign key order"

4. **CASCADE Dependents** - notes/testing-spec-15-sqlite-adapter.md:308 states "CASCADE deletes dependents"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('CASCADE deletes dependents - delete parent removes children', async () => {
  // Create series
  await adapter.saveSeries({
    id: seriesId('test-1'),
    title: 'Test Series',
  });

  // Create dependent pattern
  await adapter.savePattern({
    id: patternId('p1'),
    seriesId: seriesId('test-1'),
    type: 'daily',
    time: time('09:00'),
  });

  // Verify pattern exists before deletion
  const patternsBefore = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patternsBefore).toHaveLength(1);
  expect(patternsBefore[0].id).toBe(patternId('p1'));
  expect(patternsBefore[0].seriesId).toBe(seriesId('test-1'));

  // Verify series exists
  const seriesBefore = await adapter.getSeries(seriesId('test-1'));
  expect(seriesBefore).toBeDefined();

  // Delete series - patterns should cascade
  await adapter.deleteSeries(seriesId('test-1'));

  // Verify pattern is gone (CASCADE delete)
  const patternsAfter = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patternsAfter).toHaveLength(0);
  expect(patternsAfter).toEqual([]);

  // Verify series is gone
  const seriesAfter = await adapter.getSeries(seriesId('test-1'));
  expect(seriesAfter).toBeUndefined();
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(patternsBefore).toHaveLength(1)` - Pattern exists before
2. `expect(patternsBefore[0].id).toBe(patternId('p1'))` - Correct pattern
3. `expect(seriesBefore).toBeDefined()` - Series exists before
4. `expect(patternsAfter).toHaveLength(0)` - Pattern gone after CASCADE
5. `expect(patternsAfter).toEqual([])` - Empty array
6. `expect(seriesAfter).toBeUndefined()` - Series deleted

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies pattern exists before deletion
- Verifies series exists before deletion
- Verifies both are gone after deletion
- Uses both length and equality checks
- Cannot pass if pattern save failed

**What specific changes would transform this test into its ideal form?**

Replace line 328:
```typescript
expect(patternsAfter).toHaveLength(0);
```

With:
```typescript
expect(patternsAfter).toHaveLength(0);
expect(patternsAfter).toEqual([]);
```

Add after line 328:
```typescript
// Verify series is also gone
const seriesAfter = await adapter.getSeries(seriesId('test-1'));
expect(seriesAfter).toBeUndefined();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 310-359 to examine the exact violation at line 328 and full test context

3. **Search for CASCADE spec** - Used Grep tool with pattern `CASCADE|delete.*dependent|parent.*child|FK|foreign key` in notes/testing-spec-15-sqlite-adapter.md, finding:
   - Line 29: "All foreign key constraints active"
   - Line 76: "LAW 7: CASCADE deletes dependent rows"
   - Line 211: "LAW 20: Cascade respects foreign key order"
   - Line 308: "CASCADE deletes dependents"

4. **Search for CASCADE test plan** - Used Grep tool with pattern `CASCADE.*delete|delete.*dependent|cascade.*test|LAW 7` in notes/test-plan-15.md, finding:
   - Line 57: "CASCADE deletes dependents | delete parent | Dependents gone | LAW 7"
   - Line 227: "cascade behavior matches | cascade tests | Same behavior as mock"

---

## Violation #66: tests/15-sqlite-adapter.test.ts:942

**Test Name:** `respects FK order - complex cascade correct order`

**Violation Line:**
```typescript
expect(conditions).toHaveLength(0); // Cascade deleted
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 20: "Cascade respects foreign key order" (notes/testing-spec-15-sqlite-adapter.md:211). When deleting a series with complex FK relationships (series→condition→pattern), the cascade must delete in the correct order.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created (line 920)
2. A condition is created referencing the series (lines 921-926)
3. A pattern is created referencing both series and condition (lines 927-933)
4. Series deletion works despite complex FK relationships (line 936)
5. Conditions are cascade deleted (line 942)
6. Patterns are cascade deleted (line 944)

**Why does this specific test matter?**

Complex FK graphs require correct deletion order:
- SQLite must delete children before parents
- Wrong order causes FK violations
- This tests multi-level cascade

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. Doesn't verify conditions existed before
3. Could pass if condition save failed
4. Doesn't verify cascade order was correct

**Why does getting it right matter?**

For medically fragile people:
- Complex care schedules have multiple entity types
- Cascade deletion must work correctly
- Failed cascades could leave orphaned data

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 20** - notes/testing-spec-15-sqlite-adapter.md:211 states "LAW 20: Cascade respects foreign key order"

2. **Test Plan Reference** - notes/test-plan-15.md:160 states "respects FK order | complex cascade | Correct order | LAW 20"

3. **Complex Entity Graphs** - notes/test-plan-15.md:272 states "Test cascade order with complex entity graphs"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('respects FK order - complex cascade correct order', async () => {
  const series = createTestSeries('test-1');
  await adapter.saveSeries(series);
  await adapter.saveCondition({
    id: conditionId('cond1'),
    seriesId: seriesId('test-1'),
    type: 'weekday',
    days: [1],
  });
  await adapter.savePattern({
    id: patternId('p1'),
    seriesId: seriesId('test-1'),
    type: 'daily',
    time: time('09:00'),
    conditionId: conditionId('cond1'),
  });

  // Verify all entities exist before deletion
  const seriesBefore = await adapter.getSeries(seriesId('test-1'));
  expect(seriesBefore).toBeDefined();
  const conditionsBefore = await adapter.getConditionsBySeries(seriesId('test-1'));
  expect(conditionsBefore).toHaveLength(1);
  expect(conditionsBefore[0].id).toBe(conditionId('cond1'));
  const patternsBefore = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patternsBefore).toHaveLength(1);
  expect(patternsBefore[0].id).toBe(patternId('p1'));

  // Delete should work despite complex FK relationships
  await adapter.deleteSeries(seriesId('test-1'));

  // Verify all related entities are deleted
  const allSeries = await adapter.getAllSeries();
  expect(allSeries.map(s => s.id)).not.toContain(seriesId('test-1'));

  const conditions = await adapter.getConditionsBySeries(seriesId('test-1'));
  expect(conditions).toHaveLength(0);
  expect(conditions).toEqual([]);

  const patterns = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patterns).toHaveLength(0);
  expect(patterns).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(conditionsBefore).toHaveLength(1)` - Condition exists before
2. `expect(patternsBefore).toHaveLength(1)` - Pattern exists before
3. `expect(conditions).toHaveLength(0)` - Condition gone after
4. `expect(conditions).toEqual([])` - Empty array
5. `expect(patterns).toHaveLength(0)` - Pattern gone after

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies all entities exist before deletion
- Verifies all are gone after deletion
- Uses both length and equality checks
- Cannot pass if saves failed

**What specific changes would transform this test into its ideal form?**

Add before line 935:
```typescript
// Verify entities exist before deletion
const conditionsBefore = await adapter.getConditionsBySeries(seriesId('test-1'));
expect(conditionsBefore).toHaveLength(1);
const patternsBefore = await adapter.getPatternsBySeries(seriesId('test-1'));
expect(patternsBefore).toHaveLength(1);
```

Replace line 942:
```typescript
expect(conditions).toHaveLength(0);
```

With:
```typescript
expect(conditions).toHaveLength(0);
expect(conditions).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 920-979 to examine the exact violation at line 942 and full test context

3. **Search for FK order spec** - Used Grep tool with pattern `FK order|cascade order|LAW 20|foreign key order` in notes/testing-spec-15-sqlite-adapter.md, finding:
   - Line 211: "LAW 20: Cascade respects foreign key order"

4. **Search for FK order test plan** - Used Grep tool with pattern `FK order|cascade.*order|LAW 20|respects.*order` in notes/test-plan-15.md, finding:
   - Line 160: "respects FK order | complex cascade | Correct order | LAW 20"
   - Line 272: "Test cascade order with complex entity graphs"

---

## Violation #67: tests/15-sqlite-adapter.test.ts:944

**Test Name:** `respects FK order - complex cascade correct order`

**Violation Line:**
```typescript
expect(patterns).toHaveLength(0); // Cascade deleted
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test (same as #66) verifies LAW 20: "Cascade respects foreign key order" (notes/testing-spec-15-sqlite-adapter.md:211). This specific assertion verifies that patterns are cascade deleted when the parent series is deleted.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A pattern is created with references to both series and condition (lines 927-933)
2. After series deletion, patterns are cascade deleted (line 944)

**Why does this specific test matter?**

Patterns depend on both series and conditions:
- They must be deleted after conditions
- Cascade must handle multi-column FK
- This ensures complete cleanup

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. Doesn't verify patterns existed before
3. Could pass if pattern save failed
4. Doesn't verify the specific pattern was deleted

**Why does getting it right matter?**

For medically fragile people:
- Orphaned patterns could cause scheduling issues
- Complete cascade is essential
- Data integrity matters

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 20** - notes/testing-spec-15-sqlite-adapter.md:211 states "LAW 20: Cascade respects foreign key order"

2. **Test Plan Reference** - notes/test-plan-15.md:160 states "respects FK order | complex cascade | Correct order | LAW 20"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

(Same as violation #66 - see above for complete ideal test)

**What assertions would perfectly verify the intended behavior?**

1. `expect(patternsBefore).toHaveLength(1)` - Pattern exists before
2. `expect(patternsBefore[0].id).toBe(patternId('p1'))` - Correct pattern
3. `expect(patterns).toHaveLength(0)` - Pattern gone after
4. `expect(patterns).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies pattern exists before deletion
- Verifies pattern is gone after deletion
- Uses both length and equality checks
- Cannot pass if save failed

**What specific changes would transform this test into its ideal form?**

Replace line 944:
```typescript
expect(patterns).toHaveLength(0);
```

With:
```typescript
expect(patterns).toHaveLength(0);
expect(patterns).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 920-979 to examine the exact violation at line 944 and full test context

3. **Search for FK order spec** - Used Grep tool with pattern `FK order|cascade order|LAW 20|foreign key order` in notes/testing-spec-15-sqlite-adapter.md, finding:
   - Line 211: "LAW 20: Cascade respects foreign key order"

4. **Search for FK order test plan** - Used Grep tool with pattern `FK order|cascade.*order|LAW 20|respects.*order` in notes/test-plan-15.md, finding:
   - Line 160: "respects FK order | complex cascade | Correct order | LAW 20"

---

## Violation #68: tests/15-sqlite-adapter.test.ts:1033

**Test Name:** `original error in cause - SQLite error in cause`

**Violation Line:**
```typescript
expect(e.cause.message).toBeDefined();
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 23: "Original error preserved in cause" (notes/testing-spec-15-sqlite-adapter.md:232). When a SQLite error is mapped to a domain error, the original SQLite error should be preserved in the `cause` property.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created (lines 1024-1025)
2. Saving the same series again causes a constraint violation (line 1028)
3. The thrown error has a `cause` property (line 1032)
4. The cause has a `message` property (line 1033)

**Why does this specific test matter?**

Error cause preservation is critical for debugging:
- Allows tracing to the original SQLite error
- Provides context for troubleshooting
- Helps understand what went wrong at the database level

**What are the consequences if this test is wrong or weak?**

The `toBeDefined()` assertion is weak because:
1. It only verifies the message is defined
2. Doesn't verify the message is meaningful
3. An empty string would pass
4. Doesn't verify the message contains SQLite context

**Why does getting it right matter?**

For medically fragile people:
- Errors must be diagnosable
- Care system failures need root cause analysis
- Clear error chains help fix issues quickly

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 23** - notes/testing-spec-15-sqlite-adapter.md:232 states "LAW 23: Original error preserved in cause"

2. **Error Mapping** - notes/testing-spec-15-sqlite-adapter.md:231 states "LAW 22: All SQLite errors mapped to domain errors"

3. **Test Plan Reference** - notes/test-plan-15.md:180 states "original error in cause | mapped error | SQLite error in cause | LAW 23"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('original error in cause - SQLite error in cause', async () => {
  const series = createTestSeries('test-1');
  await adapter.saveSeries(series);

  try {
    await adapter.saveSeries(series);
    expect.fail('Should have thrown');
  } catch (e: any) {
    // Verify error is a domain error
    expect(e).toBeInstanceOf(ConstraintError);

    // Verify error has a cause (original SQLite error)
    expect(e.cause).toBeDefined();
    expect(e.cause).not.toBeNull();
    expect(e.cause).toBeInstanceOf(Error);

    // Verify cause message is meaningful
    expect(e.cause.message).toBeDefined();
    expect(typeof e.cause.message).toBe('string');
    expect(e.cause.message.length).toBeGreaterThan(0);

    // Verify cause contains SQLite constraint context
    expect(e.cause.message.toLowerCase()).toMatch(/constraint|unique|primary/);
  }
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(e).toBeInstanceOf(ConstraintError)` - Domain error type
2. `expect(e.cause).toBeDefined()` - Cause exists
3. `expect(e.cause).toBeInstanceOf(Error)` - Cause is Error
4. `expect(e.cause.message.length).toBeGreaterThan(0)` - Non-empty message
5. `expect(e.cause.message.toLowerCase()).toMatch(...)` - Contains SQLite context

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the domain error type
- Verifies cause is a real Error object
- Verifies cause message is non-empty
- Verifies cause contains SQLite context
- Cannot pass with empty or meaningless cause

**What specific changes would transform this test into its ideal form?**

Replace lines 1032-1033:
```typescript
expect(e.cause).toBeDefined();
expect(e.cause.message).toBeDefined();
```

With:
```typescript
expect(e.cause).toBeDefined();
expect(e.cause).not.toBeNull();
expect(e.cause.message).toBeDefined();
expect(e.cause.message.length).toBeGreaterThan(0);
expect(e.cause.message.toLowerCase()).toMatch(/constraint|unique/);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 1015-1064 to examine the exact violation at line 1033 and full test context

3. **Search for original error spec** - Used Grep tool with pattern `original error|error cause|SQLite error|LAW.*cause` in notes/testing-spec-15-sqlite-adapter.md, finding:
   - Line 231: "LAW 22: All SQLite errors mapped to domain errors"
   - Line 232: "LAW 23: Original error preserved in cause"

4. **Search for original error test plan** - Used Grep tool with pattern `original error|error.*cause|LAW 23|cause.*preserved` in notes/test-plan-15.md, finding:
   - Line 180: "original error in cause | mapped error | SQLite error in cause | LAW 23"

---

## Violation #69: tests/15-sqlite-adapter.test.ts:1297

**Test Name:** `cascade behavior matches - same behavior as mock`

**Violation Line:**
```typescript
expect(patterns).toHaveLength(0); // Cascade deleted
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that the SQLite adapter's cascade delete behavior matches the mock adapter. It ensures implementation parity between the two adapters.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series is created (lines 1285-1286)
2. A pattern is created referencing the series (lines 1287-1292)
3. Series is deleted (line 1294)
4. Patterns are cascade deleted (line 1297)
5. Series is also deleted (lines 1299-1300)

**Why does this specific test matter?**

Adapter parity is essential:
- Mock and SQLite adapters must behave identically
- Tests using mock must be valid for SQLite
- Inconsistent behavior could cause production bugs

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. Doesn't verify pattern existed before deletion
3. Could pass if pattern save failed
4. Doesn't verify the exact pattern was deleted

**Why does getting it right matter?**

For medically fragile people:
- Production uses SQLite, tests use mock
- Behavioral parity ensures tests are meaningful
- Cascade must work correctly in production

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-15.md:227 states "cascade behavior matches | cascade tests | Same behavior as mock"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('cascade behavior matches - same behavior as mock', async () => {
  const series = createTestSeries('test-1');
  await adapter.saveSeries(series);
  await adapter.savePattern({
    id: patternId('p1'),
    seriesId: seriesId('test-1'),
    type: 'daily',
    time: time('09:00'),
  });

  // Verify pattern exists before deletion
  const patternsBefore = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patternsBefore).toHaveLength(1);
  expect(patternsBefore[0].id).toBe(patternId('p1'));

  await adapter.deleteSeries(seriesId('test-1'));

  // Verify pattern is cascade deleted
  const patterns = await adapter.getPatternsBySeries(seriesId('test-1'));
  expect(patterns).toHaveLength(0);
  expect(patterns).toEqual([]);

  // Verify series is also deleted
  const allSeries = await adapter.getAllSeries();
  expect(allSeries.every(s => s.id !== seriesId('test-1'))).toBe(true);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(patternsBefore).toHaveLength(1)` - Pattern exists before
2. `expect(patternsBefore[0].id).toBe(patternId('p1'))` - Correct pattern
3. `expect(patterns).toHaveLength(0)` - Pattern gone after
4. `expect(patterns).toEqual([])` - Empty array
5. `expect(allSeries.every(...)).toBe(true)` - Series gone

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies pattern exists before deletion
- Verifies pattern is gone after deletion
- Uses both length and equality checks
- Verifies series is gone
- Cannot pass if save failed

**What specific changes would transform this test into its ideal form?**

Add after line 1292:
```typescript
// Verify pattern exists before deletion
const patternsBefore = await adapter.getPatternsBySeries(seriesId('test-1'));
expect(patternsBefore).toHaveLength(1);
expect(patternsBefore[0].id).toBe(patternId('p1'));
```

Replace line 1297:
```typescript
expect(patterns).toHaveLength(0);
```

With:
```typescript
expect(patterns).toHaveLength(0);
expect(patterns).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/15-sqlite-adapter.test.ts lines 1275-1324 to examine the exact violation at line 1297 and full test context

3. **Search for cascade behavior test plan** - Used Grep tool with pattern `cascade behavior|same behavior|mock.*behavior|behavior.*match` in notes/test-plan-15.md, finding:
   - Line 227: "cascade behavior matches | cascade tests | Same behavior as mock"

---

## Violation #70: tests/16-integration.test.ts:161

**Test Name:** `initial state - walks every other day, no weights`

**Violation Line:**
```typescript
expect(weightInstances).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This integration test verifies the initial state of a progressive exercise scenario. Before any walks are completed, only walk instances should appear (every other day) and weight training should NOT appear (condition not met).

**What functionality or behavior is it verifying?**

The test verifies that:
1. A 14-day schedule is retrieved (line 144)
2. Walk instances appear every other day - 7 instances (lines 147, 152-155)
3. Each walk is at 07:00 with 30-minute duration (lines 156-159)
4. Weight training instances do NOT appear (lines 148, 161)
5. Condition for weights (7 completed walks) is not met yet

**Why does this specific test matter?**

Conditional patterns are essential:
- Weights should only appear after 7 walks
- Initial state must be correct before testing transitions
- This validates the condition evaluation system

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the result is empty
2. Doesn't verify the weight series exists
3. Doesn't verify the condition is actually blocking
4. Could pass if weight series wasn't created

Note: The preceding assertions verify walk instances comprehensively.

**Why does getting it right matter?**

For medically fragile people:
- Progressive exercise programs require correct staging
- Weights too early could cause injury
- Conditions must block until prerequisites are met

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test Plan Reference** - notes/test-plan-16.md:27 states "1 | Initial state | Walks every other day, no weights | -"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('initial state - walks every other day, no weights', async () => {
  // Verify weight series exists but is condition-blocked
  const weightSeries = await planner.getSeries(weightSeriesId);
  expect(weightSeries).toBeDefined();
  expect(weightSeries?.patterns[0].condition).toBeDefined();

  const schedule = await planner.getSchedule(date('2025-01-01'), date('2025-01-14'));

  // Walk instances - every other day
  const walkInstances = schedule.instances.filter((i) => i.seriesId === walkSeriesId);
  expect(walkInstances).toHaveLength(7);
  expect(walkInstances.map((i) => i.date)).toEqual([
    date('2025-01-01'), date('2025-01-03'), date('2025-01-05'), date('2025-01-07'),
    date('2025-01-09'), date('2025-01-11'), date('2025-01-13'),
  ]);
  walkInstances.forEach((instance) => {
    expect(instance.time).toContain('07:00');
    expect(instance.duration).toBe(minutes(30));
  });

  // Weight instances - none (condition not met)
  const weightInstances = schedule.instances.filter((i) => i.seriesId === weightSeriesId);
  expect(weightInstances).toHaveLength(0);
  expect(weightInstances).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(weightSeries).toBeDefined()` - Series exists
2. `expect(weightSeries?.patterns[0].condition).toBeDefined()` - Has condition
3. `expect(walkInstances).toHaveLength(7)` - Correct walk count
4. `expect(walkInstances.map(...)).toEqual([...])` - Correct dates
5. `expect(weightInstances).toHaveLength(0)` - No weights
6. `expect(weightInstances).toEqual([])` - Empty array

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies weight series exists but is blocked
- Verifies walk instances are generated correctly
- Verifies weight instances are empty
- Uses both length and equality checks
- Cannot pass if series doesn't exist

**What specific changes would transform this test into its ideal form?**

Add before line 144:
```typescript
// Verify weight series exists but is condition-blocked
const weightSeries = await planner.getSeries(weightSeriesId);
expect(weightSeries).toBeDefined();
expect(weightSeries?.patterns[0].condition).toBeDefined();
```

Replace line 161:
```typescript
expect(weightInstances).toEqual([]);
```

With:
```typescript
expect(weightInstances).toHaveLength(0);
expect(weightInstances).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/16-integration.test.ts lines 140-189 to examine the exact violation at line 161 and full test context

3. **Search for initial state test plan** - Used Grep tool with pattern `initial state|every other day|no weights|condition.*start` in notes/test-plan-16.md, finding:
   - Line 27: "1 | Initial state | Walks every other day, no weights | -"

---

