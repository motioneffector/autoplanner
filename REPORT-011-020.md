# REPORT-011-020: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #11-20 as specified in REPORT-SPEC.md.

---

## Violation #11: tests/04-adapter.test.ts:1318

**Test Name:** `create tag returns ID`

**Violation Line:**
```typescript
expect(id.length).toBeGreaterThanOrEqual(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `createTag` returns a valid ID when creating a new tag. It's testing the basic contract of the tag creation operation as defined in notes/testing-spec-04-adapter.md:311 and notes/adapter-interface.md:85.

**What functionality or behavior is it verifying?**

The test verifies that:
1. `createTag('work')` returns an ID
2. The ID matches a pattern of alphanumeric characters and hyphens (line 1317)
3. The ID has a length >= 1 (line 1318 - the weak assertion)
4. The tag was actually created with correct properties (lines 1320-1324)

**Why does this specific test matter?**

Tag IDs are used throughout the system to reference tags in relationships (series_tag table, constraint targets, etc.). If `createTag` returns invalid or empty IDs, downstream operations would fail or create invalid relationships.

**What are the consequences if this test is wrong or weak?**

The `toBeGreaterThanOrEqual(1)` assertion is extremely weak. It would pass for:
- A single character ID like "a" (might not be a valid UUID)
- An ID that's technically valid but doesn't match expected format
- Any non-empty string

**Why does getting it right matter?**

For medically fragile people, tag management affects how care schedules are organized and queried. Invalid tag IDs could:
- Cause failures when associating tags with series
- Break constraint references that use tags as targets
- Lead to orphan or corrupted tag associations

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Adapter Interface - createTag** - notes/adapter-interface.md:85 defines `createTag(name: string): string  // returns id, or existing id if name exists`

2. **LAW 47** - notes/testing-spec-04-adapter.md:323 states "LAW 47: createTag returns existing ID if name already exists"

3. **LAW 48** - notes/testing-spec-04-adapter.md:324 states "LAW 48: addTagToSeries creates tag if it doesn't exist"

4. **TagRow Interface** - notes/adapter-interface.md:225-228 defines:
   ```typescript
   interface TagRow {
     id: string
     name: string
   }
   ```

5. **Database Schema - tag** - notes/schema.md:180-183 defines:
   ```sql
   CREATE TABLE tag (
     id TEXT PRIMARY KEY,
     name TEXT NOT NULL UNIQUE
   );
   ```

6. **SeriesTagRow Interface** - notes/adapter-interface.md:230-233 defines:
   ```typescript
   interface SeriesTagRow {
     series_id: string
     tag_id: string
   }
   ```

7. **LAW 10** - notes/testing-spec-04-adapter.md:99 states "LAW 10: s ∈ getSeriesByTag(t) ↔ t ∈ getTagsForSeries(s.id)" - shows how tags are used bidirectionally

8. **Constraint Target Reference** - notes/testing-spec-04-adapter.md:382 states "LAW 59: Constraints reference targets by tag or seriesId (soft reference)" - tags are referenced in constraints

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the ID format more specifically:

```typescript
it('create tag returns ID', async () => {
  const id = await adapter.createTag('work')

  // Verify ID format - should be a valid UUID or similar identifier
  expect(id).toMatch(/^[a-zA-Z0-9-]+$/)
  expect(id.length).toBeGreaterThanOrEqual(8)  // UUIDs are typically 36 chars, but at minimum 8

  // Verify the tag was actually created with correct properties
  const tag = await adapter.getTagByName('work')
  expect(tag).toEqual({
    id: id,
    name: 'work',
  })

  // Verify via getAllTags as well
  const allTags = await adapter.getAllTags()
  expect(allTags.find(t => t.id === id)).toEqual({
    id: id,
    name: 'work',
  })
})
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(id).toMatch(/^[a-zA-Z0-9-]+$/)` - Verify format (already present)
2. `expect(id.length).toBeGreaterThanOrEqual(8)` - Verify minimum length for a proper ID
3. `expect(tag).toEqual({id: id, name: 'work'})` - Verify exact object match (strengthen objectContaining)
4. `expect(allTags.find(t => t.id === id))` - Cross-verify via getAllTags

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Uses a realistic minimum length (8+ characters for proper IDs)
- Verifies exact object equality, not just partial matching
- Cross-verifies using multiple query methods
- Cannot pass with trivially short IDs

**What specific changes would transform this test into its ideal form?**

Replace line 1318:
```typescript
expect(id.length).toBeGreaterThanOrEqual(1)
```

With:
```typescript
expect(id.length).toBeGreaterThanOrEqual(8)  // Reasonable minimum for ID formats
```

And strengthen lines 1321-1324:
```typescript
expect(tag).toEqual({
  id: id,
  name: 'work',
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1300-1349 to examine the exact violation at line 1318

3. **Search for tag operations specification** - Used Grep tool with pattern `createTag|Tag Operations|LAW.*tag` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 99: LAW 10 - bidirectional tag-series relationship
   - Lines 308-328: Tag Operations section with LAW 47-51
   - Line 382: LAW 59 - constraint tag references

4. **Search for tag interface definition** - Used Grep tool with pattern `createTag|TagRow|Tag ===` in notes/adapter-interface.md, finding:
   - Lines 84-92: Tag operations interface
   - Lines 225-228: TagRow interface
   - Lines 230-233: SeriesTagRow interface

5. **Search for tag schema** - Used Grep tool with pattern `CREATE TABLE tag|tag.*PRIMARY KEY` (case insensitive) in notes/schema.md, finding:
   - Lines 180-183: CREATE TABLE tag definition
   - Lines 185-188: series_tag junction table

6. **Check for existing report file** - Used Glob tool with pattern `REPORT-011-020.md` - not found, so created new file

---

## Violation #12: tests/04-adapter.test.ts:1379

**Test Name:** `series delete cascades tag associations`

**Violation Line:**
```typescript
expect(seriesWithTag).toHaveLength(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 50 from the adapter specification: "Series deletion cascades to tag associations" (notes/testing-spec-04-adapter.md:326). When a series is deleted, the tag associations (in the series_tag junction table) should be automatically removed, but the tag itself should remain.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A tag can be added to a series
2. When the series is deleted, the tag-series association is removed
3. The tag itself continues to exist (not deleted)
4. `getSeriesByTag` returns no series for that tag after deletion

**Why does this specific test matter?**

The series_tag junction table manages the many-to-many relationship between series and tags. If associations survive series deletion:
- `getSeriesByTag` would return references to non-existent series
- Orphan associations accumulate in the database
- Database integrity is compromised

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because it only verifies the array is empty. It could pass when:
- `getSeriesByTag` is broken and always returns `[]`
- The tag was never added to the series successfully
- A different bug caused the association to be removed before `deleteSeries`

**Why does getting it right matter?**

For medically fragile people, tag management affects how care schedules are organized and queried. Orphan associations could:
- Cause queries to return references to deleted series
- Lead to crashes when attempting to access non-existent series
- Eventually corrupt the database over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 50** - notes/testing-spec-04-adapter.md:326 states "LAW 50: Series deletion cascades to tag associations"

2. **LAW 10** - notes/testing-spec-04-adapter.md:99 states "LAW 10: s ∈ getSeriesByTag(t) ↔ t ∈ getTagsForSeries(s.id)" - bidirectional relationship

3. **Database Schema - series_tag** - notes/schema.md:185-190 defines:
   ```sql
   CREATE TABLE series_tag (
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     tag_id TEXT NOT NULL REFERENCES tag(id) ON DELETE CASCADE,
     PRIMARY KEY (series_id, tag_id)
   );
   ```

4. **Schema Design Rationale** - notes/schema.md:275 states "series_tag | CASCADE | Tag association meaningless without series"

5. **Adapter Interface - getSeriesByTag** - notes/testing-spec-04-adapter.md:91 defines `getSeriesByTag(tagName: string): SeriesRow[]`

6. **Adapter Interface - getAllSeriesTags** - notes/adapter-interface.md:92 defines `getAllSeriesTags(): SeriesTagRow[]  // for bulk loading`

7. **SeriesTagRow Interface** - notes/adapter-interface.md:230-233 defines:
   ```typescript
   interface SeriesTagRow {
     series_id: string
     tag_id: string
   }
   ```

8. **LAW 49** - notes/testing-spec-04-adapter.md:325 states "LAW 49: Tag-series association is unique (no duplicates)"

9. **Property Test Reference** - notes/fuzz-testing-task-list.md:182 lists "Property: deleteSeries cascades to series_tag"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively:

```typescript
it('series delete cascades tag associations', async () => {
  await adapter.addTagToSeries('series-1', 'work')

  // Verify association exists before deletion
  const seriesBeforeDeletion = await adapter.getSeriesByTag('work')
  expect(seriesBeforeDeletion).toHaveLength(1)
  expect(seriesBeforeDeletion[0].id).toBe('series-1')

  // Also verify via getAllSeriesTags
  const allAssociationsBefore = await adapter.getAllSeriesTags()
  expect(allAssociationsBefore.some(st => st.series_id === 'series-1')).toBe(true)

  await adapter.deleteSeries('series-1')

  // Verify tag still exists
  const tag = await adapter.getTagByName('work')
  expect(tag).toEqual({
    id: expect.any(String),
    name: 'work',
  })

  // Verify association was removed via getSeriesByTag
  const seriesWithTag = await adapter.getSeriesByTag('work')
  expect(seriesWithTag).toHaveLength(0)

  // Verify via getAllSeriesTags - no association for deleted series
  const allAssociationsAfter = await adapter.getAllSeriesTags()
  expect(allAssociationsAfter.some(st => st.series_id === 'series-1')).toBe(false)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(seriesBeforeDeletion).toHaveLength(1)` - Verify association count
2. Pre-deletion: `expect(seriesBeforeDeletion[0].id).toBe('series-1')` - Verify correct series
3. Pre-deletion: getAllSeriesTags verification - Confirm via different API
4. Post-deletion: `expect(tag).toEqual({...})` - Verify tag still exists (already present, strengthen)
5. Post-deletion: `expect(seriesWithTag).toHaveLength(0)` - getSeriesByTag empty (already present)
6. Post-deletion: getAllSeriesTags verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies association exists with correct series ID before deletion
- Confirms association exists via both query methods
- Verifies tag survives but association doesn't
- Cross-verifies via getAllSeriesTags
- Cannot pass if association was never created

**What specific changes would transform this test into its ideal form?**

Add before line 1371:
```typescript
// Verify association exists before deletion
const seriesBeforeDeletion = await adapter.getSeriesByTag('work')
expect(seriesBeforeDeletion).toHaveLength(1)
expect(seriesBeforeDeletion[0].id).toBe('series-1')
```

Add after line 1379:
```typescript
// Also verify via getAllSeriesTags
const allAssociations = await adapter.getAllSeriesTags()
expect(allAssociations.some(st => st.series_id === 'series-1')).toBe(false)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1360-1410 to examine the exact violation at line 1379

3. **Search for tag cascade laws and getSeriesByTag** - Used Grep tool with pattern `getSeriesByTag|LAW.*tag.*association|series.*delete.*cascade.*tag` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 91: getSeriesByTag signature
   - Line 99: LAW 10 - bidirectional relationship
   - Lines 323-327: LAW 47-51 including LAW 50 about cascade

4. **Search for series_tag schema and interface** - Used Grep tool with pattern `series_tag|SeriesTagRow` across notes directory, finding:
   - notes/schema.md:185-190: CREATE TABLE series_tag with ON DELETE CASCADE
   - notes/schema.md:275: Schema design rationale
   - notes/adapter-interface.md:92: getAllSeriesTags method
   - notes/adapter-interface.md:230-233: SeriesTagRow interface
   - notes/fuzz-testing-task-list.md:182: Property test reference

---

## Violation #13: tests/04-adapter.test.ts:1490

**Test Name:** `series delete cascades reminders`

**Violation Line:**
```typescript
expect(remindersBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 53 from the adapter specification: "Series deletion cascades to reminders" (notes/testing-spec-04-adapter.md:346). When a series is deleted, all reminders associated with that series should be automatically removed from the database.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder can be created and associated with a series
2. The reminder exists before series deletion
3. When `deleteSeries('series-1')` is called, the reminder is automatically deleted via cascade
4. `getRemindersBySeries` returns an empty array after deletion

**Why does this specific test matter?**

Reminders notify caregivers about upcoming scheduled tasks. If reminders survive their parent series being deleted:
- Orphan reminders could trigger for non-existent schedules
- Caregiver notification systems would reference deleted series
- Database integrity would be compromised

**What are the consequences if this test is wrong or weak?**

The `length` check only verifies that 1 reminder exists, not what reminder it is. The assertion could pass when:
- A different reminder is returned (wrong id, label, minutesBefore)
- A reminder from a different series is returned
- The `getRemindersBySeries` function returns arbitrary data
- The reminder has corrupted properties

**Why does getting it right matter?**

For medically fragile people, orphan reminders could:
- Generate phantom notifications for deleted schedules
- Cause confusion for caregivers about which tasks need attention
- Lead to database corruption over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 53** - notes/testing-spec-04-adapter.md:346 states "LAW 53: Series deletion cascades to reminders"

2. **LAW 52** - notes/testing-spec-04-adapter.md:345 states "LAW 52: Multiple reminders per series allowed"

3. **Adapter Interface - getRemindersBySeries** - notes/adapter-interface.md:97 defines `getRemindersBySeries(seriesId: string): ReminderRow[]`

4. **Adapter Interface - getAllReminders** - notes/adapter-interface.md:98 defines `getAllReminders(): ReminderRow[]`

5. **ReminderRow Interface** - notes/adapter-interface.md:235-240 defines:
   ```typescript
   interface ReminderRow {
     id: string
     series_id: string
     minutes_before: number
     tag: string
   }
   ```

6. **Database Schema - reminder** - notes/schema.md:197-205 defines:
   ```sql
   CREATE TABLE reminder (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     minutes_before INTEGER NOT NULL,
     tag TEXT NOT NULL
   );
   CREATE INDEX idx_reminder_series ON reminder(series_id);
   ```

7. **Schema Design Rationale** - notes/schema.md:276 states "reminder | CASCADE | Reminders meaningless without series"

8. **LAW 56** - notes/testing-spec-04-adapter.md:364 states "LAW 56: Reminder deletion cascades to acknowledgments" - shows multi-level cascade

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the reminder's actual properties before deletion:

```typescript
it('series delete cascades reminders', async () => {
  await adapter.createReminder({
    id: 'rem-1',
    seriesId: 'series-1',
    minutesBefore: 15,
    label: 'Test',
  })

  // Verify reminder exists with correct properties before deletion
  const remindersBefore = await adapter.getRemindersBySeries('series-1')
  expect(remindersBefore).toHaveLength(1)
  expect(remindersBefore[0]).toMatchObject({
    id: 'rem-1',
    seriesId: 'series-1',
    minutesBefore: 15,
    label: 'Test',
  })

  // Also verify via getAllReminders
  const allRemindersBefore = await adapter.getAllReminders()
  expect(allRemindersBefore.find(r => r.id === 'rem-1')).toBeDefined()

  await adapter.deleteSeries('series-1')

  // Verify cascade via series-specific query
  const reminders = await adapter.getRemindersBySeries('series-1')
  expect(reminders).toEqual([])

  // Verify cascade via global query
  const allRemindersAfter = await adapter.getAllReminders()
  expect(allRemindersAfter.find(r => r.id === 'rem-1')).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(remindersBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(remindersBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: getAllReminders verification - Confirm via different API
4. Post-deletion: `expect(reminders).toEqual([])` - Series-specific empty (already present)
5. Post-deletion: getAllReminders verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific reminder properties before deletion
- Confirms reminder exists via both series-specific and global queries
- Verifies cascade via both query methods
- Cannot pass if `getRemindersBySeries` always returns []
- Cannot pass if reminder was never created

**What specific changes would transform this test into its ideal form?**

Replace line 1490:
```typescript
expect(remindersBefore.length).toBe(1)
```

With:
```typescript
expect(remindersBefore).toHaveLength(1)
expect(remindersBefore[0]).toMatchObject({
  id: 'rem-1',
  seriesId: 'series-1',
  minutesBefore: 15,
  label: 'Test',
})
```

Add after line 1493:
```typescript
// Also verify via global query
const allReminders = await adapter.getAllReminders()
expect(allReminders.find(r => r.id === 'rem-1')).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1470-1520 to examine the exact violation at line 1490

3. **Search for reminder operations specification** - Used Grep tool with pattern `Reminder Operations|LAW.*reminder|getRemindersBySeries|series.*delete.*cascade.*reminder` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Lines 332-347: Reminder Operations section
   - Lines 335-340: Method signatures
   - Lines 345-346: LAW 52 and LAW 53
   - Line 364: LAW 56 about cascading to acknowledgments

4. **Search for ReminderRow interface and schema** - Used Grep tool with pattern `ReminderRow|CREATE TABLE reminder` across notes directory, finding:
   - notes/adapter-interface.md:95-100: Reminder method signatures
   - notes/adapter-interface.md:235-240: ReminderRow interface
   - notes/schema.md:197-205: CREATE TABLE reminder with ON DELETE CASCADE

---

## Violation #14: tests/04-adapter.test.ts:1493

**Test Name:** `series delete cascades reminders`

**Violation Line:**
```typescript
expect(reminders).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion is the core verification of LAW 53: "Series deletion cascades to reminders" (notes/testing-spec-04-adapter.md:346). It verifies that after a series is deleted, all reminders that were associated with that series have been automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `deleteSeries('series-1')` is called
2. The reminder 'rem-1' that was associated with 'series-1' no longer exists
3. `getRemindersBySeries('series-1')` returns an empty array

**Why does this specific test matter?**

This test validates database cascade behavior defined at the schema level (notes/schema.md:199): `series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE`. If this cascade fails, orphan reminders would remain in the database, potentially triggering for non-existent schedules.

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getRemindersBySeries` is broken and always returns `[]`
- The reminder was never created successfully
- A different bug deleted the reminder before `deleteSeries`
- The cascade failed but the query returns empty for another reason

**Why does getting it right matter?**

For medically fragile people, orphan reminders could:
- Generate phantom notifications for deleted schedules
- Cause confusion for caregivers about which tasks need attention
- Lead to database corruption over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 53** - notes/testing-spec-04-adapter.md:346 states "LAW 53: Series deletion cascades to reminders"

2. **Database Schema - reminder** - notes/schema.md:197-205 defines:
   ```sql
   CREATE TABLE reminder (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     minutes_before INTEGER NOT NULL,
     tag TEXT NOT NULL
   );
   CREATE INDEX idx_reminder_series ON reminder(series_id);
   ```

3. **Schema Design Rationale** - notes/schema.md:276 states "reminder | CASCADE | Reminders meaningless without series"

4. **Adapter Interface - getRemindersBySeries** - notes/adapter-interface.md:97 defines `getRemindersBySeries(seriesId: string): ReminderRow[]`

5. **Adapter Interface - getAllReminders** - notes/adapter-interface.md:98 defines `getAllReminders(): ReminderRow[]` - could be used for cross-verification

6. **ReminderRow Interface** - notes/adapter-interface.md:235-240 defines:
   ```typescript
   interface ReminderRow {
     id: string
     series_id: string
     minutes_before: number
     tag: string
   }
   ```

7. **Reminder Usage in getPendingReminders** - notes/testing-spec-10-reminders.md:68 shows `getAllReminders()` is used to compute pending reminders

8. **Multi-level Cascade** - notes/schema.md:213 shows `reminder_acknowledgment` also has ON DELETE CASCADE from reminder, creating a chain: Series → Reminder → ReminderAcknowledgment

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using both series-specific and global queries:

```typescript
it('series delete cascades reminders', async () => {
  await adapter.createReminder({
    id: 'rem-1',
    seriesId: 'series-1',
    minutesBefore: 15,
    label: 'Test',
  })

  // Verify reminder exists with correct properties before deletion
  const remindersBefore = await adapter.getRemindersBySeries('series-1')
  expect(remindersBefore).toHaveLength(1)
  expect(remindersBefore[0]).toMatchObject({
    id: 'rem-1',
    seriesId: 'series-1',
    minutesBefore: 15,
    label: 'Test',
  })

  // Verify via getAllReminders
  const allRemindersBefore = await adapter.getAllReminders()
  expect(allRemindersBefore.find(r => r.id === 'rem-1')).toBeDefined()

  await adapter.deleteSeries('series-1')

  // Verify cascade via series-specific query
  const reminders = await adapter.getRemindersBySeries('series-1')
  expect(reminders).toEqual([])

  // Verify cascade via global query
  const allRemindersAfter = await adapter.getAllReminders()
  expect(allRemindersAfter.find(r => r.id === 'rem-1')).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(remindersBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(remindersBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: getAllReminders verification - Confirm via different API
4. Post-deletion: `expect(reminders).toEqual([])` - Series-specific empty (already present)
5. Post-deletion: getAllReminders verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific reminder properties before deletion
- Confirms reminder exists via both series-specific and global queries
- Verifies cascade via both query methods
- Cannot pass if `getRemindersBySeries` always returns []
- Cannot pass if reminder was never created

**What specific changes would transform this test into its ideal form?**

Add after line 1493:
```typescript
// Also verify via global query
const allReminders = await adapter.getAllReminders()
expect(allReminders.find(r => r.id === 'rem-1')).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1480-1515 to examine the exact violation at line 1493

3. **Search for cascade law** - Used Grep tool with pattern `LAW 53|series.*cascade.*reminder|getRemindersBySeries` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 337: getRemindersBySeries signature
   - Lines 345-346: LAW 52 and LAW 53

4. **Search for reminder schema and interface** - Used Grep tool with pattern `CREATE TABLE reminder|ReminderRow|getAllReminders` across notes directory, finding:
   - notes/adapter-interface.md:95-100: Reminder method signatures
   - notes/adapter-interface.md:235-240: ReminderRow interface
   - notes/schema.md:197-205: CREATE TABLE reminder with ON DELETE CASCADE
   - notes/schema.md:212-220: reminder_acknowledgment table showing multi-level cascade
   - notes/testing-spec-10-reminders.md:68: getAllReminders usage

---

## Violation #15: tests/04-adapter.test.ts:1538

**Test Name:** `reminder delete cascades acks`

**Violation Line:**
```typescript
expect(acksBefore.length).toBe(1)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 56 from the adapter specification: "Reminder deletion cascades to acknowledgments" (notes/testing-spec-04-adapter.md:364). When a reminder is deleted, all acknowledgments associated with that reminder should be automatically removed from the database.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder can be acknowledged
2. The acknowledgment exists before reminder deletion
3. When `deleteReminder('rem-1')` is called, the acknowledgment is automatically deleted via cascade
4. `getReminderAcksInRange` returns an empty array after deletion

**Why does this specific test matter?**

Reminder acknowledgments track which notifications have been seen by caregivers. If acknowledgments survive their parent reminder being deleted:
- Orphan acknowledgments accumulate in the database
- Queries might return acknowledgments for non-existent reminders
- Database integrity would be compromised

**What are the consequences if this test is wrong or weak?**

The `length` check only verifies that 1 acknowledgment exists, not what acknowledgment it is. The assertion could pass when:
- A different acknowledgment is returned (wrong reminderId, instanceDate)
- An acknowledgment from a different reminder is returned
- The `getReminderAcksInRange` function returns arbitrary data
- The acknowledgment has corrupted properties

**Why does getting it right matter?**

For medically fragile people, orphan acknowledgments could:
- Corrupt queries about notification history
- Lead to database integrity issues over time
- Cause confusion about which notifications have been seen

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 56** - notes/testing-spec-04-adapter.md:364 states "LAW 56: Reminder deletion cascades to acknowledgments"

2. **LAW 54** - notes/testing-spec-04-adapter.md:362 states "LAW 54: After acknowledge, isReminderAcknowledged returns true"

3. **LAW 55** - notes/testing-spec-04-adapter.md:363 states "LAW 55: Re-acknowledging is idempotent"

4. **Adapter Interface - getAcknowledgedRemindersInRange** - notes/adapter-interface.md:105 defines `getAcknowledgedRemindersInRange(startDate: string, endDate: string): ReminderAcknowledgmentRow[]`

5. **ReminderAcknowledgmentRow Interface** - notes/adapter-interface.md:242-246 defines:
   ```typescript
   interface ReminderAcknowledgmentRow {
     reminder_id: string
     instance_date: string
     acknowledged_at: string
   }
   ```

6. **Database Schema - reminder_acknowledgment** - notes/schema.md:212-221 defines:
   ```sql
   CREATE TABLE reminder_acknowledgment (
     reminder_id TEXT NOT NULL REFERENCES reminder(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     acknowledged_at TEXT NOT NULL,
     PRIMARY KEY (reminder_id, instance_date)
   );
   CREATE INDEX idx_reminder_ack_time ON reminder_acknowledgment(acknowledged_at);
   ```

7. **Schema Design Rationale** - notes/schema.md:277 states "reminder_acknowledgment | CASCADE | Acks meaningless without reminder"

8. **Mock Adapter State** - notes/testing-spec-04-adapter.md:432 shows `reminderAcks: Map<string, ReminderAcknowledgmentRow>  // key = reminderId:instanceDate`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the acknowledgment's actual properties before deletion:

```typescript
it('reminder delete cascades acks', async () => {
  await adapter.acknowledgeReminder('rem-1', '2024-01-15' as LocalDate, '2024-01-15T09:45:00' as LocalDateTime)

  // Verify ack exists with correct properties before deletion
  const acksBefore = await adapter.getReminderAcksInRange('2024-01-01' as LocalDate, '2024-01-31' as LocalDate)
  expect(acksBefore).toHaveLength(1)
  expect(acksBefore[0]).toMatchObject({
    reminderId: 'rem-1',
    instanceDate: '2024-01-15',
  })

  // Also verify via isReminderAcknowledged
  const wasAcked = await adapter.isReminderAcknowledged('rem-1', '2024-01-15' as LocalDate)
  expect(wasAcked).toBe(true)

  await adapter.deleteReminder('rem-1')

  // Verify cascade via range query
  const acks = await adapter.getReminderAcksInRange('2024-01-01' as LocalDate, '2024-01-31' as LocalDate)
  expect(acks).toEqual([])

  // Note: isReminderAcknowledged would also return false, but reminder doesn't exist
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(acksBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(acksBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: isReminderAcknowledged verification - Confirm via different API
4. Post-deletion: `expect(acks).toEqual([])` - Range query empty (already present)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific acknowledgment properties before deletion
- Confirms acknowledgment exists via both range query and isReminderAcknowledged
- Cannot pass if `getReminderAcksInRange` always returns []
- Cannot pass if acknowledgment was never created

**What specific changes would transform this test into its ideal form?**

Replace line 1538:
```typescript
expect(acksBefore.length).toBe(1)
```

With:
```typescript
expect(acksBefore).toHaveLength(1)
expect(acksBefore[0]).toMatchObject({
  reminderId: 'rem-1',
  instanceDate: '2024-01-15',
})
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1520-1570 to examine the exact violation at line 1538

3. **Search for acknowledgment laws and interface** - Used Grep tool with pattern `Reminder Acknowledgment|LAW.*acknowledgment|LAW 56|getReminderAcksInRange|reminder.*delete.*cascade.*ack` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Lines 351-366: Reminder Acknowledgment Operations section
   - Lines 354-357: Method signatures
   - Lines 362-365: LAW 54-57

4. **Search for ReminderAcknowledgmentRow interface and schema** - Used Grep tool with pattern `ReminderAcknowledgmentRow|CREATE TABLE reminder_acknowledgment` across notes directory, finding:
   - notes/adapter-interface.md:105: getAcknowledgedRemindersInRange method
   - notes/adapter-interface.md:242-246: ReminderAcknowledgmentRow interface
   - notes/schema.md:212-221: CREATE TABLE reminder_acknowledgment with ON DELETE CASCADE
   - notes/testing-spec-04-adapter.md:432: Mock adapter state definition

---

## Violation #16: tests/04-adapter.test.ts:1541

**Test Name:** `reminder delete cascades acks`

**Violation Line:**
```typescript
expect(acks).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This assertion is the core verification of LAW 56: "Reminder deletion cascades to acknowledgments" (notes/testing-spec-04-adapter.md:364). It verifies that after a reminder is deleted, all acknowledgments that were associated with that reminder have been automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The assertion verifies that:
1. After `deleteReminder('rem-1')` is called
2. The acknowledgment that was associated with 'rem-1' no longer exists
3. `getReminderAcksInRange` returns an empty array

**Why does this specific test matter?**

This test validates database cascade behavior defined at the schema level (notes/schema.md:213): `reminder_id TEXT NOT NULL REFERENCES reminder(id) ON DELETE CASCADE`. If this cascade fails, orphan acknowledgments would remain in the database.

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies the result is an empty array. It could pass when:
- `getReminderAcksInRange` is broken and always returns `[]`
- The acknowledgment was never created successfully
- A different bug deleted the acknowledgment before `deleteReminder`
- The cascade failed but the query returns empty for another reason

**Why does getting it right matter?**

For medically fragile people, orphan acknowledgments could:
- Corrupt queries about notification history
- Lead to database integrity issues over time
- Cause unpredictable behavior in the notification system

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 56** - notes/testing-spec-04-adapter.md:364 states "LAW 56: Reminder deletion cascades to acknowledgments"

2. **Database Schema - reminder_acknowledgment** - notes/schema.md:212-221 defines:
   ```sql
   CREATE TABLE reminder_acknowledgment (
     reminder_id TEXT NOT NULL REFERENCES reminder(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     acknowledged_at TEXT NOT NULL,
     PRIMARY KEY (reminder_id, instance_date)
   );
   CREATE INDEX idx_reminder_ack_time ON reminder_acknowledgment(acknowledged_at);
   ```

3. **Schema Design Rationale** - notes/schema.md:277 states "reminder_acknowledgment | CASCADE | Acks meaningless without reminder"

4. **Adapter Interface - getAcknowledgedRemindersInRange** - notes/testing-spec-04-adapter.md:356 defines `getAcknowledgedRemindersInRange(startDate: string, endDate: string): ReminderAcknowledgmentRow[]`

5. **Adapter Interface - isReminderAcknowledged** - notes/testing-spec-04-adapter.md:355 defines `isReminderAcknowledged(reminderId: string, instanceDate: string): boolean`

6. **LAW 54** - notes/testing-spec-04-adapter.md:362 states "LAW 54: After acknowledge, isReminderAcknowledged returns true"

7. **LAW 57** - notes/testing-spec-04-adapter.md:365 states "LAW 57: purgeOldAcknowledgments removes entries where acknowledged_at < olderThan"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cascade deletion more definitively using multiple query methods:

```typescript
it('reminder delete cascades acks', async () => {
  await adapter.acknowledgeReminder('rem-1', '2024-01-15' as LocalDate, '2024-01-15T09:45:00' as LocalDateTime)

  // Verify ack exists with correct properties before deletion
  const acksBefore = await adapter.getReminderAcksInRange('2024-01-01' as LocalDate, '2024-01-31' as LocalDate)
  expect(acksBefore).toHaveLength(1)
  expect(acksBefore[0]).toMatchObject({
    reminderId: 'rem-1',
    instanceDate: '2024-01-15',
  })

  // Verify via isReminderAcknowledged
  const wasAcked = await adapter.isReminderAcknowledged('rem-1', '2024-01-15' as LocalDate)
  expect(wasAcked).toBe(true)

  await adapter.deleteReminder('rem-1')

  // Verify cascade via range query
  const acks = await adapter.getReminderAcksInRange('2024-01-01' as LocalDate, '2024-01-31' as LocalDate)
  expect(acks).toEqual([])

  // Note: isReminderAcknowledged might throw or return false since reminder doesn't exist
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(acksBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(acksBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: isReminderAcknowledged verification - Confirm via different API
4. Post-deletion: `expect(acks).toEqual([])` - Range query empty (already present)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific acknowledgment properties before deletion
- Confirms acknowledgment exists via both range query and isReminderAcknowledged
- Cannot pass if `getReminderAcksInRange` always returns []
- Cannot pass if acknowledgment was never created

**What specific changes would transform this test into its ideal form?**

The post-deletion assertion is already correct (`toEqual([])`). The improvement needed is in the pre-deletion verification (Violation #15). No changes needed at line 1541.

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 1530-1565 to examine the exact violation at line 1541

3. **Search for cascade law and interface** - Used Grep tool with pattern `LAW 56|reminder.*cascade.*ack|getReminderAcksInRange|getAcknowledgedRemindersInRange` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 356: getAcknowledgedRemindersInRange signature
   - Line 364: LAW 56 - Reminder deletion cascades to acknowledgments

4. **Search for reminder_acknowledgment schema** - Used Grep tool with pattern `reminder_acknowledgment|ReminderAcknowledgmentRow` in notes/schema.md, finding:
   - Lines 212-221: CREATE TABLE reminder_acknowledgment with ON DELETE CASCADE
   - Line 277: Schema design rationale

---

## Violation #17: tests/04-adapter.test.ts:2052

**Test Name:** `INV 7: No orphaned children after operations`

**Violation Line:**
```typescript
expect(weekdays).toHaveLength(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that multi-level cascade deletion works correctly: LAW 20 "Series deletion cascades to patterns" (notes/testing-spec-04-adapter.md:167) combined with LAW 19/23 "Pattern deletion cascades to pattern_weekday entries" (notes/testing-spec-04-adapter.md:166,184). When a series is deleted, patterns are deleted, which cascades to delete weekdays.

**What functionality or behavior is it verifying?**

The test verifies the invariant INV 7 - that no orphaned children exist after operations:
1. A series is created with a pattern that has weekdays
2. The series is deleted
3. Both patterns and weekdays should be automatically cascade deleted
4. `getPatternWeekdays('p1')` returns empty (no orphaned weekdays)

**Why does this specific test matter?**

This test validates the multi-level cascade chain: Series → Pattern → PatternWeekday. If any level of the cascade fails, orphan data would accumulate in the database, eventually causing integrity issues.

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because it only verifies the array is empty. It could pass when:
- `getPatternWeekdays` is broken and always returns `[]`
- The weekdays were never set successfully
- A different bug deleted the weekdays before the series was deleted
- The pattern_id passed doesn't exist (returns empty instead of erroring)

**Why does getting it right matter?**

For medically fragile people, orphan pattern weekdays could:
- Corrupt schedule calculations
- Cause the reflow algorithm to process orphan data
- Lead to database integrity violations over time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 20** - notes/testing-spec-04-adapter.md:167 states "LAW 20: Series deletion cascades to patterns"

2. **LAW 19** - notes/testing-spec-04-adapter.md:166 states "LAW 19: Pattern deletion cascades to pattern_weekday entries"

3. **LAW 23** - notes/testing-spec-04-adapter.md:184 states "LAW 23: Pattern deletion cascades to weekdays"

4. **Adapter Interface - getPatternWeekdays** - notes/adapter-interface.md:36 defines `getPatternWeekdays(patternId: string): Weekday[]`

5. **Adapter Interface - getAllPatternWeekdays** - notes/adapter-interface.md:37 defines `getAllPatternWeekdays(): PatternWeekdayRow[]  // for bulk loading`

6. **PatternWeekdayRow Interface** - notes/adapter-interface.md:162-165 defines:
   ```typescript
   interface PatternWeekdayRow {
     pattern_id: string
     weekday: string
   }
   ```

7. **Database Schema - pattern_weekday** - notes/schema.md:133-138 defines:
   ```sql
   CREATE TABLE pattern_weekday (
     pattern_id TEXT NOT NULL REFERENCES pattern(id) ON DELETE CASCADE,
     weekday TEXT NOT NULL CHECK (weekday IN ('mon','tue','wed','thu','fri','sat','sun')),
     PRIMARY KEY (pattern_id, weekday)
   );
   ```

8. **Schema Design Rationale** - notes/schema.md:272 states "pattern_weekday | CASCADE | Weekdays meaningless without pattern"

9. **LAW 21** - notes/testing-spec-04-adapter.md:182 states "LAW 21: setPatternWeekdays replaces all existing weekdays for pattern"

10. **LAW 22** - notes/testing-spec-04-adapter.md:183 states "LAW 22: getPatternWeekdays returns exactly what was set"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify the multi-level cascade more definitively:

```typescript
it('INV 7: No orphaned children after operations', async () => {
  await adapter.createSeries({
    id: 's1',
    title: 'Test',
    createdAt: '2024-01-15T10:00:00' as LocalDateTime,
  })
  await adapter.createPattern({
    id: 'p1',
    seriesId: 's1',
    type: 'weekdays',
    conditionId: null,
  } as Pattern)
  await adapter.setPatternWeekdays('p1', ['mon', 'wed'])

  // Verify pattern and weekdays exist before deletion
  const patternsBefore = await adapter.getPatternsBySeries('s1')
  expect(patternsBefore).toHaveLength(1)
  expect(patternsBefore[0].id).toBe('p1')

  const weekdaysBefore = await adapter.getPatternWeekdays('p1')
  expect(weekdaysBefore).toEqual(['mon', 'wed'])

  // Also verify via global queries
  const allPatternsBefore = await adapter.getAllPatterns()
  expect(allPatternsBefore.find(p => p.id === 'p1')).toBeDefined()

  const allWeekdaysBefore = await adapter.getAllPatternWeekdays()
  expect(allWeekdaysBefore.filter(w => w.pattern_id === 'p1')).toHaveLength(2)

  await adapter.deleteSeries('s1')

  // Verify cascade: no orphaned patterns
  const allPatterns = await adapter.getPatternsBySeries('s1')
  expect(allPatterns.map(p => p.id)).not.toContain('p1')

  // Verify cascade: no orphaned weekdays
  const weekdays = await adapter.getPatternWeekdays('p1')
  expect(weekdays).toHaveLength(0)

  // Also verify via global queries
  const allPatternsAfter = await adapter.getAllPatterns()
  expect(allPatternsAfter.find(p => p.id === 'p1')).toBeUndefined()

  const allWeekdaysAfter = await adapter.getAllPatternWeekdays()
  expect(allWeekdaysAfter.filter(w => w.pattern_id === 'p1')).toHaveLength(0)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: Verify pattern exists with correct ID
2. Pre-deletion: Verify weekdays are exactly ['mon', 'wed']
3. Pre-deletion: Verify via global queries (getAllPatterns, getAllPatternWeekdays)
4. Post-deletion: Pattern not in series patterns (already present)
5. Post-deletion: `expect(weekdays).toHaveLength(0)` (already present)
6. Post-deletion: Verify via global queries

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific pattern and weekday data before deletion
- Confirms existence via both specific and global queries
- Verifies cascade via multiple query methods
- Cannot pass if weekdays were never created
- Cannot pass if pattern was never created

**What specific changes would transform this test into its ideal form?**

Add before line 2046:
```typescript
// Verify weekdays exist before deletion
const weekdaysBefore = await adapter.getPatternWeekdays('p1')
expect(weekdaysBefore).toEqual(['mon', 'wed'])
```

Add after line 2052:
```typescript
// Also verify via global query
const allWeekdays = await adapter.getAllPatternWeekdays()
expect(allWeekdays.filter(w => w.pattern_id === 'p1')).toHaveLength(0)
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand analysis requirements for this test

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/04-adapter.test.ts lines 2020-2055 to examine the exact violation at line 2052 and get full test context

3. **Search for pattern weekday laws and interface** - Used Grep tool with pattern `PatternWeekday|getPatternWeekdays|LAW.*weekday|pattern.*cascade.*weekday` (case insensitive) in notes/testing-spec-04-adapter.md, finding:
   - Line 166: LAW 19 - Pattern deletion cascades to pattern_weekday
   - Line 167: LAW 20 - Series deletion cascades to patterns
   - Lines 175-177: Pattern weekday method signatures
   - Lines 182-184: LAW 21-23 about weekday operations

4. **Search for pattern_weekday schema** - Used Grep tool with pattern `pattern_weekday|PatternWeekdayRow` in notes/schema.md, finding:
   - Lines 133-138: CREATE TABLE pattern_weekday with ON DELETE CASCADE
   - Line 272: Schema design rationale

5. **Search for adapter interface** - Used Grep tool with pattern `PatternWeekdayRow|getPatternWeekdays|getAllPatternWeekdays` in notes/adapter-interface.md, finding:
   - Lines 36-37: Pattern weekday method signatures
   - Lines 162-165: PatternWeekdayRow interface

---

## Violation #18: tests/05-series-crud.test.ts:1036

**Test Name:** `delete cascades patterns`

**Violation Line:**
```typescript
expect(patterns.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 17 from the adapter specification: "deleteSeries cascades to patterns: getPatternsBySeries(id) = []" (notes/testing-spec-04-adapter.md:145) and POST 12 from the series-crud specification: "All associated data deleted (patterns, conditions, reminders, etc.)" (notes/testing-spec-05-series-crud.md:169). When a series is deleted, all patterns associated with that series should be automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series can be created with a daily pattern
2. When `deleteSeries(adapter, id)` is called, the pattern is automatically deleted via cascade
3. `getPatternsBySeries(id)` returns an empty array after deletion

**Why does this specific test matter?**

Patterns define when scheduled events occur. If patterns survive their parent series being deleted:
- `getPatternsBySeries` would return patterns referencing non-existent series
- Pattern expansion would attempt to generate instances for deleted series
- Database integrity would be compromised with orphan data

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that the cascade actually happened. It could pass when:
- `getPatternsBySeries` is broken and always returns `[]`
- The pattern was never created successfully during `createSeries`
- A different bug deleted the pattern before `deleteSeries`
- The series_id passed doesn't match

**Why does getting it right matter?**

For medically fragile people, orphan patterns could:
- Cause schedule calculation failures
- Lead to phantom instances being generated
- Corrupt the reflow algorithm's state

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 17** - notes/testing-spec-04-adapter.md:145 states "LAW 17: deleteSeries cascades to patterns: getPatternsBySeries(id) = []"

2. **LAW 20** - notes/testing-spec-04-adapter.md:167 states "LAW 20: Series deletion cascades to patterns"

3. **POST 12** - notes/testing-spec-05-series-crud.md:169 states "POST 12: All associated data deleted (patterns, conditions, reminders, etc.)"

4. **Database Schema - pattern** - notes/schema.md:105-107 defines:
   ```sql
   CREATE TABLE pattern (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
   ```

5. **Adapter Interface - getPatternsBySeries** - notes/adapter-interface.md:29 defines `getPatternsBySeries(seriesId: string): PatternRow[]`

6. **Adapter Interface - getAllPatterns** - notes/adapter-interface.md:30 defines `getAllPatterns(): PatternRow[]` - could be used for cross-verification

7. **PatternRow Interface** - notes/adapter-interface.md:150-160 defines:
   ```typescript
   interface PatternRow {
     id: string
     series_id: string
     condition_id: string | null
     is_exception: number  // 0 or 1
     type: string
     n: number | null
     day: number | null
     month: number | null
     weekday: string | null
   }
   ```

8. **LAW 18** - notes/testing-spec-04-adapter.md:165 states "LAW 18: Pattern's series_id must reference existing series" - patterns cannot exist without series

9. **Property Test Reference** - notes/fuzz-testing-task-list.md:176 states "155. Property: deleteSeries cascades to patterns"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify pattern existence before deletion and cascade via multiple query methods:

```typescript
it('delete cascades patterns', async () => {
  const id = await createSeries(adapter, {
    title: 'Test',
    startDate: '2024-01-15' as LocalDate,
    timeOfDay: '09:00' as LocalTime,
    duration: 30,
    patterns: [{ type: 'daily' }],
  })

  // Verify pattern exists with correct properties before deletion
  const patternsBefore = await adapter.getPatternsBySeries(id)
  expect(patternsBefore).toHaveLength(1)
  expect(patternsBefore[0]).toMatchObject({
    series_id: id,
    type: 'daily',
  })

  // Also verify via getAllPatterns
  const allPatternsBefore = await adapter.getAllPatterns()
  expect(allPatternsBefore.find(p => p.series_id === id)).toBeDefined()

  await deleteSeries(adapter, id)

  // Verify cascade via series-specific query
  const patterns = await adapter.getPatternsBySeries(id)
  expect(patterns).toEqual([])

  // Verify cascade via global query
  const allPatternsAfter = await adapter.getAllPatterns()
  expect(allPatternsAfter.find(p => p.series_id === id)).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(patternsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(patternsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: getAllPatterns verification - Confirm via different API
4. Post-deletion: `expect(patterns).toEqual([])` - Series-specific empty
5. Post-deletion: getAllPatterns verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific pattern properties before deletion
- Confirms pattern exists via both series-specific and global queries
- Verifies cascade via both query methods
- Cannot pass if `getPatternsBySeries` always returns []
- Cannot pass if pattern was never created

**What specific changes would transform this test into its ideal form?**

Add before line 1034:
```typescript
// Verify pattern exists before deletion
const patternsBefore = await adapter.getPatternsBySeries(id)
expect(patternsBefore).toHaveLength(1)
expect(patternsBefore[0]).toMatchObject({
  series_id: id,
  type: 'daily',
})
```

Replace line 1036:
```typescript
expect(patterns.length).toBe(0)
```

With:
```typescript
expect(patterns).toEqual([])

// Also verify via global query
const allPatterns = await adapter.getAllPatterns()
expect(allPatterns.find(p => p.series_id === id)).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/05-series-crud.test.ts lines 1020-1080 to examine the exact violation at line 1036 and full test context

3. **Search for cascade laws and specifications** - Used Grep tool with pattern `deleteSeries.*cascade.*pattern|LAW.*pattern|POST.*delete|getPatternsBySeries` (case insensitive) in notes directory, finding:
   - notes/testing-spec-04-adapter.md:145: LAW 17 - deleteSeries cascades to patterns
   - notes/testing-spec-04-adapter.md:155: getPatternsBySeries signature
   - notes/testing-spec-04-adapter.md:167: LAW 20 - Series deletion cascades to patterns
   - notes/testing-spec-05-series-crud.md:169: POST 12 - All associated data deleted
   - notes/fuzz-testing-task-list.md:176: Property test reference

4. **Search for schema definition** - Used Grep tool with pattern `CREATE TABLE pattern|pattern.*REFERENCES.*series|ON DELETE CASCADE` in notes/schema.md, finding:
   - Lines 105-107: CREATE TABLE pattern with ON DELETE CASCADE

5. **Search for adapter interface** - Used Grep tool with pattern `getAllPatterns|PatternRow` in notes/adapter-interface.md, finding:
   - Lines 29-31: Pattern method signatures
   - Lines 150-160: PatternRow interface

6. **Read specification details** - Used Read tool on:
   - notes/testing-spec-04-adapter.md lines 140-174: LAW 14-20 definitions
   - notes/testing-spec-05-series-crud.md lines 160-179: POST 11-12 and LAW 9-11
   - notes/schema.md lines 100-119: CREATE TABLE pattern definition
   - notes/adapter-interface.md lines 145-164: PatternRow interface

---

## Violation #19: tests/05-series-crud.test.ts:1058

**Test Name:** `delete cascades conditions`

**Violation Line:**
```typescript
expect(conditions.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies POST 12 from the series-crud specification: "All associated data deleted (patterns, conditions, reminders, etc.)" (notes/testing-spec-05-series-crud.md:169). When a series is deleted, all conditions associated with that series should be automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series can be created
2. A condition can be added to the series via `adapter.createCondition`
3. When `deleteSeries(adapter, id)` is called, the condition is automatically deleted via cascade
4. `getConditionsBySeries(id)` returns an empty array after deletion

**Why does this specific test matter?**

Conditions determine when patterns are active - they gate pattern activation based on completion counts, days since events, and boolean logic. If conditions survive their parent series being deleted:
- `getConditionsBySeries` would return conditions referencing non-existent series
- Condition evaluation would attempt to process orphan data
- Database integrity would be compromised

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that the cascade actually happened. It could pass when:
- `getConditionsBySeries` is broken and always returns `[]`
- The condition was never created successfully (the `as any` cast is suspicious)
- A different bug deleted the condition before `deleteSeries`
- The series_id passed doesn't match

**Why does getting it right matter?**

For medically fragile people, orphan conditions could:
- Cause condition evaluation failures
- Lead to incorrect pattern activation decisions
- Corrupt the boolean logic tree structure (since conditions reference parent_id)

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **POST 12** - notes/testing-spec-05-series-crud.md:169 states "POST 12: All associated data deleted (patterns, conditions, reminders, etc.)"

2. **Database Schema - condition** - notes/schema.md:82-93 defines:
   ```sql
   CREATE TABLE condition (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     parent_id TEXT REFERENCES condition(id) ON DELETE CASCADE,  -- NULL = root
     type TEXT NOT NULL CHECK (type IN ('count', 'daysSince', 'and', 'or', 'not')),
     ...
   );
   ```

3. **LAW 26** - notes/testing-spec-04-adapter.md:204 states "LAW 26: Condition deletion cascades to children" - cascade chain within conditions

4. **LAW 28** - notes/testing-spec-04-adapter.md:206 states "LAW 28: getConditionsBySeries returns flat list; tree built via parent_id"

5. **Adapter Interface - getConditionsBySeries** - notes/adapter-interface.md:42 defines `getConditionsBySeries(seriesId: string): ConditionRow[]  // flat list, use parent_id to build tree`

6. **Adapter Interface - getAllConditions** - notes/adapter-interface.md:43 defines `getAllConditions(): ConditionRow[]` - could be used for cross-verification

7. **ConditionRow Interface** - notes/adapter-interface.md:167-177 defines:
   ```typescript
   interface ConditionRow {
     id: string
     series_id: string
     parent_id: string | null
     type: string  // 'count' | 'daysSince' | 'and' | 'or' | 'not'
     operator: string | null
     value: number | null
     window_days: number | null
     target_type: string | null  // 'tag' | 'seriesId'
     target_value: string | null
   }
   ```

8. **LAW 24** - notes/testing-spec-04-adapter.md:202 states "LAW 24: Root conditions have parent_id = null"

9. **Property Test Reference** - notes/fuzz-testing-task-list.md:177 states "156. Property: deleteSeries cascades to conditions"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify condition existence before deletion and cascade via multiple query methods:

```typescript
it('delete cascades conditions', async () => {
  const id = await createSeries(adapter, {
    title: 'Test',
    startDate: '2024-01-15' as LocalDate,
    timeOfDay: '09:00' as LocalTime,
    duration: 30,
  })

  // Create condition with full type safety
  await adapter.createCondition({
    id: 'cond-1',
    seriesId: id,
    parentId: null,
    type: 'count',
    operator: '>=',
    value: 5,
    windowDays: 14,
    targetType: null,
    targetValue: null,
  })

  // Verify condition exists with correct properties before deletion
  const conditionsBefore = await adapter.getConditionsBySeries(id)
  expect(conditionsBefore).toHaveLength(1)
  expect(conditionsBefore[0]).toMatchObject({
    id: 'cond-1',
    series_id: id,
    parent_id: null,
    type: 'count',
  })

  // Also verify via getAllConditions
  const allConditionsBefore = await adapter.getAllConditions()
  expect(allConditionsBefore.find(c => c.id === 'cond-1')).toBeDefined()

  await deleteSeries(adapter, id)

  // Verify cascade via series-specific query
  const conditions = await adapter.getConditionsBySeries(id)
  expect(conditions).toEqual([])

  // Verify cascade via global query
  const allConditionsAfter = await adapter.getAllConditions()
  expect(allConditionsAfter.find(c => c.id === 'cond-1')).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(conditionsBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(conditionsBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: getAllConditions verification - Confirm via different API
4. Post-deletion: `expect(conditions).toEqual([])` - Series-specific empty
5. Post-deletion: getAllConditions verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific condition properties before deletion
- Confirms condition exists via both series-specific and global queries
- Verifies cascade via both query methods
- Cannot pass if `getConditionsBySeries` always returns []
- Cannot pass if condition was never created
- Uses proper types instead of `as any` cast

**What specific changes would transform this test into its ideal form?**

Add before line 1056:
```typescript
// Verify condition exists before deletion
const conditionsBefore = await adapter.getConditionsBySeries(id)
expect(conditionsBefore).toHaveLength(1)
expect(conditionsBefore[0]).toMatchObject({
  id: 'cond-1',
  series_id: id,
  type: 'count',
})
```

Replace line 1058:
```typescript
expect(conditions.length).toBe(0)
```

With:
```typescript
expect(conditions).toEqual([])

// Also verify via global query
const allConditions = await adapter.getAllConditions()
expect(allConditions.find(c => c.id === 'cond-1')).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/05-series-crud.test.ts lines 1035-1084 to examine the exact violation at line 1058 and full test context

3. **Search for cascade laws and specifications** - Used Grep tool with pattern `deleteSeries.*cascade.*condition|LAW.*condition|getConditionsBySeries|condition.*ON DELETE CASCADE` (case insensitive) in notes directory, finding:
   - notes/adapter-interface.md:42: getConditionsBySeries signature
   - notes/schema.md:85: parent_id ON DELETE CASCADE
   - notes/fuzz-testing-task-list.md:177: Property test reference
   - notes/testing-spec-04-adapter.md:194: getConditionsBySeries signature
   - notes/testing-spec-04-adapter.md:202-206: LAW 24-28 about conditions

4. **Search for schema definition** - Used Grep tool with pattern `CREATE TABLE condition|condition.*REFERENCES.*series` in notes/schema.md, finding:
   - Line 82: CREATE TABLE condition

5. **Search for adapter interface** - Used Grep tool with pattern `getAllConditions|ConditionRow|getConditionsBySeries` in notes/adapter-interface.md, finding:
   - Lines 40-44: Condition method signatures
   - Line 167: ConditionRow interface

6. **Read specification details** - Used Read tool on:
   - notes/testing-spec-04-adapter.md lines 188-217: Condition Operations section with LAW 24-28
   - notes/schema.md lines 78-97: CREATE TABLE condition definition
   - notes/adapter-interface.md lines 163-187: ConditionRow interface

---

## Violation #20: tests/05-series-crud.test.ts:1071

**Test Name:** `delete cascades reminders`

**Violation Line:**
```typescript
expect(reminders.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 53 from the adapter specification: "Series deletion cascades to reminders" (notes/testing-spec-04-adapter.md:346) and POST 12 from the series-crud specification: "All associated data deleted (patterns, conditions, reminders, etc.)" (notes/testing-spec-05-series-crud.md:169). When a series is deleted, all reminders associated with that series should be automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series can be created with a reminder (`reminders: [{ minutes: 15 }]`)
2. When `deleteSeries(adapter, id)` is called, the reminder is automatically deleted via cascade
3. `getRemindersBySeries(id)` returns an empty array after deletion

**Why does this specific test matter?**

Reminders notify caregivers about upcoming scheduled tasks. If reminders survive their parent series being deleted:
- `getRemindersBySeries` would return reminders for non-existent series
- The pending reminder calculation (`getPendingReminders`) would reference deleted schedules
- Orphan notifications could be generated for schedules that no longer exist

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that the cascade actually happened. It could pass when:
- `getRemindersBySeries` is broken and always returns `[]`
- The reminder was never created successfully during `createSeries`
- A different bug deleted the reminder before `deleteSeries`
- The series_id passed doesn't match

**Why does getting it right matter?**

For medically fragile people, orphan reminders could:
- Generate phantom notifications for deleted schedules
- Cause confusion for caregivers about which tasks need attention
- Lead to database corruption over time with accumulating orphan data

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 53** - notes/testing-spec-04-adapter.md:346 states "LAW 53: Series deletion cascades to reminders"

2. **LAW 3** - notes/testing-spec-10-reminders.md:51 states "LAW 3: Series deletion cascades to reminders"

3. **POST 12** - notes/testing-spec-05-series-crud.md:169 states "POST 12: All associated data deleted (patterns, conditions, reminders, etc.)"

4. **Database Schema - reminder** - notes/schema.md:197-205 defines:
   ```sql
   CREATE TABLE reminder (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     minutes_before INTEGER NOT NULL,
     tag TEXT NOT NULL
   );
   CREATE INDEX idx_reminder_series ON reminder(series_id);
   ```

5. **Adapter Interface - getRemindersBySeries** - notes/adapter-interface.md:97 defines `getRemindersBySeries(seriesId: string): ReminderRow[]`

6. **Adapter Interface - getAllReminders** - notes/adapter-interface.md:98 defines `getAllReminders(): ReminderRow[]` - could be used for cross-verification

7. **ReminderRow Interface** - notes/adapter-interface.md:235-240 defines:
   ```typescript
   interface ReminderRow {
     id: string
     series_id: string
     minutes_before: number
     tag: string
   }
   ```

8. **LAW 52** - notes/testing-spec-04-adapter.md:345 states "LAW 52: Multiple reminders per series allowed"

9. **Property Test Reference** - notes/fuzz-testing-task-list.md:178 states "157. Property: deleteSeries cascades to reminders"

10. **Multi-level Cascade** - notes/schema.md:212-213 shows `reminder_acknowledgment` also has ON DELETE CASCADE from reminder, creating a chain: Series → Reminder → ReminderAcknowledgment

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify reminder existence before deletion and cascade via multiple query methods:

```typescript
it('delete cascades reminders', async () => {
  const id = await createSeries(adapter, {
    title: 'Test',
    startDate: '2024-01-15' as LocalDate,
    timeOfDay: '09:00' as LocalTime,
    duration: 30,
    reminders: [{ minutes: 15 }],
  })

  // Verify reminder exists with correct properties before deletion
  const remindersBefore = await adapter.getRemindersBySeries(id)
  expect(remindersBefore).toHaveLength(1)
  expect(remindersBefore[0]).toMatchObject({
    series_id: id,
    minutes_before: 15,
  })

  // Also verify via getAllReminders
  const allRemindersBefore = await adapter.getAllReminders()
  const createdReminder = allRemindersBefore.find(r => r.series_id === id)
  expect(createdReminder).toBeDefined()
  const reminderId = createdReminder!.id

  await deleteSeries(adapter, id)

  // Verify cascade via series-specific query
  const reminders = await adapter.getRemindersBySeries(id)
  expect(reminders).toEqual([])

  // Verify cascade via global query
  const allRemindersAfter = await adapter.getAllReminders()
  expect(allRemindersAfter.find(r => r.id === reminderId)).toBeUndefined()
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-deletion: `expect(remindersBefore).toHaveLength(1)` - Verify count
2. Pre-deletion: `expect(remindersBefore[0]).toMatchObject({...})` - Verify actual data
3. Pre-deletion: getAllReminders verification - Confirm via different API
4. Post-deletion: `expect(reminders).toEqual([])` - Series-specific empty
5. Post-deletion: getAllReminders verification - Confirm cascade via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific reminder properties before deletion
- Confirms reminder exists via both series-specific and global queries
- Verifies cascade via both query methods
- Cannot pass if `getRemindersBySeries` always returns []
- Cannot pass if reminder was never created

**What specific changes would transform this test into its ideal form?**

Add before line 1069:
```typescript
// Verify reminder exists before deletion
const remindersBefore = await adapter.getRemindersBySeries(id)
expect(remindersBefore).toHaveLength(1)
expect(remindersBefore[0]).toMatchObject({
  series_id: id,
  minutes_before: 15,
})
```

Replace line 1071:
```typescript
expect(reminders.length).toBe(0)
```

With:
```typescript
expect(reminders).toEqual([])

// Also verify via global query
const allReminders = await adapter.getAllReminders()
expect(allReminders.find(r => r.series_id === id)).toBeUndefined()
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/05-series-crud.test.ts lines 1056-1085 to examine the exact violation at line 1071 and full test context

3. **Search for cascade laws and specifications** - Used Grep tool with pattern `deleteSeries.*cascade.*reminder|LAW.*reminder|getRemindersBySeries|POST.*delete` (case insensitive) in notes directory, finding:
   - notes/adapter-interface.md:97: getRemindersBySeries signature
   - notes/testing-spec-04-adapter.md:337: getRemindersBySeries signature
   - notes/testing-spec-04-adapter.md:345-346: LAW 52 and LAW 53
   - notes/testing-spec-10-reminders.md:51: LAW 3 - Series deletion cascades to reminders
   - notes/testing-spec-05-series-crud.md:169: POST 12 - All associated data deleted
   - notes/fuzz-testing-task-list.md:178: Property test reference

4. **Search for schema definition** - Used Grep tool with pattern `CREATE TABLE reminder|reminder.*REFERENCES.*series` in notes/schema.md, finding:
   - Line 197: CREATE TABLE reminder
   - Line 212: CREATE TABLE reminder_acknowledgment (showing multi-level cascade)

5. **Search for adapter interface** - Used Grep tool with pattern `getAllReminders|ReminderRow|getRemindersBySeries` in notes/adapter-interface.md, finding:
   - Lines 95-99: Reminder method signatures
   - Line 235: ReminderRow interface

6. **Read specification details** - Used Read tool on:
   - notes/testing-spec-04-adapter.md lines 330-354: Reminder Operations section with LAW 52-53
   - notes/schema.md lines 193-217: CREATE TABLE reminder and reminder_acknowledgment definitions
   - notes/adapter-interface.md lines 232-246: ReminderRow and ReminderAcknowledgmentRow interfaces

---

