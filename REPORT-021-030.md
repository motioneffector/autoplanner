# REPORT-021-030: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #21-30 as specified in REPORT-SPEC.md.

---

## Violation #21: tests/05-series-crud.test.ts:1367

**Test Name:** `split series starts fresh with no completions`

**Violation Line:**
```typescript
expect(completions.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 19 from the series-crud specification: "New series has no completions initially" (notes/testing-spec-05-series-crud.md:231). When a series is split using `splitSeries`, the new series should start fresh with no completions - the completions remain with the original series.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series with a completion record exists (completion dated 2024-01-05)
2. When `splitSeries` is called with splitDate='2024-01-15'
3. The new series (returned by splitSeries) has no completions
4. Completions from before the split date stay with the original series

**Why does this specific test matter?**

Splitting a series allows users to modify future occurrences without affecting historical records. If completions were copied to the new series:
- Completion counts would be artificially inflated
- Condition evaluations (count-based) would be incorrect
- Historical tracking would be duplicated and corrupted

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that the split correctly partitioned data. It could pass when:
- `getCompletionsBySeries` is broken and always returns `[]`
- The completion was never created successfully
- `splitSeries` failed but returned a valid-looking ID
- The series_id doesn't match expected value

**Why does getting it right matter?**

For medically fragile people, incorrect completion counts could:
- Cause condition-gated patterns to activate/deactivate incorrectly
- Lead to wrong adaptive duration calculations
- Corrupt historical care records used for medical reporting

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 19** - notes/testing-spec-05-series-crud.md:231 states "LAW 19: New series has no completions initially"

2. **LAW 18** - notes/testing-spec-05-series-crud.md:230 states "LAW 18: Original series completions preserved"

3. **Property 189** - notes/fuzz-testing-task-list.md:212 states "189. Property: splitSeries — new series has no completions"

4. **splitSeries Signature** - notes/testing-spec-05-series-crud.md:204 defines `splitSeries(id: SeriesId, splitDate: LocalDate, newParams: Partial<Series>): SeriesId`

5. **POST 14** - notes/testing-spec-05-series-crud.md:220 states "POST 14: New series created with startDate = splitDate"

6. **Database Schema - completion** - notes/schema.md:161-174 defines:
   ```sql
   CREATE TABLE completion (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE RESTRICT,
     instance_date TEXT NOT NULL,
     date TEXT NOT NULL,
     start_time TEXT NOT NULL,
     end_time TEXT NOT NULL,
     created_at TEXT NOT NULL
   );
   ```
   Note: ON DELETE RESTRICT means completions block series deletion, not cascade.

7. **Adapter Interface - getCompletionsBySeries** - notes/adapter-interface.md:73 defines `getCompletionsBySeries(seriesId: string): CompletionRow[]`

8. **CompletionRow Interface** - notes/adapter-interface.md:215-223 defines:
   ```typescript
   interface CompletionRow {
     id: string
     series_id: string
     instance_date: string  // ISO date
     date: string  // ISO date when completed
     start_time: string  // ISO datetime
     end_time: string  // ISO datetime
     created_at: string
   }
   ```

9. **LAW 17** - notes/testing-spec-05-series-crud.md:229 states "LAW 17: splitSeries returns new series ID ≠ original ID"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify both series' completion states and the split's integrity:

```typescript
it('split series starts fresh with no completions', async () => {
  const id = await createSeries(adapter, {
    title: 'Test',
    startDate: '2024-01-01' as LocalDate,
    endDate: '2024-01-31' as LocalDate,
    timeOfDay: '09:00' as LocalTime,
    duration: 30,
  })
  await adapter.createCompletion({
    id: 'comp-1',
    seriesId: id,
    instanceDate: '2024-01-05' as LocalDate,
    date: '2024-01-05' as LocalDate,
    startTime: '2024-01-05T13:30:00' as LocalDateTime,
    endTime: '2024-01-05T14:00:00' as LocalDateTime,
  })

  // Verify completion exists with correct properties before split
  const completionsBefore = await adapter.getCompletionsBySeries(id)
  expect(completionsBefore).toHaveLength(1)
  expect(completionsBefore[0]).toMatchObject({
    id: 'comp-1',
    series_id: id,
    instance_date: '2024-01-05',
  })

  const newId = await splitSeries(adapter, id, '2024-01-15' as LocalDate, {})

  // Verify new series ID is different
  expect(newId).not.toBe(id)

  // Verify new series has no completions
  const completions = await adapter.getCompletionsBySeries(newId)
  expect(completions).toEqual([])

  // Verify original series still has its completions
  const originalCompletions = await adapter.getCompletionsBySeries(id)
  expect(originalCompletions).toHaveLength(1)
  expect(originalCompletions[0].id).toBe('comp-1')

  // Verify via getAllCompletions
  const allCompletions = await adapter.getAllCompletions()
  expect(allCompletions.find(c => c.series_id === newId)).toBeUndefined()
  expect(allCompletions.find(c => c.id === 'comp-1')?.series_id).toBe(id)
})
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-split: `expect(completionsBefore).toHaveLength(1)` - Verify completion exists
2. Pre-split: `expect(completionsBefore[0]).toMatchObject({...})` - Verify actual data
3. Post-split: `expect(newId).not.toBe(id)` - Verify new ID (LAW 17)
4. Post-split: `expect(completions).toEqual([])` - New series empty
5. Post-split: Original series still has completions (LAW 18)
6. Post-split: getAllCompletions verification - Cross-verify via different API

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies completion data before split
- Confirms new series is actually different (not same ID)
- Verifies BOTH series' states after split
- Cannot pass if `getCompletionsBySeries` always returns []
- Cannot pass if completion was never created
- Validates LAW 17, LAW 18, and LAW 19 together

**What specific changes would transform this test into its ideal form?**

Add before line 1365:
```typescript
// Verify completion exists before split
const completionsBefore = await adapter.getCompletionsBySeries(id)
expect(completionsBefore).toHaveLength(1)
expect(completionsBefore[0]).toMatchObject({
  id: 'comp-1',
  series_id: id,
})
```

Add after line 1365 (after splitSeries call):
```typescript
// Verify new series ID is different
expect(newId).not.toBe(id)
```

Replace line 1367:
```typescript
expect(completions.length).toBe(0)
```

With:
```typescript
expect(completions).toEqual([])

// Verify original series still has completions (LAW 18)
const originalCompletions = await adapter.getCompletionsBySeries(id)
expect(originalCompletions).toHaveLength(1)
expect(originalCompletions[0].id).toBe('comp-1')
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/05-series-crud.test.ts lines 1355-1394 to examine the exact violation at line 1367 and full test context

3. **Search for splitSeries specification and completions** - Used Grep tool with pattern `splitSeries|split.*series|POST.*split|LAW.*completion|getCompletionsBySeries` (case insensitive) in notes directory, finding:
   - notes/testing-spec-05-series-crud.md:204: splitSeries signature
   - notes/testing-spec-05-series-crud.md:229-231: LAW 17-19 about split behavior
   - notes/fuzz-testing-task-list.md:208-212: Property tests for splitSeries
   - notes/adapter-interface.md:73: getCompletionsBySeries signature
   - notes/testing-spec-04-adapter.md:276: getCompletionsBySeries

4. **Search for completion schema** - Used Grep tool with pattern `CREATE TABLE completion|completion.*REFERENCES.*series` in notes/schema.md, finding:
   - Line 161: CREATE TABLE completion

5. **Search for adapter interface** - Used Grep tool with pattern `getAllCompletions|CompletionRow|getCompletionsBySeries` in notes/adapter-interface.md, finding:
   - Lines 71-74: Completion method signatures
   - Line 215: CompletionRow interface

6. **Read specification details** - Used Read tool on:
   - notes/testing-spec-05-series-crud.md lines 200-239: Series Splitting section with PRE 21-24, POST 13-17, LAW 17-20
   - notes/schema.md lines 158-174: CREATE TABLE completion definition
   - notes/adapter-interface.md lines 212-223: CompletionRow interface

---

## Violation #22: tests/06-completions.test.ts:481

**Test Name:** `completions outside window`

**Violation Line:**
```typescript
expect(completions.length).toBe(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 7 from the completions specification: "All returned completions have date in [today - windowDays + 1, today]" (notes/testing-spec-06-completions.md:114) and LAW 17: "Completion on asOf - windowDays is NOT counted" (notes/testing-spec-06-completions.md:172). A completion 10 days in the past should NOT appear when querying with a 7-day window.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A completion is logged 10 days before asOf date (2024-01-10 when asOf is 2024-01-20)
2. When `getCompletionsByTarget` is called with windowDays=7
3. The completion is NOT returned because 10 > 7 (outside the window)
4. The window boundary calculation is correct: [Jan 14, Jan 20] for windowDays=7 as of Jan 20

**Why does this specific test matter?**

Window-based completion queries drive condition evaluation (count conditions). If completions outside the window are incorrectly included:
- Count conditions would evaluate incorrectly
- Pattern activation logic would malfunction
- Schedules would fire at wrong times

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that window filtering actually happened. It could pass when:
- `getCompletionsByTarget` is broken and always returns `[]`
- The completion was never logged successfully
- The target doesn't match (wrong seriesId)
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, incorrect window filtering could:
- Cause medications to be scheduled incorrectly (count-gated patterns)
- Lead to over- or under-administration of treatments
- Corrupt the condition evaluation system entirely

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 7** - notes/testing-spec-06-completions.md:114 states "LAW 7: All returned completions have date in [today - windowDays + 1, today]"

2. **LAW 17** - notes/testing-spec-06-completions.md:172 states "LAW 17: Completion on asOf - windowDays is NOT counted"

3. **Test Plan Reference** - notes/test-plan-06.md:71 states "completions outside window | window=7, log 10 days ago | Excluded | LAW 7"

4. **getCompletions Signature** - notes/testing-spec-06-completions.md:109 defines `getCompletions(target: Target, windowDays: number): Completion[]`

5. **Window Definition** - notes/testing-spec-03-condition-evaluation.md:93-94 explains:
   ```
   Window for windowDays W as of date D = [D - W + 1, D] inclusive
     // windowDays=14 as of Jan 15 → [Jan 2, Jan 15]
   ```

6. **LAW 1** - notes/testing-spec-03-condition-evaluation.md:100 states "LAW 1 (Window size): Window contains exactly windowDays days"

7. **LAW 36** - notes/testing-spec-03-condition-evaluation.md:247 states "LAW 36: Completion outside window doesn't affect count condition result"

8. **Property 199** - notes/fuzz-testing-task-list.md:224 states "199. Property: getCompletions respects windowDays"

9. **countCompletionsInWindow Formula** - notes/testing-spec-06-completions.md:161-162 defines the mathematical window calculation

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify both the window boundary and that the completion exists outside it:

```typescript
it('completions outside window', async () => {
  const asOf = parseDate('2024-01-20');
  // Log completion 10 days ago (outside 7-day window)
  await logCompletion(adapter, {
    seriesId: testSeriesId,
    instanceDate: addDays(asOf, -10),
    startTime: parseDateTime('2024-01-10T09:00:00'),
    endTime: parseDateTime('2024-01-10T09:30:00'),
  });

  // Verify completion exists (was actually logged)
  const allCompletions = await adapter.getCompletionsBySeries(testSeriesId);
  expect(allCompletions).toHaveLength(1);
  expect(allCompletions[0].date).toBe('2024-01-10');  // 10 days before Jan 20

  // Verify window boundary: [Jan 14, Jan 20] for windowDays=7
  // Completion on Jan 10 is outside this window
  const completions = await getCompletionsByTarget(adapter, {
    target: { type: 'seriesId', seriesId: testSeriesId },
    windowDays: 7,
    asOf,
  });
  expect(completions).toEqual([]);

  // Also verify boundary edge case: completion exactly at window start IS included
  await logCompletion(adapter, {
    seriesId: testSeriesId,
    instanceDate: addDays(asOf, -6),  // Jan 14 = asOf - windowDays + 1
    startTime: parseDateTime('2024-01-14T09:00:00'),
    endTime: parseDateTime('2024-01-14T09:30:00'),
  });
  const boundaryCompletions = await getCompletionsByTarget(adapter, {
    target: { type: 'seriesId', seriesId: testSeriesId },
    windowDays: 7,
    asOf,
  });
  expect(boundaryCompletions).toHaveLength(1);
  expect(boundaryCompletions[0].date).toBe(addDays(asOf, -6));
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-query: `expect(allCompletions).toHaveLength(1)` - Verify completion was logged
2. Pre-query: `expect(allCompletions[0].date).toBe('2024-01-10')` - Verify actual date
3. Window query: `expect(completions).toEqual([])` - Empty array (no completions in window)
4. Boundary test: Verify completion exactly at window start IS included (LAW 16)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the completion actually exists before checking window filtering
- Confirms the completion date is what we expect (10 days ago)
- Tests the window boundary to show the filtering is actually based on window
- Cannot pass if `getCompletionsByTarget` always returns []
- Cannot pass if completion was never logged

**What specific changes would transform this test into its ideal form?**

Add after line 474 (after logCompletion):
```typescript
// Verify completion exists (was actually logged)
const allCompletions = await adapter.getCompletionsBySeries(testSeriesId);
expect(allCompletions).toHaveLength(1);
expect(allCompletions[0].date).toBe(addDays(asOf, -10));
```

Replace line 481:
```typescript
expect(completions.length).toBe(0);
```

With:
```typescript
expect(completions).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/06-completions.test.ts lines 455-509 to examine the exact violation at line 481 and full test context

3. **Search for window and getCompletionsByTarget specification** - Used Grep tool with pattern `getCompletionsByTarget|LAW.*window|windowDays|completions.*window` (case insensitive) in notes directory, finding:
   - notes/testing-spec-06-completions.md:109: getCompletions signature
   - notes/testing-spec-06-completions.md:114: LAW 7 - window filtering
   - notes/testing-spec-06-completions.md:172: LAW 17 - outside window not counted
   - notes/test-plan-06.md:71: Test case for outside window
   - notes/testing-spec-03-condition-evaluation.md:93-94: Window definition
   - notes/testing-spec-03-condition-evaluation.md:100: LAW 1 - window size
   - notes/fuzz-testing-task-list.md:224: Property 199

4. **Read specification details** - Used Read tool on:
   - notes/testing-spec-06-completions.md lines 105-134: getCompletions by target section with LAW 7-9
   - notes/testing-spec-06-completions.md lines 163-182: Window boundary laws LAW 12-17

---

## Violation #23: tests/06-completions.test.ts:669

**Test Name:** `getByInstance after delete`

**Violation Line:**
```typescript
expect(allCompletions).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies POST 5 and LAW 10 from the completions specification: "Completion no longer exists" (notes/testing-spec-06-completions.md:136) and "After delete, getCompletionByInstance returns null for that instance" (notes/testing-spec-06-completions.md:143). After calling `deleteCompletion`, the completion should be removed from all query results.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A completion can be logged and exists (verified at line 658-663)
2. When `deleteCompletion(logResult.value.id)` is called
3. The completion is removed from `getCompletionsBySeries` results
4. The array is now empty

**Why does this specific test matter?**

Completion deletion allows users to correct mistakes or remove invalid completion records. If completions aren't properly deleted:
- Completion counts would remain inflated
- Historical data would be incorrect
- Condition evaluations would use stale data

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because it only verifies an empty array is returned, not that:
1. The specific completion was actually deleted
2. LAW 10 is satisfied (getCompletionByInstance returns null)
3. The deletion persisted correctly

It could pass when:
- `getCompletionsBySeries` is broken and always returns `[]`
- The completion was never created successfully
- The series ID doesn't match

**Why does getting it right matter?**

For medically fragile people, incorrect completion records could:
- Lead to wrong medication dosing calculations (based on completion counts)
- Corrupt historical care records
- Cause condition-gated patterns to activate/deactivate incorrectly

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **POST 5** - notes/testing-spec-06-completions.md:136 states "POST 5: Completion no longer exists"

2. **POST 6** - notes/testing-spec-06-completions.md:137 states "POST 6: getCompletion(id) = null"

3. **LAW 10** - notes/testing-spec-06-completions.md:143 states "LAW 10: After delete, getCompletionByInstance returns null for that instance"

4. **LAW 11** - notes/testing-spec-06-completions.md:144 states "LAW 11: Delete on non-existent ID throws NotFoundError"

5. **PRE 6** - notes/testing-spec-06-completions.md:130 states "PRE 6: Completion with id exists"

6. **deleteCompletion Signature** - notes/testing-spec-06-completions.md:124 defines `deleteCompletion(id: CompletionId): void`

7. **Adapter Interface - deleteCompletion** - notes/adapter-interface.md:75 defines `deleteCompletion(id: string): void`

8. **getCompletionsBySeries Signature** - notes/testing-spec-06-completions.md:86 defines `getCompletionsBySeries(seriesId: SeriesId): Completion[]`

9. **Property 171** - notes/fuzz-testing-task-list.md:192 states "171. Property: deleteCompletion removes it"

10. **Property 197** - notes/fuzz-testing-task-list.md:222 states "197. Property: deleteCompletion removes from counts"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify deletion via multiple query methods and confirm LAW 10:

```typescript
it('getByInstance after delete', async () => {
  const instanceDate = parseDate('2024-01-15');
  const logResult = await logCompletion(adapter, {
    seriesId: testSeriesId,
    instanceDate,
    startTime: parseDateTime('2024-01-15T09:00:00'),
    endTime: parseDateTime('2024-01-15T09:30:00'),
  });
  expect(logResult.ok).toBe(true);
  if (!logResult.ok) throw new Error(`'getByInstance after delete' setup failed: ${logResult.error.type}`);

  const completionId = logResult.value.id;

  // Verify completion exists before deletion
  const beforeDelete = await getCompletionByInstance(adapter, testSeriesId, instanceDate);
  expect(beforeDelete).toEqual(expect.objectContaining({
    seriesId: testSeriesId,
    date: instanceDate,
    durationMinutes: 30,
  }));

  // Also verify via getCompletionsBySeries
  const beforeDeleteAll = await getCompletionsBySeries(adapter, testSeriesId);
  expect(beforeDeleteAll).toHaveLength(1);
  expect(beforeDeleteAll[0].id).toBe(completionId);

  await deleteCompletion(adapter, completionId);

  // LAW 10: After delete, getCompletionByInstance returns null
  const afterDelete = await getCompletionByInstance(adapter, testSeriesId, instanceDate);
  expect(afterDelete).toBeNull();

  // Verify the completion was actually removed from the collection
  const allCompletions = await getCompletionsBySeries(adapter, testSeriesId);
  expect(allCompletions).toEqual([]);

  // Also verify via getAllCompletions
  const globalCompletions = await adapter.getAllCompletions();
  expect(globalCompletions.find(c => c.id === completionId)).toBeUndefined();
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: Verify completion exists via getCompletionByInstance
2. Pre-delete: Verify completion exists via getCompletionsBySeries with matching ID
3. Post-delete: `expect(afterDelete).toBeNull()` - LAW 10 verification
4. Post-delete: `expect(allCompletions).toEqual([])` - series query empty
5. Post-delete: Verify via getAllCompletions - cross-verify via global query

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Captures the completion ID before deletion
- Verifies existence via multiple query methods before delete
- Explicitly tests LAW 10 (getCompletionByInstance returns null)
- Cross-verifies via getAllCompletions
- Cannot pass if deletion didn't actually happen
- Cannot pass if completion was never created

**What specific changes would transform this test into its ideal form?**

Add after line 665 (after deleteCompletion):
```typescript
// LAW 10: After delete, getCompletionByInstance returns null
const afterDelete = await getCompletionByInstance(adapter, testSeriesId, instanceDate);
expect(afterDelete).toBeNull();
```

Add after line 669:
```typescript
// Also verify via getAllCompletions
const globalCompletions = await adapter.getAllCompletions();
expect(globalCompletions.find(c => c.id === logResult.value.id)).toBeUndefined();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/06-completions.test.ts lines 640-694 to examine the exact violation at line 669 and full test context

3. **Search for deleteCompletion specification** - Used Grep tool with pattern `deleteCompletion|LAW.*delete.*completion|getCompletionsBySeries|getCompletionByInstance` (case insensitive) in notes directory, finding:
   - notes/testing-spec-06-completions.md:124: deleteCompletion signature
   - notes/testing-spec-06-completions.md:143: LAW 10 - getCompletionByInstance returns null
   - notes/adapter-interface.md:75: deleteCompletion adapter interface
   - notes/fuzz-testing-task-list.md:192,222: Property tests for deletion

4. **Read specification details** - Used Read tool on:
   - notes/testing-spec-06-completions.md lines 120-154: Delete Completion section with PRE 6, POST 5-6, LAW 10-11

---

## Violation #24: tests/07-cycling.test.ts:861

**Test Name:** `cycling optional`

**Violation Line:**
```typescript
expect(series).not.toHaveProperty('cycling');
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies INV 3 from the cycling specification: "Cycling config is optional per series" (notes/testing-spec-07-cycling.md:204). A series can be created without any cycling configuration, and the system should handle this gracefully.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A series can be created without specifying a `cycling` property
2. After creation, the series does not have a `cycling` property
3. The series exists and has the correct title

**Why does this specific test matter?**

Cycling is an optional feature that rotates through titles/descriptions across instances. Many series (simple one-time events, basic recurring schedules) don't need cycling. The system must work correctly when cycling is not configured.

**What are the consequences if this test is wrong or weak?**

The `not.toHaveProperty('cycling')` assertion is weak because it:
1. Only checks for absence of a property on the series object
2. Doesn't verify via `getCyclingConfig(seriesId)` which should return null
3. Doesn't verify that instance title resolution works correctly (LAW 14)
4. Could pass if the adapter returns a malformed series object

**Why does getting it right matter?**

For medically fragile people, cycling often distinguishes between different medications or care tasks in a rotation. If a non-cycling series incorrectly inherits cycling behavior:
- Task titles could show wrong medication names
- Caregivers could be confused about which task to perform
- Critical care could be misdirected

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **INV 3** - notes/testing-spec-07-cycling.md:204 states "INV 3: Cycling config is optional per series"

2. **LAW 14** - notes/testing-spec-07-cycling.md:169 states "LAW 14: No cycling → series title"

3. **resolveInstanceTitle Definition** - notes/testing-spec-07-cycling.md:159-164:
   ```
   resolveInstanceTitle(series, instanceNumber) =
     if series.cycling = null then
       series.title
     else
       let item = getCyclingItem(series.cycling, series.cyclingState, instanceNumber)
       item.title
   ```

4. **Adapter Interface - getCyclingConfig** - notes/adapter-interface.md:54 defines `getCyclingConfig(seriesId: string): CyclingConfigRow | null`

5. **CyclingConfigRow Interface** - notes/adapter-interface.md:190-196 defines:
   ```typescript
   interface CyclingConfigRow {
     id: string
     series_id: string
     mode: string  // 'sequential' | 'random'
     gap_leap: number  // 0 or 1
     current_index: number
   }
   ```

6. **Series Type** - notes/testing-spec-05-series-crud.md:38 shows `cycling?: CyclingConfig` (optional property)

7. **Test Plan Reference** - notes/test-plan-07.md:172 states "INV 3 | `cycling optional` | Series without cycling works"

8. **No Cycling Title Resolution** - notes/test-plan-07.md:137 states "no cycling uses series title | series without cycling | series.title | LAW 14 (resolve)"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify both the absence of cycling and the correct behavior for non-cycling series:

```typescript
it('cycling optional', async () => {
  const seriesResult = await createSeries(adapter, {
    title: 'No Cycling',
    startDate: parseDate('2024-01-01'),
  });
  expect(seriesResult.ok).toBe(true);
  if (!seriesResult.ok) throw new Error(`'cycling optional' setup failed: ${seriesResult.error.type}`);

  const seriesId = seriesResult.value.id;
  const series = await adapter.getSeries(seriesId);

  // Verify series exists and has correct properties
  expect(series).not.toBeNull();
  expect(series).toEqual(expect.objectContaining({
    id: seriesId,
    title: 'No Cycling',
  }));

  // INV 3: Cycling is optional - verify via dedicated getter
  const cyclingConfig = await adapter.getCyclingConfig(seriesId);
  expect(cyclingConfig).toBeNull();

  // LAW 14: No cycling → series title is used
  // Verify resolveInstanceTitle behavior (if available)
  const instanceTitle = await resolveInstanceTitle(adapter, seriesId, 0);
  expect(instanceTitle).toBe('No Cycling');

  // Also verify cycling items don't exist
  const cyclingItems = await adapter.getCyclingItems(seriesId);
  expect(cyclingItems).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. `expect(series).not.toBeNull()` - Verify series exists
2. `expect(series).toEqual(...)` - Verify correct properties
3. `expect(cyclingConfig).toBeNull()` - INV 3 via getCyclingConfig
4. `expect(instanceTitle).toBe('No Cycling')` - LAW 14 verification
5. `expect(cyclingItems).toEqual([])` - No cycling items

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies cycling absence via dedicated adapter method
- Tests the actual behavior (title resolution) not just data structure
- Cross-verifies that no cycling items exist
- Cannot pass if getCyclingConfig returns something other than null
- Validates the behavioral consequence of no cycling (LAW 14)

**What specific changes would transform this test into its ideal form?**

Add after line 861:
```typescript
// INV 3: Verify via dedicated getter
const cyclingConfig = await adapter.getCyclingConfig(seriesResult.value.id);
expect(cyclingConfig).toBeNull();

// Also verify no cycling items
const cyclingItems = await adapter.getCyclingItems(seriesResult.value.id);
expect(cyclingItems).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/07-cycling.test.ts lines 850-889 to examine the exact violation at line 861 and full test context

3. **Search for cycling optional specification** - Used Grep tool with pattern `cycling.*optional|LAW.*cycling|getCyclingConfig|cycling.*null|no cycling` (case insensitive) in notes directory, finding:
   - notes/testing-spec-07-cycling.md:204: INV 3 - Cycling config is optional
   - notes/testing-spec-07-cycling.md:160-161: null cycling handling
   - notes/testing-spec-07-cycling.md:169: LAW 14 - No cycling uses series title
   - notes/adapter-interface.md:54: getCyclingConfig signature
   - notes/test-plan-07.md:137,172: Test cases for optional cycling

4. **Search for CyclingConfig interface** - Used Grep tool with pattern `CyclingConfig|cycling_config|cycling.*series` in notes directory, finding:
   - notes/adapter-interface.md:190: CyclingConfigRow interface
   - notes/testing-spec-05-series-crud.md:38: cycling optional in Series type

5. **Read specification details** - Used Read tool on:
   - notes/testing-spec-07-cycling.md lines 155-214: resolveInstanceTitle, LAW 14-19, INV 1-4
   - notes/adapter-interface.md lines 185-209: CyclingConfigRow and CyclingItemRow interfaces

---

## Violation #25: tests/09-instance-exceptions.test.ts:843

**Test Name:** (cascade deletion test within instance exceptions)

**Violation Line:**
```typescript
expect(exceptions.length).toBe(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 39 from the adapter specification: "Series deletion cascades to exceptions" (notes/testing-spec-04-adapter.md:266). When a series is deleted, all instance exceptions (cancelled or rescheduled instances) associated with that series should be automatically removed from the database via cascade deletion.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Multiple instance exceptions can be created for a series (lines 829-836 show two exceptions for dates '2024-01-15' and '2024-01-16')
2. When `deleteSeries(adapter, testSeriesId)` is called
3. The exceptions are automatically deleted via database cascade
4. `getExceptionsBySeries(adapter, testSeriesId)` returns an empty array

**Why does this specific test matter?**

Instance exceptions modify specific occurrences of recurring schedules (cancellations and reschedules). If exceptions survive their parent series being deleted:
- `getExceptionsBySeries` would return orphan data
- Range queries might return exceptions for non-existent series
- Database integrity would be compromised

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that:
1. The specific exceptions were actually deleted
2. Cascade deletion actually happened (vs query returning empty for another reason)
3. Both exceptions (at '2024-01-15' and '2024-01-16') are gone

**Why does getting it right matter?**

For medically fragile people, orphan instance exceptions could:
- Corrupt schedule instance calculations
- Lead to confusing data in historical views
- Cause unexpected behavior in the reflow algorithm

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 39** - notes/testing-spec-04-adapter.md:266 states "LAW 39: Series deletion cascades to exceptions"

2. **Database Schema - instance_exception** - notes/schema.md:145-154 defines:
   ```sql
   CREATE TABLE instance_exception (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     type TEXT NOT NULL CHECK (type IN ('cancelled', 'rescheduled')),
     new_time TEXT,
     created_at TEXT NOT NULL,
     UNIQUE (series_id, instance_date)
   );
   ```

3. **Schema Design Rationale** - notes/schema.md:273 states "instance_exception | CASCADE | Exceptions meaningless without series"

4. **Adapter Interface - getInstanceExceptionsBySeries** - notes/adapter-interface.md:66 defines `getInstanceExceptionsBySeries(seriesId: string): InstanceExceptionRow[]`

5. **InstanceExceptionRow Interface** - notes/adapter-interface.md:206-213 defines:
   ```typescript
   interface InstanceExceptionRow {
     id: string
     series_id: string
     instance_date: string  // ISO date
     type: string  // 'cancelled' | 'rescheduled'
     new_time: string | null  // ISO datetime
     created_at: string
   }
   ```

6. **LAW 37** - notes/testing-spec-04-adapter.md:264 states "LAW 37: At most one exception per (seriesId, instanceDate)"

7. **Property Test Reference** - notes/fuzz-testing-task-list.md:179 states "158. Property: deleteSeries cascades to instance exceptions"

8. **getInstanceExceptionsInRange** - notes/adapter-interface.md:67 defines `getInstanceExceptionsInRange(startDate: string, endDate: string): InstanceExceptionRow[]` - could be used for cross-verification

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify exception existence before deletion and cascade via multiple methods:

```typescript
// (continuation of test - after creating exceptions)
expect(exceptions.some(e => e.instanceDate === parseDate('2024-01-15'))).toBe(true);
expect(exceptions.some(e => e.instanceDate === parseDate('2024-01-16'))).toBe(true);
expect(exceptions[0].seriesId).toBe(testSeriesId);
expect(exceptions[1].seriesId).toBe(testSeriesId);

// Capture exception IDs for later verification
const exceptionIds = exceptions.map(e => e.id);
expect(exceptionIds).toHaveLength(2);

// Delete series
await deleteSeries(adapter, testSeriesId);

// LAW 39: Exceptions should be deleted via cascade
exceptions = await getExceptionsBySeries(adapter, testSeriesId);
expect(exceptions).toEqual([]);

// Also verify via range query
const rangeExceptions = await adapter.getInstanceExceptionsInRange(
  parseDate('2024-01-01'),
  parseDate('2024-01-31')
);
expect(rangeExceptions.find(e => e.series_id === testSeriesId)).toBeUndefined();

// Also verify via individual getters
const ex1 = await adapter.getInstanceException(testSeriesId, parseDate('2024-01-15'));
const ex2 = await adapter.getInstanceException(testSeriesId, parseDate('2024-01-16'));
expect(ex1).toBeNull();
expect(ex2).toBeNull();
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: Capture exception IDs before deletion
2. Post-delete: `expect(exceptions).toEqual([])` - series-specific empty
3. Post-delete: Range query verification - cross-check via different API
4. Post-delete: Individual exception getters return null

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies specific exceptions exist before deletion
- Cross-verifies via range query
- Tests individual exception lookups return null
- Cannot pass if `getExceptionsBySeries` always returns []
- Cannot pass if exceptions were never created

**What specific changes would transform this test into its ideal form?**

Add before line 838 (before deleteSeries):
```typescript
// Capture exception IDs for verification
const exceptionIds = exceptions.map(e => e.id);
expect(exceptionIds).toHaveLength(2);
```

Replace line 843:
```typescript
expect(exceptions.length).toBe(0);
```

With:
```typescript
expect(exceptions).toEqual([]);

// Also verify via individual lookups
const ex1 = await adapter.getInstanceException(testSeriesId, parseDate('2024-01-15'));
const ex2 = await adapter.getInstanceException(testSeriesId, parseDate('2024-01-16'));
expect(ex1).toBeNull();
expect(ex2).toBeNull();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/09-instance-exceptions.test.ts lines 830-869 to examine the exact violation at line 843 and full test context

3. **Search for cascade and exception specification** - Used Grep tool with pattern `deleteSeries.*cascade.*exception|LAW.*exception|getExceptionsBySeries|exception.*ON DELETE CASCADE|instance.*exception` (case insensitive) in notes directory, finding:
   - notes/testing-spec-04-adapter.md:266: LAW 39 - Series deletion cascades to exceptions
   - notes/fuzz-testing-task-list.md:179: Property test reference
   - notes/adapter-interface.md:66-67: Exception method signatures
   - notes/schema.md:145,273: CREATE TABLE and rationale

4. **Search for InstanceExceptionRow interface** - Used Grep tool with pattern `CREATE TABLE.*exception|instance_exception|InstanceExceptionRow` in notes directory, finding:
   - notes/schema.md:145: CREATE TABLE instance_exception
   - notes/adapter-interface.md:206: InstanceExceptionRow interface

5. **Read specification details** - Used Read tool on:
   - notes/testing-spec-04-adapter.md lines 250-274: Instance Exception Operations section with LAW 37-39
   - notes/schema.md lines 140-159: CREATE TABLE instance_exception definition
   - notes/adapter-interface.md lines 202-216: InstanceExceptionRow interface

---

## Violation #26: tests/09-instance-exceptions.test.ts:1039

**Test Name:** `cancel week of instances`

**Violation Line:**
```typescript
expect(schedule.length).toBe(0);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 1 from the instance exceptions specification: "Cancelled instance excluded from getSchedule results" (notes/testing-spec-09-instance-exceptions.md:50) and POST 2: "Instance no longer appears in schedule" (notes/testing-spec-09-instance-exceptions.md:43). When multiple instances (Mon-Fri of a week) are cancelled, the schedule for that range should be empty.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A daily series exists (created in beforeEach with startDate '2024-01-01')
2. Five consecutive dates (Jan 8-12, 2024) are cancelled via `cancelInstance`
3. When `getSchedule` is called for the range [Jan 8, Jan 12]
4. The schedule is empty because all instances in that range are cancelled

**Why does this specific test matter?**

This tests a "vacation scenario" - cancelling a week's worth of instances. It validates that:
- Multiple cancellations work correctly together
- The schedule generation respects all cancelled instances in a range
- Bulk cancellation (like for vacation/holiday) functions as expected

**What are the consequences if this test is wrong or weak?**

The `.length` check is weak because it only verifies the count is 0, not that:
1. The 5 specific dates were actually cancelled
2. Exception records were created for each date
3. The cancellations specifically filtered those dates (not a broken query returning empty)

It could pass when:
- `getSchedule` is broken and always returns `[]`
- The series was never created correctly
- `cancelInstance` silently failed
- The range doesn't match what the series would produce

**Why does getting it right matter?**

For medically fragile people, incorrect vacation handling could:
- Schedule care tasks during known absence periods
- Fail to cancel medication reminders during hospitalization
- Generate alerts and notifications when caregivers are unavailable

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 1** - notes/testing-spec-09-instance-exceptions.md:50 states "LAW 1: Cancelled instance excluded from getSchedule results"

2. **POST 2** - notes/testing-spec-09-instance-exceptions.md:43 states "POST 2: Instance no longer appears in schedule"

3. **POST 1** - notes/testing-spec-09-instance-exceptions.md:42 states "POST 1: Exception record created with type='cancelled'"

4. **LAW 2** - notes/testing-spec-09-instance-exceptions.md:51 states "LAW 2: Cancelling doesn't affect pattern (other instances still generated)"

5. **cancelInstance Signature** - notes/testing-spec-09-instance-exceptions.md:28 defines `cancelInstance(seriesId: SeriesId, instanceDate: LocalDate): void`

6. **applyInstanceExceptions Logic** - notes/testing-spec-09-instance-exceptions.md:164-167 shows how cancelled instances are filtered:
   ```
   applyInstanceExceptions(instances: Instance[], exceptions: InstanceException[]): Instance[] =
     instances
       .filter(i => not isCancelled(i, exceptions))
       .map(i => applyReschedule(i, exceptions))
   ```

7. **isCancelled Definition** - notes/testing-spec-09-instance-exceptions.md:169-170 states:
   ```
   isCancelled(instance, exceptions) =
     ∃e ∈ exceptions: e.instanceDate = instance.date ∧ e.type = 'cancelled'
   ```

8. **getSchedule Integration** - notes/testing-spec-09-instance-exceptions.md:147-158 shows how expandSeriesInstances applies exceptions to generate the final schedule

9. **Verification Strategy** - notes/testing-spec-09-instance-exceptions.md:209-210 states "Cancel → instance gone from schedule"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify exception creation and schedule exclusion for each specific date:

```typescript
it('cancel week of instances', async () => {
  const dates = [
    parseDate('2024-01-08'),
    parseDate('2024-01-09'),
    parseDate('2024-01-10'),
    parseDate('2024-01-11'),
    parseDate('2024-01-12'),
  ];

  // Verify instances exist before cancellation
  const beforeCancel = await getSchedule(adapter, {
    seriesId: testSeriesId,
    range: { start: dates[0], end: dates[4] },
  });
  expect(beforeCancel).toHaveLength(5);
  expect(beforeCancel.map(i => i.date)).toEqual(dates);

  // Cancel each instance
  for (const date of dates) {
    await cancelInstance(adapter, testSeriesId, date);
  }

  // Verify exception records were created for each date
  const exceptions = await getExceptionsBySeries(adapter, testSeriesId);
  expect(exceptions).toHaveLength(5);
  for (const date of dates) {
    expect(exceptions.some(e =>
      e.instanceDate === date && e.type === 'cancelled'
    )).toBe(true);
  }

  // LAW 1: Cancelled instances excluded from getSchedule
  const schedule = await getSchedule(adapter, {
    seriesId: testSeriesId,
    range: { start: dates[0], end: dates[4] },
  });
  expect(schedule).toEqual([]);

  // LAW 2: Verify other instances still exist (pattern unaffected)
  const beforeRange = await getSchedule(adapter, {
    seriesId: testSeriesId,
    range: { start: parseDate('2024-01-01'), end: parseDate('2024-01-07') },
  });
  expect(beforeRange).toHaveLength(7);  // Jan 1-7

  const afterRange = await getSchedule(adapter, {
    seriesId: testSeriesId,
    range: { start: parseDate('2024-01-13'), end: parseDate('2024-01-14') },
  });
  expect(afterRange).toHaveLength(2);  // Jan 13-14
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-cancel: `expect(beforeCancel).toHaveLength(5)` - Instances exist before
2. Pre-cancel: `expect(beforeCancel.map(i => i.date)).toEqual(dates)` - Correct dates
3. Post-cancel: `expect(exceptions).toHaveLength(5)` - Exception records created
4. Post-cancel: Each exception has correct date and type='cancelled'
5. Post-cancel: `expect(schedule).toEqual([])` - Schedule empty for cancelled range
6. Post-cancel: Before/after ranges still populated (LAW 2 - pattern unaffected)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies instances exist before cancellation
- Confirms exception records were actually created
- Validates each exception has the correct properties
- Tests LAW 2 (pattern unaffected) by checking surrounding dates
- Cannot pass if `getSchedule` always returns []
- Cannot pass if `cancelInstance` silently fails

**What specific changes would transform this test into its ideal form?**

Add before line 1030 (before cancellation loop):
```typescript
// Verify instances exist before cancellation
const beforeCancel = await getSchedule(adapter, {
  seriesId: testSeriesId,
  range: { start: dates[0], end: dates[4] },
});
expect(beforeCancel).toHaveLength(5);
expect(beforeCancel.map(i => i.date)).toEqual(dates);
```

Add after line 1032 (after cancellation loop):
```typescript
// Verify exception records were created
const exceptions = await getExceptionsBySeries(adapter, testSeriesId);
expect(exceptions).toHaveLength(5);
for (const date of dates) {
  expect(exceptions.some(e =>
    e.instanceDate === date && e.type === 'cancelled'
  )).toBe(true);
}
```

Replace line 1039:
```typescript
expect(schedule.length).toBe(0);
```

With:
```typescript
expect(schedule).toEqual([]);

// LAW 2: Verify other instances still exist
const afterRange = await getSchedule(adapter, {
  seriesId: testSeriesId,
  range: { start: parseDate('2024-01-13'), end: parseDate('2024-01-14') },
});
expect(afterRange).toHaveLength(2);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/09-instance-exceptions.test.ts lines 1020-1076 to examine the exact violation at line 1039 and full test context (cancel week of instances test)

3. **Search for cancelInstance and getSchedule specification** - Used Grep tool with pattern `cancelInstance.*LAW|LAW.*cancel` in autoplanner directory, finding:
   - notes/testing-spec-09-instance-exceptions.md: cancelInstance specification
   - notes/test-plan-09.md: Test cases

4. **Search for schedule LAWs** - Used Grep tool with pattern `getSchedule.*LAW|LAW.*schedule` in autoplanner directory, finding:
   - notes/testing-spec-09-instance-exceptions.md: Integration with pattern expansion
   - notes/testing-spec-13-reflow-algorithm.md: Schedule generation
   - notes/testing-spec-11-links.md: Schedule integration

5. **Read instance exceptions specification** - Used Read tool on notes/testing-spec-09-instance-exceptions.md (full file, 251 lines) to find:
   - Line 28: cancelInstance signature
   - Line 42-43: POST 1-2 about exception creation and schedule exclusion
   - Line 50-51: LAW 1-2 about schedule filtering and pattern preservation
   - Lines 164-175: applyInstanceExceptions algorithm

6. **Read test file imports** - Used Read tool on tests/09-instance-exceptions.test.ts lines 1-55 to understand:
   - Line 27-28: getSchedule imported from '../src/schedule'
   - Line 44-55: beforeEach creates daily series starting 2024-01-01

---

## Violation #27: tests/10-reminders.test.ts:206

**Test Name:** `delete existing reminder`

**Violation Line:**
```typescript
expect(deletedReminder).toHaveLength(0); // Correctly empty after deletion
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `deleteReminder` removes a reminder from the database. After deletion, querying `getRemindersBySeries` and filtering for the deleted reminder's ID should return an empty array.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder can be created successfully (lines 192-197)
2. The reminder can be deleted via `deleteReminder(adapter, createResult.value.id)` (line 200)
3. After deletion, the reminder no longer appears in `getRemindersBySeries` results (lines 204-206)

**Why does this specific test matter?**

Reminder deletion allows users to remove unwanted notifications. If reminders persist after deletion:
- Users would receive unwanted alerts
- `getPendingReminders` would include stale data
- Database storage would grow unboundedly

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because it:
1. Filters the array first (`reminders.filter(r => r.id === createResult.value.id)`)
2. Only checks the filtered array is empty
3. Doesn't verify via `getReminder(id)` returning null
4. Doesn't verify via `getAllReminders` excluding the deleted reminder

It could pass when:
- `getRemindersBySeries` is broken and always returns `[]`
- The reminder was never created successfully
- The filter condition has a bug (wrong ID comparison)

**Why does getting it right matter?**

For medically fragile people, incorrect reminder behavior could:
- Fail to stop unwanted medication alerts
- Continue alerting for cancelled care tasks
- Cause alert fatigue by not respecting user deletions

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **deleteReminder Signature** - notes/testing-spec-10-reminders.md:43 defines `deleteReminder(id: ReminderId): void`

2. **Adapter Interface - deleteReminder** - notes/adapter-interface.md:100 defines `deleteReminder(id: string): void`

3. **Adapter Interface - getRemindersBySeries** - notes/adapter-interface.md:97 defines `getRemindersBySeries(seriesId: string): ReminderRow[]`

4. **ReminderRow Interface** - notes/adapter-interface.md:235-240 defines:
   ```typescript
   interface ReminderRow {
     id: string
     series_id: string
     minutes_before: number
     tag: string
   }
   ```

5. **Database Schema - reminder** - notes/schema.md:197-202 defines:
   ```sql
   CREATE TABLE reminder (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     minutes_before INTEGER NOT NULL,
     tag TEXT NOT NULL
   );
   ```

6. **Test Plan Reference** - notes/test-plan-10.md:43 states "delete existing reminder | delete | Removed | -"

7. **LAW 3** - notes/testing-spec-10-reminders.md:51 states "LAW 3: Series deletion cascades to reminders" (related cascade behavior)

8. **getReminder Signature** - notes/testing-spec-10-reminders.md:40 defines `getReminder(id: ReminderId): Reminder | null` (should return null after deletion)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify deletion via multiple query methods:

```typescript
it('delete existing reminder', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error(`'delete existing reminder' setup failed: ${createResult.error.type}`);

  const reminderId = createResult.value.id;

  // Verify reminder exists before deletion
  const beforeDelete = await getReminder(adapter, reminderId);
  expect(beforeDelete).not.toBeNull();
  expect(beforeDelete).toMatchObject({
    id: reminderId,
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });

  // Also verify via getRemindersBySeries
  const beforeDeleteBySeries = await getRemindersBySeries(adapter, testSeriesId);
  expect(beforeDeleteBySeries.some(r => r.id === reminderId)).toBe(true);

  const deleteResult = await deleteReminder(adapter, reminderId);
  expect(deleteResult.ok).toBe(true);

  // Verify deletion via getReminder - should return null
  const afterDelete = await getReminder(adapter, reminderId);
  expect(afterDelete).toBeNull();

  // Verify deletion via getRemindersBySeries
  const reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders.find(r => r.id === reminderId)).toBeUndefined();

  // Also verify via getAllReminders
  const allReminders = await adapter.getAllReminders();
  expect(allReminders.find(r => r.id === reminderId)).toBeUndefined();
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(beforeDelete).not.toBeNull()` - Reminder exists
2. Pre-delete: `expect(beforeDelete).toMatchObject({...})` - Correct properties
3. Pre-delete: `expect(beforeDeleteBySeries.some(...)).toBe(true)` - In series collection
4. Post-delete: `expect(afterDelete).toBeNull()` - getReminder returns null
5. Post-delete: `expect(reminders.find(...)).toBeUndefined()` - Not in series results
6. Post-delete: `expect(allReminders.find(...)).toBeUndefined()` - Not in global results

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Captures the reminder ID before deletion
- Verifies existence via getReminder before delete
- Verifies via multiple query methods after delete
- Cannot pass if `getRemindersBySeries` always returns []
- Cannot pass if reminder was never created
- Tests getReminder(id) returning null (direct lookup)

**What specific changes would transform this test into its ideal form?**

Add after line 198 (after createResult verification):
```typescript
const reminderId = createResult.value.id;

// Verify reminder exists before deletion
const beforeDelete = await getReminder(adapter, reminderId);
expect(beforeDelete).not.toBeNull();
expect(beforeDelete).toMatchObject({
  id: reminderId,
  seriesId: testSeriesId,
  minutesBefore: 15,
  tag: 'test',
});
```

Add after line 201 (after deleteResult):
```typescript
// Verify deletion via getReminder - should return null
const afterDelete = await getReminder(adapter, reminderId);
expect(afterDelete).toBeNull();
```

Replace lines 204-206:
```typescript
const reminders = await getRemindersBySeries(adapter, testSeriesId);
const deletedReminder = reminders.filter(r => r.id === createResult.value.id);
expect(deletedReminder).toHaveLength(0);
```

With:
```typescript
const reminders = await getRemindersBySeries(adapter, testSeriesId);
expect(reminders.find(r => r.id === reminderId)).toBeUndefined();

// Also verify via getAllReminders
const allReminders = await adapter.getAllReminders();
expect(allReminders.find(r => r.id === reminderId)).toBeUndefined();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 190-239 to examine the exact violation at line 206 and full test context

3. **Search for deleteReminder specification** - Used Grep tool with pattern `deleteReminder.*LAW|LAW.*delete.*reminder|POST.*delete.*reminder` (case insensitive) in notes directory, finding:
   - notes/testing-spec-05-series-crud.md: related cascade mentions

4. **Search for reminder operations** - Used Grep tool with pattern `deleteReminder|reminder.*delete|getRemindersBySeries` in notes directory, finding:
   - notes/test-plan-10.md:43: Test case reference
   - notes/testing-spec-10-reminders.md: Reminder specification
   - notes/adapter-interface.md:100: deleteReminder signature
   - notes/schema.md:197: CREATE TABLE reminder

5. **Read reminders specification** - Used Read tool on notes/testing-spec-10-reminders.md (full file, 232 lines) to find:
   - Line 43: deleteReminder signature
   - Line 40-41: CRUD method signatures
   - Lines 48-53: LAW 1-4 about reminders

6. **Read adapter interface for reminders** - Used Read tool on notes/adapter-interface.md lines 95-122 to find:
   - Line 97: getRemindersBySeries signature
   - Line 100: deleteReminder signature

7. **Read ReminderRow interface** - Used Read tool on notes/adapter-interface.md lines 230-249 to find:
   - Lines 235-240: ReminderRow interface definition

8. **Read database schema** - Used Read tool on notes/schema.md lines 193-227 to find:
   - Lines 197-202: CREATE TABLE reminder definition
   - Line 199: ON DELETE CASCADE for series_id

9. **Search test plan** - Used Grep tool with pattern `delete.*reminder|reminder.*delete` in notes/test-plan-10.md, finding:
   - Line 43: "delete existing reminder | delete | Removed | -"

---

## Violation #28: tests/10-reminders.test.ts:227

**Test Name:** `delete cascades acknowledgments`

**Violation Line:**
```typescript
expect(deletedReminder).toHaveLength(0); // Correctly empty after deletion
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 56 from the adapter specification: "Reminder deletion cascades to acknowledgments" (notes/testing-spec-04-adapter.md:364). When a reminder is deleted, any acknowledgments associated with that reminder should also be automatically deleted via the database's ON DELETE CASCADE constraint.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder can be created (lines 210-216)
2. The reminder can be acknowledged via `acknowledgeReminder` (line 219)
3. When `deleteReminder` is called (line 222)
4. The reminder no longer appears in `getRemindersBySeries` results (lines 225-227)
5. Implicitly: the acknowledgments should also be deleted (cascade)

**Why does this specific test matter?**

Reminder acknowledgments track which notifications have been shown to users. If acknowledgments survive reminder deletion:
- Orphan acknowledgment records would accumulate
- Database integrity would be compromised
- Queries might return inconsistent results

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the reminder is deleted, not the acknowledgment
2. It doesn't call `isReminderAcknowledged` to verify acknowledgment state
3. It doesn't query `getAcknowledgedRemindersInRange` to verify cascade
4. The test name says "cascades acknowledgments" but doesn't verify the cascade

It could pass when:
- `getRemindersBySeries` is broken and always returns `[]`
- The reminder was never created successfully
- The acknowledgment was never created
- The cascade didn't actually happen (orphan acknowledgment remains)

**Why does getting it right matter?**

For medically fragile people, orphan acknowledgment records could:
- Corrupt the pending reminders calculation
- Prevent re-creation of similar reminders
- Cause database bloat affecting performance

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 56** - notes/testing-spec-04-adapter.md:364 states "LAW 56: Reminder deletion cascades to acknowledgments"

2. **Database Schema - reminder_acknowledgment** - notes/schema.md:212-218 defines:
   ```sql
   CREATE TABLE reminder_acknowledgment (
     reminder_id TEXT NOT NULL REFERENCES reminder(id) ON DELETE CASCADE,
     instance_date TEXT NOT NULL,
     acknowledged_at TEXT NOT NULL,
     PRIMARY KEY (reminder_id, instance_date)
   );
   ```

3. **acknowledgeReminder Signature** - notes/adapter-interface.md:103 defines `acknowledgeReminder(reminderId: string, instanceDate: string): void`

4. **isReminderAcknowledged Signature** - notes/adapter-interface.md:104 defines `isReminderAcknowledged(reminderId: string, instanceDate: string): boolean`

5. **getAcknowledgedRemindersInRange Signature** - notes/adapter-interface.md:105 defines `getAcknowledgedRemindersInRange(startDate: string, endDate: string): ReminderAcknowledgmentRow[]`

6. **ReminderAcknowledgmentRow Interface** - notes/adapter-interface.md:242-246 defines:
   ```typescript
   interface ReminderAcknowledgmentRow {
     reminder_id: string
     instance_date: string
     acknowledged_at: string
   }
   ```

7. **Test Plan Reference** - notes/test-plan-10.md:44 states "delete cascades acknowledgments | ack then delete reminder | Acks deleted | -"

8. **LAW 10** - notes/testing-spec-10-reminders.md:112 states "LAW 10: Acknowledgment is idempotent"

9. **Schema Rationale** - notes/schema.md:213 shows `ON DELETE CASCADE` for reminder_id, meaning acknowledgments are automatically deleted when the reminder is deleted

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify both reminder deletion AND acknowledgment cascade:

```typescript
it('delete cascades acknowledgments', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error(`'delete cascades acknowledgments' setup failed: ${createResult.error.type}`);

  const reminderId = createResult.value.id;
  const instanceDate = parseDate('2024-01-15');

  // Acknowledge the reminder
  await acknowledgeReminder(adapter, reminderId, instanceDate);

  // Verify acknowledgment exists before deletion
  const isAckedBefore = await isReminderAcknowledged(adapter, reminderId, instanceDate);
  expect(isAckedBefore).toBe(true);

  // Also verify via range query
  const acksBefore = await adapter.getAcknowledgedRemindersInRange(
    parseDate('2024-01-01'),
    parseDate('2024-01-31')
  );
  expect(acksBefore.some(a => a.reminder_id === reminderId && a.instance_date === instanceDate)).toBe(true);

  // Delete the reminder
  await deleteReminder(adapter, reminderId);

  // LAW 56: Verify reminder is deleted
  const reminder = await getReminder(adapter, reminderId);
  expect(reminder).toBeNull();

  // Verify reminder not in series list
  const reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders.find(r => r.id === reminderId)).toBeUndefined();

  // LAW 56: Verify acknowledgment was cascaded - this is the key assertion!
  // Note: isReminderAcknowledged may throw if reminder doesn't exist,
  // so we verify via range query instead
  const acksAfter = await adapter.getAcknowledgedRemindersInRange(
    parseDate('2024-01-01'),
    parseDate('2024-01-31')
  );
  expect(acksAfter.find(a => a.reminder_id === reminderId)).toBeUndefined();
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(isAckedBefore).toBe(true)` - Acknowledgment exists
2. Pre-delete: Verify via range query - acknowledgment in collection
3. Post-delete: `expect(reminder).toBeNull()` - Reminder deleted
4. Post-delete: `expect(reminders.find(...)).toBeUndefined()` - Not in series list
5. Post-delete: `expect(acksAfter.find(...)).toBeUndefined()` - Acknowledgment cascaded

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies acknowledgment exists before deletion
- Verifies acknowledgment is gone after deletion (the actual cascade)
- Uses multiple query methods to cross-verify
- Cannot pass if acknowledgment was never created
- Cannot pass if cascade didn't happen (orphan ack remains)

**What specific changes would transform this test into its ideal form?**

Add after line 219 (after acknowledgeReminder):
```typescript
const reminderId = createResult.value.id;
const instanceDate = parseDate('2024-01-15');

// Verify acknowledgment exists before deletion
const isAckedBefore = await isReminderAcknowledged(adapter, reminderId, instanceDate);
expect(isAckedBefore).toBe(true);
```

Replace lines 224-227:
```typescript
// Verify deletion via collection - deleted reminder should not appear
const reminders = await getRemindersBySeries(adapter, testSeriesId);
const deletedReminder = reminders.filter(r => r.id === createResult.value.id);
expect(deletedReminder).toHaveLength(0);
```

With:
```typescript
// Verify reminder is deleted
const reminder = await getReminder(adapter, reminderId);
expect(reminder).toBeNull();

// Verify reminder not in series list
const reminders = await getRemindersBySeries(adapter, testSeriesId);
expect(reminders.find(r => r.id === reminderId)).toBeUndefined();

// LAW 56: Verify acknowledgment was cascaded
const acksAfter = await adapter.getAcknowledgedRemindersInRange(
  parseDate('2024-01-01'),
  parseDate('2024-01-31')
);
expect(acksAfter.find(a => a.reminder_id === reminderId)).toBeUndefined();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 205-254 to examine the exact violation at line 227 and full test context

3. **Search for acknowledgment cascade specification** - Used Grep tool with pattern `acknowledgment.*cascade|cascade.*acknowledgment|ON DELETE CASCADE.*reminder` (case insensitive) in notes directory, finding:
   - notes/test-plan-10.md: Test plan reference
   - notes/testing-spec-04-adapter.md: LAW 56
   - notes/schema.md: ON DELETE CASCADE

4. **Read schema for reminder_acknowledgment** - Used Read tool on notes/schema.md lines 207-231 to find:
   - Lines 212-218: CREATE TABLE reminder_acknowledgment with ON DELETE CASCADE
   - Line 213: reminder_id REFERENCES reminder(id) ON DELETE CASCADE

5. **Read adapter specification for LAW 56** - Used Read tool on notes/testing-spec-04-adapter.md lines 358-387 to find:
   - Line 364: "LAW 56: Reminder deletion cascades to acknowledgments"

6. **Read test plan for reminders** - Used Read tool on notes/test-plan-10.md lines 38-62 to find:
   - Line 44: "delete cascades acknowledgments | ack then delete reminder | Acks deleted | -"

7. **Search for acknowledgment adapter methods** - Used Grep tool with pattern `acknowledgeReminder|isReminderAcknowledged|ReminderAcknowledgmentRow` in notes/adapter-interface.md, finding:
   - Line 103: acknowledgeReminder signature
   - Line 104: isReminderAcknowledged signature
   - Line 105: getAcknowledgedRemindersInRange signature
   - Line 242: ReminderAcknowledgmentRow interface

8. **Read ReminderAcknowledgmentRow interface** - Used Read tool on notes/adapter-interface.md lines 240-254 to find:
   - Lines 242-246: ReminderAcknowledgmentRow interface definition

---

## Violation #29: tests/10-reminders.test.ts:240

**Test Name:** `series delete cascades reminders`

**Violation Line:**
```typescript
expect(reminders).toHaveLength(0); // Correctly empty after cascade delete
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 3 from the reminders specification: "Series deletion cascades to reminders" (notes/testing-spec-10-reminders.md:51) and LAW 53 from the adapter specification: "Series deletion cascades to reminders" (notes/testing-spec-04-adapter.md:346). When a series is deleted, all reminders associated with that series should be automatically deleted via the database's ON DELETE CASCADE constraint.

**What functionality or behavior is it verifying?**

The test verifies that:
1. Two reminders can be created for a series (lines 231-232)
2. Both reminders exist before deletion (lines 234-235)
3. When `deleteSeries(adapter, testSeriesId)` is called (line 237)
4. All reminders for that series are automatically deleted (lines 239-240)

**Why does this specific test matter?**

Reminders are notifications tied to series instances. If reminders survive their parent series being deleted:
- Orphan reminders would accumulate in the database
- `getPendingReminders` might return reminders for non-existent series
- Database integrity would be compromised

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that specific reminders were deleted
2. It doesn't verify via `getAllReminders` to cross-check
3. It doesn't capture reminder IDs to verify they're gone
4. Could pass if `getRemindersBySeries` always returns `[]`

It could pass when:
- `getRemindersBySeries` is broken
- The reminders were never created successfully
- The series ID doesn't match
- The cascade didn't actually happen

**Why does getting it right matter?**

For medically fragile people, orphan reminders could:
- Cause alerts for non-existent care tasks
- Corrupt the pending reminders calculation
- Lead to confusion about what tasks need to be done

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 3** - notes/testing-spec-10-reminders.md:51 states "LAW 3: Series deletion cascades to reminders"

2. **LAW 53** - notes/testing-spec-04-adapter.md:346 states "LAW 53: Series deletion cascades to reminders"

3. **Database Schema - reminder** - notes/schema.md:197-202 defines:
   ```sql
   CREATE TABLE reminder (
     id TEXT PRIMARY KEY,
     series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE,
     minutes_before INTEGER NOT NULL,
     tag TEXT NOT NULL
   );
   ```

4. **ON DELETE CASCADE** - notes/schema.md:199 shows `series_id TEXT NOT NULL REFERENCES series(id) ON DELETE CASCADE`, meaning reminders are automatically deleted when the series is deleted

5. **Test Plan Reference** - notes/test-plan-10.md:45 states "series delete cascades reminders | delete series | Reminders deleted | LAW 3"

6. **Property Test Reference** - notes/fuzz-testing-task-list.md:178 states "157. Property: deleteSeries cascades to reminders"

7. **getRemindersBySeries Signature** - notes/adapter-interface.md:97 defines `getRemindersBySeries(seriesId: string): ReminderRow[]`

8. **getAllReminders Signature** - notes/adapter-interface.md:98 defines `getAllReminders(): ReminderRow[]` (for cross-verification)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would capture reminder IDs and verify cascade via multiple query methods:

```typescript
it('series delete cascades reminders', async () => {
  const result1 = await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 15, tag: 'a' });
  const result2 = await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 30, tag: 'b' });

  expect(result1.ok).toBe(true);
  expect(result2.ok).toBe(true);
  if (!result1.ok || !result2.ok) throw new Error('Setup failed');

  const reminderId1 = result1.value.id;
  const reminderId2 = result2.value.id;

  // Verify reminders exist before deletion
  let reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders).toHaveLength(2);
  expect(reminders.map(r => r.tag).sort()).toEqual(['a', 'b']);
  expect(reminders.map(r => r.id).sort()).toEqual([reminderId1, reminderId2].sort());

  // Also verify via getAllReminders
  let allReminders = await adapter.getAllReminders();
  expect(allReminders.filter(r => r.series_id === testSeriesId)).toHaveLength(2);

  await deleteSeries(adapter, testSeriesId);

  // LAW 3, LAW 53: Verify cascade
  reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders).toEqual([]);

  // Cross-verify via getAllReminders - specific reminders should be gone
  allReminders = await adapter.getAllReminders();
  expect(allReminders.find(r => r.id === reminderId1)).toBeUndefined();
  expect(allReminders.find(r => r.id === reminderId2)).toBeUndefined();

  // Also verify via getReminder (individual lookups)
  const reminder1 = await getReminder(adapter, reminderId1);
  const reminder2 = await getReminder(adapter, reminderId2);
  expect(reminder1).toBeNull();
  expect(reminder2).toBeNull();
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(reminders).toHaveLength(2)` - Reminders exist
2. Pre-delete: `expect(reminders.map(r => r.tag).sort()).toEqual(['a', 'b'])` - Correct tags
3. Pre-delete: Capture reminder IDs for later verification
4. Post-delete: `expect(reminders).toEqual([])` - Series query empty
5. Post-delete: Verify via getAllReminders - specific IDs not found
6. Post-delete: Verify via getReminder - individual lookups return null

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Captures reminder IDs before deletion
- Verifies specific reminders exist before delete
- Cross-verifies via getAllReminders
- Tests individual lookups return null
- Cannot pass if `getRemindersBySeries` always returns []
- Cannot pass if reminders were never created

**What specific changes would transform this test into its ideal form?**

Replace lines 230-241:
```typescript
it('series delete cascades reminders', async () => {
  await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 15, tag: 'a' });
  await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 30, tag: 'b' });

  let reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders.map(r => r.tag).sort()).toEqual(['a', 'b']);

  await deleteSeries(adapter, testSeriesId);

  reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders).toHaveLength(0);
});
```

With:
```typescript
it('series delete cascades reminders', async () => {
  const result1 = await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 15, tag: 'a' });
  const result2 = await createReminder(adapter, { seriesId: testSeriesId, minutesBefore: 30, tag: 'b' });
  if (!result1.ok || !result2.ok) throw new Error('Setup failed');

  const reminderId1 = result1.value.id;
  const reminderId2 = result2.value.id;

  let reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders).toHaveLength(2);
  expect(reminders.map(r => r.tag).sort()).toEqual(['a', 'b']);

  await deleteSeries(adapter, testSeriesId);

  // LAW 3: Verify cascade
  reminders = await getRemindersBySeries(adapter, testSeriesId);
  expect(reminders).toEqual([]);

  // Cross-verify via getAllReminders
  const allReminders = await adapter.getAllReminders();
  expect(allReminders.find(r => r.id === reminderId1)).toBeUndefined();
  expect(allReminders.find(r => r.id === reminderId2)).toBeUndefined();
});
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 225-269 to examine the exact violation at line 240 and full test context

3. **Search for cascade specification** - Used Grep tool with pattern `series.*delete.*cascade.*reminder|LAW.*cascade.*reminder|reminder.*cascade.*delete` (case insensitive) in notes directory, finding:
   - notes/test-plan-10.md: Test plan reference
   - notes/test-plan-04.md: Adapter test plan
   - notes/testing-spec-10-reminders.md: Reminder specification
   - notes/testing-spec-04-adapter.md: Adapter specification

4. **Search for LAW 3 and ON DELETE CASCADE** - Used Grep tool with pattern `LAW 3|Series.*cascade.*reminder|series_id.*ON DELETE CASCADE` in notes directory, finding multiple matches including:
   - notes/testing-spec-10-reminders.md:51: LAW 3
   - notes/testing-spec-04-adapter.md:346: LAW 53
   - notes/schema.md:199: ON DELETE CASCADE
   - notes/fuzz-testing-task-list.md:178: Property test reference

5. **Read reminders specification** - Used Read tool on notes/testing-spec-10-reminders.md lines 46-60 to find:
   - Lines 49-53: LAW 1-4 including LAW 3 about cascade

6. **Read adapter specification** - Used Read tool on notes/testing-spec-04-adapter.md lines 340-359 to find:
   - Line 346: LAW 53 - Series deletion cascades to reminders

7. **Read database schema** - Used Read tool on notes/schema.md lines 195-209 to find:
   - Lines 197-202: CREATE TABLE reminder definition
   - Line 199: series_id with ON DELETE CASCADE

8. **Search test plan reference** - Used Grep tool with pattern `series.*delete.*cascades.*reminders|cascade.*reminders` in notes/test-plan-10.md, finding:
   - Line 45: "series delete cascades reminders | delete series | Reminders deleted | LAW 3"

---

## Violation #30: tests/10-reminders.test.ts:266

**Test Name:** `reminder not yet due`

**Violation Line:**
```typescript
expect(forOurInstance).toHaveLength(0); // Not yet due - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 5 from the reminders specification: "Only returns reminders where fireTime ≤ asOf" (notes/testing-spec-10-reminders.md:81). A reminder whose fire time is in the future (relative to the query time) should NOT appear in the pending reminders list.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created with minutesBefore=15 (lines 252-256)
2. The series instance is at 09:00, so fireTime = 09:00 - 15min = 08:45
3. Query is made at 08:30 (asOf='2024-01-15T08:30:00') which is BEFORE fireTime
4. Since 08:30 < 08:45, the reminder should NOT be in pending results
5. The filtered result for our instance should be empty

**Why does this specific test matter?**

Reminders should only trigger when they're due. Returning future reminders prematurely would:
- Alert users too early
- Create confusing UI showing reminders that shouldn't fire yet
- Potentially cause actions before they're needed

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that the filtering logic is correct
2. It doesn't verify that the reminder WOULD appear if queried later
3. It doesn't verify the fire time calculation
4. Could pass if `getPendingReminders` always returns `[]`

It could pass when:
- `getPendingReminders` is broken
- The reminder was never created successfully
- The series has no instances on that date
- The filtering is on wrong criteria

**Why does getting it right matter?**

For medically fragile people, premature reminder delivery could:
- Cause confusion about when medications are due
- Lead to early administration of time-sensitive treatments
- Create alert fatigue from too-early notifications

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 5** - notes/testing-spec-10-reminders.md:81 states "LAW 5: Only returns reminders where fireTime ≤ asOf"

2. **getPendingReminders Definition** - notes/testing-spec-10-reminders.md:66-75 defines the algorithm:
   ```
   getPendingReminders(asOf) =
     let instances = getAllScheduledInstances(near future window)
     let reminders = getAllReminders()
     [
       for each instance i
       for each reminder r where r.seriesId = i.seriesId
       let fireTime = addMinutes(i.scheduledTime, -r.minutesBefore)
       if fireTime ≤ asOf AND not isAcknowledged(r.id, i.instanceDate)
       yield { ... }
     ]
   ```

3. **Fire Time Calculation** - notes/testing-spec-10-reminders.md:72 shows `fireTime = addMinutes(i.scheduledTime, -r.minutesBefore)`

4. **Test Plan Reference** - notes/test-plan-10.md:55 states "reminder not yet due | fireTime > asOf | Not in pending | LAW 5"

5. **PendingReminder Type** - notes/testing-spec-10-reminders.md:25-31 defines:
   ```
   type PendingReminder = {
     reminderId: ReminderId
     seriesId: SeriesId
     instanceDate: LocalDate
     fireTime: LocalDateTime    // computed: instance time - minutesBefore
     tag: string
   }
   ```

6. **LAW 18** - notes/testing-spec-10-reminders.md:166 states "LAW 18: fireTime < instance.scheduledTime (unless minutesBefore = 0)"

7. **INV 1** - notes/testing-spec-10-reminders.md:178 states "INV 1: minutesBefore ≥ 0"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify both exclusion at early time AND inclusion at correct time:

```typescript
it('reminder not yet due', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error('Setup failed');

  const instanceDate = parseDate('2024-01-15');
  const instanceTime = parseDateTime('2024-01-15T09:00:00');  // from series setup
  const fireTime = parseDateTime('2024-01-15T08:45:00');  // 09:00 - 15min

  // Verify reminder exists
  const reminder = await getReminder(adapter, createResult.value.id);
  expect(reminder).not.toBeNull();
  expect(reminder?.minutesBefore).toBe(15);

  // Query at 08:30 - before fire time (08:45)
  const earlyQuery = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:30:00'),
    range: { start: instanceDate, end: instanceDate },
  });

  // LAW 5: fireTime > asOf → not in pending
  const forOurInstanceEarly = earlyQuery.filter(p => p.instanceDate === instanceDate);
  expect(forOurInstanceEarly).toEqual([]);

  // Now verify it DOES appear at the correct time (boundary test)
  const onTimeQuery = await getPendingReminders(adapter, {
    asOf: fireTime,  // Exactly at fire time
    range: { start: instanceDate, end: instanceDate },
  });

  const forOurInstanceOnTime = onTimeQuery.filter(p => p.instanceDate === instanceDate);
  expect(forOurInstanceOnTime).toHaveLength(1);
  expect(forOurInstanceOnTime[0]).toMatchObject({
    seriesId: testSeriesId,
    instanceDate: instanceDate,
    tag: 'test',
  });
  expect(forOurInstanceOnTime[0].fireTime).toBe(fireTime);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-query: Verify reminder exists with correct minutesBefore
2. Early query: `expect(forOurInstanceEarly).toEqual([])` - Not in pending at 08:30
3. On-time query: `expect(forOurInstanceOnTime).toHaveLength(1)` - In pending at 08:45
4. On-time query: Verify reminder properties (seriesId, instanceDate, tag, fireTime)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the reminder was created successfully
- Tests the boundary: excluded before fire time, included at fire time
- Validates the actual reminder data when it does appear
- Cannot pass if `getPendingReminders` always returns []
- Cannot pass if the fire time calculation is wrong

**What specific changes would transform this test into its ideal form?**

Add after line 256 (after createReminder):
```typescript
expect(createResult.ok).toBe(true);
if (!createResult.ok) throw new Error('Setup failed');

// Verify reminder exists
const reminder = await getReminder(adapter, createResult.value.id);
expect(reminder).not.toBeNull();
expect(reminder?.minutesBefore).toBe(15);
```

Replace lines 265-266:
```typescript
const forOurInstance = pending.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(forOurInstance).toHaveLength(0);
```

With:
```typescript
const forOurInstance = pending.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(forOurInstance).toEqual([]);

// Boundary test: verify it DOES appear at fire time
const onTimeQuery = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T08:45:00'),  // Fire time
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const atFireTime = onTimeQuery.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(atFireTime).toHaveLength(1);
expect(atFireTime[0].tag).toBe('test');
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 250-299 to examine the exact violation at line 266 and full test context

3. **Search for LAW 5 and pending reminders specification** - Used Grep tool with pattern `LAW 5|getPendingReminders|fireTime.*asOf|not yet due` (case insensitive) in notes directory, finding many files including testing-spec-10-reminders.md

4. **Search for LAW 5 specifically in reminders spec** - Used Grep tool with pattern `LAW 5.*fireTime|fireTime.*≤.*asOf|getPendingReminders.*asOf` in notes/testing-spec-10-reminders.md, finding:
   - Line 60: getPendingReminders signature
   - Line 66: getPendingReminders definition
   - Line 73: fireTime ≤ asOf condition
   - Line 81: LAW 5

5. **Read pending reminders specification** - Used Read tool on notes/testing-spec-10-reminders.md lines 55-94 to find:
   - Lines 60-75: getPendingReminders definition
   - Lines 78-86: Properties including LAW 5-9

6. **Search test plan reference** - Used Grep tool with pattern `reminder not yet due|fireTime.*asOf|LAW 5` in notes/test-plan-10.md, finding:
   - Line 55: "reminder not yet due | fireTime > asOf | Not in pending | LAW 5"
   - Line 56: "reminder exactly due | fireTime = asOf | In pending | LAW 5"
   - Line 57: "reminder past due | fireTime < asOf | In pending | LAW 5"

7. **Search for fire time calculation** - Used Grep tool with pattern `fireTime.*calculation|calculateFireTime|minutesBefore|addMinutes.*scheduledTime` in notes/testing-spec-10-reminders.md, finding:
   - Line 29: fireTime definition in PendingReminder type
   - Line 72: fireTime = addMinutes(i.scheduledTime, -r.minutesBefore)
   - Line 166: LAW 18 about fireTime < scheduledTime
   - Line 178: INV 1 about minutesBefore ≥ 0

---

