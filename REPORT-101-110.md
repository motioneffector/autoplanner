# REPORT-101-110: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #101-110 as specified in REPORT-SPEC.md.

---

## Violation #101: tests/fuzz/integration/stress.test.ts:4268

**Test Name:** `Property #467: genSolvableSchedule produces solvable inputs`

**Violation Line:**
```typescript
expect(typeof slot.start).toBe('number')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `genSolvableSchedule` produces valid solvable schedule inputs and that the solution slots have valid structure. Line 4268 checks that each slot's `start` field is a number.

**What functionality or behavior is it verifying?**

The test verifies:
1. Correct item count is generated (line 4247)
2. Fixed items have non-overlapping times (lines 4250-4259)
3. Solve succeeds (line 4264)
4. Solution slots have string itemId (line 4267)
5. Solution slots have number start (line 4268) - THIS IS THE VIOLATION
6. Solution slots have number end (line 4269)
7. All fixed items are placed (lines 4272-4275)

**Why does this specific test matter?**

Schedule solving assigns time slots to items. The `start` field represents when an item begins (minutes from midnight).

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('number')` assertion is weak because:
1. It only checks the type, not the value validity
2. Could pass with NaN, Infinity, or negative numbers
3. Doesn't verify start is within the expected window (480-1080, i.e., 8 AM to 6 PM)
4. Doesn't verify start < end (positive duration)
5. Doesn't verify alignment with item's earliest start constraint

**Why does getting it right matter?**

For medically fragile people:
- Scheduled medication times must be valid and within waking hours
- Invalid start times (NaN, negative) could crash the display
- Out-of-window times could schedule medications at inappropriate hours

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **TimeSlot interface** - tests/fuzz/integration/stress.test.ts:3945-3949:
   ```typescript
   interface TimeSlot {
     itemId: string
     start: number // minutes from midnight
     end: number
   }
   ```
   Comment on line 3947 indicates start is "minutes from midnight"

2. **ScheduleSolver.solve() creates slots** - tests/fuzz/integration/stress.test.ts:4079-4083:
   ```typescript
   solution.push({
     itemId: item.id,
     start: item.fixedTime!,
     end: item.fixedTime! + item.duration,
   })
   ```

3. **Window constraints** - tests/fuzz/integration/stress.test.ts:4101:
   ```typescript
   const availableSlots = this.computeAvailableSlots(solution, 480, 1080)
   ```
   Window is 480-1080 minutes (8 AM to 6 PM)

4. **Item earliest start** - tests/fuzz/integration/stress.test.ts:3986-3987:
   ```typescript
   earliestStart: 480, // 8 AM
   latestEnd: 1080, // 6 PM
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
for (const slot of result.solution!) {
  // Verify itemId references an actual input item
  const inputItem = items.find(i => i.id === slot.itemId)
  expect(inputItem).toBeDefined()

  // Verify start is valid minutes in day range
  expect(Number.isInteger(slot.start)).toBe(true)
  expect(slot.start).toBeGreaterThanOrEqual(480)  // 8 AM
  expect(slot.start).toBeLessThan(slot.end)       // Positive duration

  // Verify respects item's earliest start
  expect(slot.start).toBeGreaterThanOrEqual(inputItem!.earliestStart ?? 480)

  // Verify end is within window
  expect(slot.end).toBeLessThanOrEqual(1080)      // 6 PM
}
```

**What specific changes would transform this test into its ideal form?**

1. Replace `typeof slot.start).toBe('number')` with `Number.isInteger(slot.start)).toBe(true)`
2. Add range validation for window bounds (480-1080)
3. Add relationship check: start < end
4. Validate against item's constraint fields

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4255-4305 to examine the violation at line 4268

3. **Search for TimeSlot interface** - Used Grep tool with pattern "interface TimeSlot" to find definition at line 3945 with context showing start: number is minutes from midnight

4. **Read ScheduleSolver implementation** - Used Read tool on tests/fuzz/integration/stress.test.ts lines 4145-4205 to understand:
   - Lines 4145-4165: computeAvailableSlots with window 480-1080
   - Lines 4195-4204: findSlotForItem using effective start/end

---

## Violation #102: tests/fuzz/integration/stress.test.ts:4269

**Test Name:** `Property #467: genSolvableSchedule produces solvable inputs`

**Violation Line:**
```typescript
expect(typeof slot.end).toBe('number')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `genSolvableSchedule` produces valid solvable schedule inputs. Line 4269 checks that each solution slot's `end` field is a number type.

**What functionality or behavior is it verifying?**

The test verifies:
1. Correct item count is generated (line 4247)
2. Fixed items have non-overlapping times (lines 4250-4259)
3. Solve succeeds (line 4264)
4. Solution slots have string itemId (line 4267)
5. Solution slots have number start (line 4268)
6. Solution slots have number end (line 4269) - THIS IS THE VIOLATION
7. All fixed items are placed (lines 4272-4275)

**Why does this specific test matter?**

Schedule solving assigns time slots to items. The `end` field represents when an item finishes (minutes from midnight).

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('number')` assertion is weak because:
1. It only checks the type, not the value validity
2. Could pass with NaN, Infinity, or values less than start
3. Doesn't verify end is within the expected window (â‰¤1080, i.e., 6 PM)
4. Doesn't verify end > start (positive duration)
5. Doesn't verify end respects item's latestEnd constraint
6. Doesn't verify end = start + duration (correct calculation)

**Why does getting it right matter?**

For medically fragile people:
- Scheduled medication end times must be valid
- Invalid end times could cause overlapping schedules
- Duration validation ensures time slots are properly sized

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **TimeSlot interface** - tests/fuzz/integration/stress.test.ts:3945-3949:
   ```typescript
   interface TimeSlot {
     itemId: string
     start: number // minutes from midnight
     end: number
   }
   ```

2. **End time calculation in solve()** - tests/fuzz/integration/stress.test.ts:4082:
   ```typescript
   end: item.fixedTime! + item.duration,
   ```
   End is calculated as start + duration

3. **Duration usage** - tests/fuzz/integration/stress.test.ts:378:
   ```typescript
   const slotDuration = slot.end - slot.start
   ```
   Duration is derived from end - start

4. **Window constraint** - tests/fuzz/integration/stress.test.ts:3987:
   ```typescript
   latestEnd: 1080, // 6 PM
   ```
   Items specify latest end time

5. **End used in overlap check** - tests/fuzz/integration/stress.test.ts:4158:
   ```typescript
   current = Math.max(current, slot.end)
   ```
   End times affect available slot computation

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
for (const slot of result.solution!) {
  const inputItem = items.find(i => i.id === slot.itemId)
  expect(inputItem).toBeDefined()

  // Verify end is valid integer
  expect(Number.isInteger(slot.end)).toBe(true)

  // Verify positive duration: end > start
  expect(slot.end).toBeGreaterThan(slot.start)

  // Verify correct duration calculation
  expect(slot.end - slot.start).toBe(inputItem!.duration)

  // Verify end within window
  expect(slot.end).toBeLessThanOrEqual(inputItem!.latestEnd ?? 1080)
}
```

**What specific changes would transform this test into its ideal form?**

1. Replace `typeof slot.end).toBe('number')` with `Number.isInteger(slot.end)).toBe(true)`
2. Add `slot.end).toBeGreaterThan(slot.start)` for positive duration
3. Add duration correctness check: `slot.end - slot.start).toBe(item.duration)`
4. Add window bound check: `slot.end).toBeLessThanOrEqual(1080)`

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4235-4294 to examine the violation at line 4269

3. **Search for slot.end usage** - Used Grep tool with pattern "slot\.end" to find all occurrences:
   - Line 378: Duration calculation
   - Line 4158: Available slots computation
   - Line 4222, 4228, 4229: Slot splitting logic

4. **Read TimeSlot interface** - Used Read tool on tests/fuzz/integration/stress.test.ts lines 3940-3965 showing TimeSlot definition at lines 3945-3949

---

## Violation #103: tests/fuzz/integration/stress.test.ts:4290

**Test Name:** `Property #468: genUnsolvableSchedule produces unsolvable inputs`

**Violation Line:**
```typescript
expect(typeof result.conflicts![0]).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `genUnsolvableSchedule` produces inputs that the solver correctly identifies as unsolvable and returns appropriate conflict messages.

**What functionality or behavior is it verifying?**

The test verifies:
1. genUnsolvableSchedule returns items, constraints, and contradiction (line 4283)
2. Solve returns success: false (line 4287)
3. First conflict matches expected pattern (line 4289)
4. First conflict is a string (line 4290) - THIS IS THE VIOLATION
5. Contradiction is a string (line 4291)
6. Contradiction contains 'must' (line 4292)

**Why does this specific test matter?**

Unsolvable schedules need clear conflict messages to help users understand why scheduling failed.

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is redundant because:
1. Line 4289 already uses `.toMatch(/Item|slot|duration/)` on the same value
2. `.toMatch()` on a non-string would throw an error
3. If line 4289 passes, line 4290 is guaranteed to pass
4. The assertion adds no additional verification

**Why does getting it right matter?**

For medically fragile people:
- Scheduling conflicts must be clearly reported
- Users need to understand why a schedule can't be created
- Redundant tests obscure what's actually being verified

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/integration/stress.test.ts:4282-4293:
   - Line 4282: Test name "Property #468: genUnsolvableSchedule produces unsolvable inputs"
   - Line 4289: `expect(result.conflicts![0]).toMatch(/Item|slot|duration/)`
   - Line 4290: `expect(typeof result.conflicts![0]).toBe('string')` - redundant

2. **Conflict creation in solve()** - tests/fuzz/integration/stress.test.ts:4090, 4119, 4130:
   ```typescript
   conflicts.push(`Fixed items ${solution[i].itemId} and ${solution[j].itemId} overlap`)
   conflicts.push(`Item ${item.id}: earliest start + duration exceeds latest end`)
   conflicts.push(`No valid slot for item ${item.id}`)
   ```
   All conflicts are template strings, so always strings.

3. **genUnsolvableSchedule** - tests/fuzz/integration/stress.test.ts:4041-4063:
   - Creates known contradictory constraints
   - Line 4054: C must be before A
   - Line 4055: C must be after B
   - But B ends after A starts, creating contradiction

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
const result = ScheduleSolver.solve(items, constraints)

expect(result.success).toBe(false)
expect(result.conflicts).toBeDefined()
expect(result.conflicts!.length).toBeGreaterThan(0)

// Verify conflict message contains meaningful information
expect(result.conflicts![0]).toMatch(/Item|slot|duration|overlap|constraint/)

// Remove redundant typeof check - toMatch already verified it's a string

// Verify contradiction message is meaningful
expect(contradiction).toContain('must')
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 4290 entirely - it's redundant after line 4289
2. Add `result.conflicts!.length).toBeGreaterThan(0)` to verify conflicts exist
3. Consider verifying all conflicts, not just the first one

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4275-4315 to examine the violation at line 4290

3. **Search for conflicts.push** - Used Grep tool with pattern "conflicts\.push" to find all conflict creation:
   - Line 4090: Fixed items overlap message
   - Line 4119: Earliest start + duration exceeds latest end message
   - Line 4130: No valid slot message

4. **Analyze redundancy** - Line 4289 uses `.toMatch()` which would fail on non-string, making line 4290 redundant

---

## Violation #104: tests/fuzz/integration/stress.test.ts:4291

**Test Name:** `Property #468: genUnsolvableSchedule produces unsolvable inputs`

**Violation Line:**
```typescript
expect(typeof contradiction).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that `genUnsolvableSchedule` produces inputs that are correctly identified as unsolvable, with appropriate contradiction messages.

**What functionality or behavior is it verifying?**

The test verifies:
1. genUnsolvableSchedule returns items, constraints, and contradiction (line 4283)
2. Solve returns success: false (line 4287)
3. First conflict matches expected pattern (line 4289)
4. First conflict is a string (line 4290)
5. Contradiction is a string (line 4291) - THIS IS THE VIOLATION
6. Contradiction contains 'must' (line 4292)

**Why does this specific test matter?**

The contradiction field explains why a schedule is unsolvable.

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is redundant because:
1. Line 4292 uses `.toContain('must')` on the same `contradiction` value
2. `.toContain()` on a non-string would throw an error
3. If line 4292 passes, line 4291 is guaranteed to pass
4. The return type of genUnsolvableSchedule already declares `contradiction: string` (line 4044)

**Why does getting it right matter?**

For medically fragile people:
- Contradiction messages explain scheduling failures
- Redundant type checks obscure actual verification
- Real tests should verify content, not just type

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/integration/stress.test.ts:4282-4293:
   - Line 4283: Destructures `contradiction` from genUnsolvableSchedule()
   - Line 4291: `expect(typeof contradiction).toBe('string')` - redundant
   - Line 4292: `expect(contradiction).toContain('must')` - makes 4291 redundant

2. **genUnsolvableSchedule return type** - tests/fuzz/integration/stress.test.ts:4041-4044:
   ```typescript
   static genUnsolvableSchedule(): {
     items: ScheduleItem[]
     constraints: ScheduleConstraint[]
     contradiction: string
   }
   ```
   Return type already declares `contradiction: string`

3. **Contradiction value** - tests/fuzz/integration/stress.test.ts:4061:
   ```typescript
   contradiction: 'C must end before 9 AM but start after 11 AM',
   ```
   A string literal explaining the contradiction

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
const { items, constraints, contradiction } = ScheduleSolver.genUnsolvableSchedule()

const result = ScheduleSolver.solve(items, constraints)

expect(result.success).toBe(false)
expect(result.conflicts).toBeDefined()
expect(result.conflicts!.length).toBeGreaterThan(0)
expect(result.conflicts![0]).toMatch(/Item|slot|duration/)

// Remove redundant typeof checks
// Verify contradiction explains the problem meaningfully
expect(contradiction).toContain('must')
expect(contradiction).toContain('C') // References the conflicting item
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 4290 (redundant after line 4289's `.toMatch()`)
2. Remove line 4291 (redundant after line 4292's `.toContain()`)
3. Add verification that contradiction references the actual conflicting item

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4278-4307 to examine the violation at line 4291

3. **Search for genUnsolvableSchedule** - Used Grep tool with pattern "genUnsolvableSchedule" to find:
   - Line 4041: Function definition
   - Line 4283: Usage in test

4. **Read genUnsolvableSchedule implementation** - Used Read tool on tests/fuzz/integration/stress.test.ts lines 4038-4067:
   - Line 4044: Return type declares `contradiction: string`
   - Line 4061: Contradiction is a string literal

---

## Violation #105: tests/fuzz/integration/stress.test.ts:4336

**Test Name:** `Property #472: unsolvable inputs report conflicts`

**Violation Line:**
```typescript
expect(typeof conflict).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies that unsolvable schedule inputs generate descriptive conflict messages explaining what went wrong.

**What functionality or behavior is it verifying?**

The test verifies:
1. genUnsolvableSchedule provides unsolvable inputs (line 4329)
2. Solve returns success: false (line 4333)
3. Each conflict is a string (line 4336) - THIS IS THE VIOLATION
4. Each conflict matches expected pattern (line 4338)
5. At least one conflict references an 'Item' (line 4341)

**Why does this specific test matter?**

Conflict reporting helps users understand why scheduling failed.

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is redundant because:
1. Line 4338 uses `.toMatch()` on the same `conflict` variable
2. `.toMatch()` on a non-string would throw an error
3. If line 4338 passes, line 4336 is guaranteed to pass
4. All conflict messages are created via template strings (lines 4090, 4119, 4130)

**Why does getting it right matter?**

For medically fragile people:
- Conflict messages must be clear and actionable
- Redundant type checks obscure actual content verification
- Real tests should verify message content, not just type

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/integration/stress.test.ts:4328-4342:
   - Line 4328: Test name "Property #472: unsolvable inputs report conflicts"
   - Line 4335: Loop through conflicts
   - Line 4336: `expect(typeof conflict).toBe('string')` - redundant
   - Line 4338: `expect(conflict).toMatch(...)` - makes 4336 redundant

2. **Conflict creation in solve()** - tests/fuzz/integration/stress.test.ts:
   - Line 4090: `conflicts.push(\`Fixed items ${solution[i].itemId} and ${solution[j].itemId} overlap\`)`
   - Line 4119: `conflicts.push(\`Item ${item.id}: earliest start + duration exceeds latest end\`)`
   - Line 4130: `conflicts.push(\`No valid slot for item ${item.id}\`)`

   All conflicts are template strings containing "Item", "earliest", "duration", or "slot".

3. **Conflict usage** - tests/fuzz/integration/stress.test.ts:4341:
   ```typescript
   expect(result.conflicts!.some(c => c.includes('Item'))).toBe(true)
   ```
   Verifies at least one conflict mentions an Item.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
const result = ScheduleSolver.solve(items, constraints)

expect(result.success).toBe(false)
expect(result.conflicts).toBeDefined()
expect(result.conflicts!.length).toBeGreaterThan(0)

for (const conflict of result.conflicts!) {
  // Remove redundant typeof check
  // Verify conflict is descriptive
  expect(conflict).toMatch(/Item|earliest|latest|duration|slot|exceeds|overlap/)
  expect(conflict.length).toBeGreaterThan(10) // Minimum meaningful message
}

// Verify at least one conflict references an item
expect(result.conflicts!.some(c => c.includes('Item'))).toBe(true)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 4336 - redundant after line 4338's `.toMatch()`
2. Add minimum length check to ensure messages are meaningful
3. Add 'overlap' to the regex pattern (conflict messages include it)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4320-4370 to examine the violation at line 4336

3. **Search for conflicts usage** - Used Grep tool with pattern "conflicts!\.some" to find:
   - Line 4341: Check for 'Item' in conflicts
   - Line 4373: Check for 'overlap' in conflicts

4. **Read solve() conflict creation** - Used Read tool on tests/fuzz/integration/stress.test.ts lines 4085-4135:
   - Line 4090: Overlap conflict message
   - Line 4119: Duration exceeds message
   - Line 4130: No valid slot message

---

## Violation #106: tests/fuzz/integration/stress.test.ts:4644

**Test Name:** `Property #414: SQLite errors mapped to domain errors`

**Violation Line:**
```typescript
expect(typeof domainError.type).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that SQLite error codes are correctly mapped to domain-specific error types with meaningful messages.

**What functionality or behavior is it verifying?**

The test verifies:
1. Maps various SQLite error codes (lines 4628-4638)
2. domainError.type is a string (line 4644) - THIS IS THE VIOLATION
3. domainError.message is a string (line 4645)
4. Message contains word characters (line 4647)
5. Details contain original SQLite info (lines 4650-4651)
6. Type is one of the defined domain error types (line 4663)

**Why does this specific test matter?**

Error mapping translates low-level database errors into user-friendly domain errors.

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is redundant because:
1. Line 4663 uses `expect(validTypes).toContain(domainError.type)`
2. validTypes is `DomainErrorType[]` which is a string literal union
3. If domainError.type is in validTypes, it's guaranteed to be a string
4. The DomainError interface already declares `type: DomainErrorType` (line 4463)

**Why does getting it right matter?**

For medically fragile people:
- Database errors need clear, actionable error messages
- Constraint violations must explain what went wrong
- Type-checking is redundant when stronger enum validation exists

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **DomainErrorType definition** - tests/fuzz/integration/stress.test.ts:4453-4460:
   ```typescript
   type DomainErrorType =
     | 'NOT_FOUND'
     | 'ALREADY_EXISTS'
     | 'CONSTRAINT_VIOLATION'
     | 'INVALID_OPERATION'
     | 'DATABASE_ERROR'
     | 'LOCKED'
     | 'FOREIGN_KEY_VIOLATION'
   ```

2. **DomainError interface** - tests/fuzz/integration/stress.test.ts:4462-4466:
   ```typescript
   interface DomainError {
     type: DomainErrorType
     message: string
     details?: Record<string, unknown>
   }
   ```
   The `type` field is already typed as DomainErrorType.

3. **Test assertions** - tests/fuzz/integration/stress.test.ts:4644, 4663:
   - Line 4644: `expect(typeof domainError.type).toBe('string')` - redundant
   - Line 4663: `expect(validTypes).toContain(domainError.type)` - stronger validation

4. **SQLiteErrorMapper.mapError()** - tests/fuzz/integration/stress.test.ts:4486-4514:
   Returns DomainError with type set to one of the valid DomainErrorType values.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
const domainError = SQLiteErrorMapper.mapError(sqliteCode, message)

// Remove redundant typeof checks - the enum validation is sufficient
const validTypes: DomainErrorType[] = [
  'NOT_FOUND', 'ALREADY_EXISTS', 'CONSTRAINT_VIOLATION',
  'INVALID_OPERATION', 'DATABASE_ERROR', 'LOCKED', 'FOREIGN_KEY_VIOLATION',
]
expect(validTypes).toContain(domainError.type)

// Verify message is meaningful
expect(domainError.message.length).toBeGreaterThan(5)
expect(domainError.message).toMatch(/\w+/)

// Verify details preserved original info
expect(domainError.details?.sqliteCode).toBe(sqliteCode)
expect(domainError.details?.originalMessage).toBe(message)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 4644 (`typeof domainError.type).toBe('string')`) - redundant
2. Remove line 4645 (`typeof domainError.message).toBe('string')`) - toMatch already verifies
3. Add minimum message length check for meaningful messages

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4620-4670 to examine the violation at line 4644

3. **Search for SQLiteErrorMapper** - Used Grep tool with pattern "class SQLiteErrorMapper" to find definition at line 4471

4. **Read type definitions** - Used Read tool on tests/fuzz/integration/stress.test.ts lines 4455-4515:
   - Lines 4453-4460: DomainErrorType union type
   - Lines 4462-4466: DomainError interface with type: DomainErrorType
   - Lines 4486-4514: mapError implementation

---

## Violation #107: tests/fuzz/integration/stress.test.ts:4645

**Test Name:** `Property #414: SQLite errors mapped to domain errors`

**Violation Line:**
```typescript
expect(typeof domainError.message).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that SQLite error codes are correctly mapped to domain-specific errors with meaningful message strings.

**What functionality or behavior is it verifying?**

The test verifies:
1. Maps various SQLite error codes (lines 4628-4638)
2. domainError.type is a string (line 4644)
3. domainError.message is a string (line 4645) - THIS IS THE VIOLATION
4. Message contains word characters (line 4647)
5. Details contain original SQLite info (lines 4650-4651)
6. Type is one of the defined domain error types (line 4663)

**Why does this specific test matter?**

Error messages must be meaningful strings that help users understand what went wrong.

**What are the consequences if this test is wrong or weak?**

The `typeof...toBe('string')` assertion is redundant because:
1. Line 4647 uses `expect(domainError.message).toMatch(/\w+/)`
2. `.toMatch()` on a non-string would throw an error
3. If line 4647 passes, line 4645 is guaranteed to pass
4. The DomainError interface already declares `message: string` (line 4464)

**Why does getting it right matter?**

For medically fragile people:
- Error messages must clearly explain what went wrong
- Redundant type checks obscure the actual content verification
- Real tests should verify message content, not just type

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **DomainError interface** - tests/fuzz/integration/stress.test.ts:4462-4466:
   ```typescript
   interface DomainError {
     type: DomainErrorType
     message: string
     details?: Record<string, unknown>
   }
   ```
   The `message` field is already typed as `string`.

2. **Test assertions** - tests/fuzz/integration/stress.test.ts:4645, 4647:
   - Line 4645: `expect(typeof domainError.message).toBe('string')` - redundant
   - Line 4647: `expect(domainError.message).toMatch(/\w+/)` - makes 4645 redundant

3. **Error message examples from mapError** - tests/fuzz/integration/stress.test.ts:
   - Line 4491: `'A record with this identifier already exists'`
   - Line 4498: `'Referenced record does not exist'`
   - Line 4505: `'Required field is missing'`
   - Line 4512: `'Database constraint violated'`

   All messages are string literals.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
const domainError = SQLiteErrorMapper.mapError(sqliteCode, message)

// Remove redundant typeof check
// Verify message is meaningful with content check
expect(domainError.message).toMatch(/\w+/)
expect(domainError.message.length).toBeGreaterThan(10) // Meaningful minimum

// Verify details preserved
expect(domainError.details?.sqliteCode).toBe(sqliteCode)
expect(domainError.details?.originalMessage).toBe(message)

// Verify type is valid
const validTypes: DomainErrorType[] = [...]
expect(validTypes).toContain(domainError.type)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 4645 - redundant after line 4647's `.toMatch()`
2. Add minimum message length check (e.g., > 10 characters)
3. Consider verifying message doesn't contain internal codes/jargon

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/integration/stress.test.ts lines 4625-4675 to examine the violation at line 4645

3. **Search for DomainError interface** - Used Grep tool with pattern "interface DomainError" with context:
   - Lines 4462-4466: DomainError interface with `message: string`

4. **Analyze assertion sequence** - Line 4647 uses `.toMatch()` which implicitly verifies the value is a string, making line 4645 redundant

---

## Violation #108: tests/fuzz/invariants/invariants.test.ts:49

**Test Name:** `Property #417: valid dates pass dateIsValid`

**Violation Line:**
```typescript
expect(result.violations).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that all dates generated by `localDateGen()` pass the `dateIsValid` invariant checker, meaning they have valid year/month/day combinations.

**What functionality or behavior is it verifying?**

The test verifies:
1. Result passed is true (line 48)
2. Result violations is empty array (line 49) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Date validation is critical for a scheduling system - invalid dates could cause crashes or incorrect scheduling.

**What are the consequences if this test is wrong or weak?**

The `.toEqual([])` assertion is weak because:
1. It only confirms the array is empty
2. Provides poor error messages when it fails
3. Line 48 already confirms `result.passed` is true
4. If `passed` is true, violations is guaranteed empty (per the implementation at index.ts:82)
5. The assertion is redundant given line 48

**Why does getting it right matter?**

For medically fragile people:
- Invalid dates could cause medication scheduling failures
- Feb 30 or Month 13 dates could crash the system
- Dates must be valid before any scheduling logic

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/invariants/invariants.test.ts:44-51:
   - Line 44: Test name "Property #417: valid dates pass dateIsValid"
   - Line 48: `expect(result.passed).toBe(true)`
   - Line 49: `expect(result.violations).toEqual([])` - redundant

2. **InvariantCheckResult interface** - tests/fuzz/invariants/index.ts:32-35:
   ```typescript
   export interface InvariantCheckResult {
     passed: boolean
     violations: InvariantViolation[]
   }
   ```

3. **dateIsValid return** - tests/fuzz/invariants/index.ts:82:
   ```typescript
   return { passed: violations.length === 0, violations }
   ```
   The `passed` field is derived from `violations.length === 0`. If passed is true, violations is guaranteed empty.

4. **dateIsValid validation** - tests/fuzz/invariants/index.ts:50-73:
   - Validates month in range [1, 12]
   - Validates day >= 1
   - Validates day <= lastDayOfMonth

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
fc.assert(
  fc.property(localDateGen(), (date) => {
    const result = dateIsValid(date)

    // Primary assertion - passed should be true
    expect(result.passed).toBe(true)

    // If we want to verify violations, use a descriptive assertion
    if (result.violations.length > 0) {
      // This provides better error context
      throw new Error(`Expected no violations but got: ${JSON.stringify(result.violations)}`)
    }
  })
)
```

Or simply remove the redundant assertion:

```typescript
fc.assert(
  fc.property(localDateGen(), (date) => {
    const result = dateIsValid(date)
    expect(result.passed).toBe(true)
    // Remove redundant toEqual([]) - passed: true already guarantees this
  })
)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 49 - it's redundant since line 48 already verifies `passed: true`
2. If violations check is desired, use a custom assertion with better error messages
3. Could add specific checks on the generated date (format, range)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/invariants/invariants.test.ts lines 1-80 to examine the violation at line 49

3. **Search for dateIsValid** - Used Grep tool with pattern "export.*dateIsValid" to find definition in tests/fuzz/invariants/index.ts

4. **Read dateIsValid implementation** - Used Read tool on tests/fuzz/invariants/index.ts lines 1-83:
   - Lines 32-35: InvariantCheckResult interface
   - Lines 44-82: dateIsValid function
   - Line 82: `passed: violations.length === 0` - proves redundancy

---

## Violation #109: tests/fuzz/invariants/invariants.test.ts:75

**Test Name:** `Property #418: valid times pass timeIsValid`

**Violation Line:**
```typescript
expect(result.violations).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that all times generated by `localTimeGen()` pass the `timeIsValid` invariant checker, meaning they have valid hour/minute combinations (HH:MM format).

**What functionality or behavior is it verifying?**

The test verifies:
1. Result passed is true (line 74)
2. Result violations is empty array (line 75) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Time validation ensures all scheduled times are valid 24-hour format times (00:00 - 23:59).

**What are the consequences if this test is wrong or weak?**

The `.toEqual([])` assertion is weak because:
1. It only confirms the array is empty
2. Provides poor error messages when it fails
3. Line 74 already confirms `result.passed` is true
4. If `passed` is true, violations is guaranteed empty (per index.ts:121)
5. The assertion is redundant given line 74

**Why does getting it right matter?**

For medically fragile people:
- Invalid times (25:00, 12:60) could crash the scheduler
- Time validation prevents scheduling at impossible hours
- Medication times must be valid 24-hour times

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/invariants/invariants.test.ts:70-77:
   - Line 70: Test name "Property #418: valid times pass timeIsValid"
   - Line 74: `expect(result.passed).toBe(true)`
   - Line 75: `expect(result.violations).toEqual([])` - redundant

2. **timeIsValid implementation** - tests/fuzz/invariants/index.ts:88-121:
   - Line 92: Validates "HH:MM" format
   - Lines 105-110: Validates hours in range [0, 23]
   - Lines 113-118: Validates minutes in range [0, 59]
   - Line 121: `return { passed: violations.length === 0, violations }`

3. **InvariantCheckResult return** - tests/fuzz/invariants/index.ts:121:
   ```typescript
   return { passed: violations.length === 0, violations }
   ```
   The `passed` field is derived from `violations.length === 0`. If passed is true, violations is guaranteed empty.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
fc.assert(
  fc.property(localTimeGen(), (time) => {
    const result = timeIsValid(time)

    // Single assertion is sufficient
    expect(result.passed).toBe(true)

    // Optional: verify time format directly
    expect(time).toMatch(/^\d{2}:\d{2}$/)
  })
)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 75 - redundant since line 74 already verifies `passed: true`
2. Optionally add direct time format validation
3. If violations check is kept, use descriptive error reporting

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/invariants/invariants.test.ts lines 65-115 to examine the violation at line 75

3. **Search for timeIsValid** - Used Grep tool with pattern "function timeIsValid" to find definition at line 88

4. **Read timeIsValid implementation** - Used Read tool on tests/fuzz/invariants/index.ts lines 85-122:
   - Lines 88-121: timeIsValid function
   - Line 121: `passed: violations.length === 0` - proves redundancy

---

## Violation #110: tests/fuzz/invariants/invariants.test.ts:99

**Test Name:** `Property #419: valid dateTimes pass dateTimeIsValid`

**Violation Line:**
```typescript
expect(result.violations).toEqual([])
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that all date-times generated by `localDateTimeGen()` pass the `dateTimeIsValid` invariant checker, meaning they have valid date + time combinations.

**What functionality or behavior is it verifying?**

The test verifies:
1. Result passed is true (line 98)
2. Result violations is empty array (line 99) - THIS IS THE VIOLATION

**Why does this specific test matter?**

DateTime validation ensures all scheduled timestamps are valid ISO 8601 date-time values.

**What are the consequences if this test is wrong or weak?**

The `.toEqual([])` assertion is weak because:
1. It only confirms the array is empty
2. Provides poor error messages when it fails
3. Line 98 already confirms `result.passed` is true
4. If `passed` is true, violations is guaranteed empty (per index.ts:163)
5. The assertion is redundant given line 98

**Why does getting it right matter?**

For medically fragile people:
- Invalid date-times could cause scheduling failures
- Combined date+time validation catches edge cases
- Timestamps are critical for medication scheduling

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/invariants/invariants.test.ts:94-101:
   - Line 94: Test name "Property #419: valid dateTimes pass dateTimeIsValid"
   - Line 98: `expect(result.passed).toBe(true)`
   - Line 99: `expect(result.violations).toEqual([])` - redundant

2. **dateTimeIsValid implementation** - tests/fuzz/invariants/index.ts:127-163:
   - Line 131: Parses the dateTime
   - Lines 134-137: Validates date portion using dateIsValid
   - Lines 140-146: Validates hours in range [0, 23]
   - Lines 148-154: Validates minutes in range [0, 59]
   - Line 163: `return { passed: violations.length === 0, violations }`

3. **Composite validation** - tests/fuzz/invariants/index.ts:134-137:
   ```typescript
   const dateResult = dateIsValid(...)
   violations.push(...dateResult.violations)
   ```
   Reuses dateIsValid for the date portion.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
fc.assert(
  fc.property(localDateTimeGen(), (dateTime) => {
    const result = dateTimeIsValid(dateTime)

    // Single assertion is sufficient
    expect(result.passed).toBe(true)

    // Optional: verify dateTime format directly
    expect(dateTime).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/)
  })
)
```

**What specific changes would transform this test into its ideal form?**

1. Remove line 99 - redundant since line 98 already verifies `passed: true`
2. Optionally add direct dateTime format validation
3. If violations check is kept, provide better error context

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/invariants/invariants.test.ts lines 90-130 to examine the violation at line 99

3. **Search for dateTimeIsValid** - Used Grep tool with pattern "function dateTimeIsValid" to find definition at line 127

4. **Read dateTimeIsValid implementation** - Used Read tool on tests/fuzz/invariants/index.ts lines 124-165:
   - Lines 127-163: dateTimeIsValid function
   - Line 163: `passed: violations.length === 0` - proves redundancy

---
