# REPORT-121-130: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #121-130 as specified in REPORT-SPEC.md.

---

## Violation #121: tests/fuzz/properties/constraints.test.ts:374

**Test Name:** `Property #357: withinMinutes required iff type = mustBeWithin`

**Violation Line:**
```typescript
expect(typeof constraint.withinMinutes).toBe('number')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that the `withinMinutes` field is present on RelationalConstraint objects only when the constraint type is 'mustBeWithin'.

**What functionality or behavior is it verifying?**

The test verifies (lines 373-380):
1. When type is 'mustBeWithin': withinMinutes is a number (line 374) - THIS IS THE VIOLATION
2. When type is 'mustBeWithin': withinMinutes >= 1 (line 375)
3. When type is NOT 'mustBeWithin': withinMinutes is not in the object keys (line 379)

**Why does this specific test matter?**

RelationalConstraints define temporal relationships between tasks. The 'mustBeWithin' type requires a time window (withinMinutes), while other types don't need this parameter.

**What are the consequences if this test is wrong or weak?**

The `typeof constraint.withinMinutes).toBe('number')` assertion is weak because:
1. TypeScript already guarantees withinMinutes is a number when defined (it's typed as `number`)
2. Line 375 already checks `toBeGreaterThanOrEqual(1)` which is stronger
3. The typeof check is redundant given the stronger assertion on the next line
4. If line 375 passes, line 374 must also pass (but not vice versa)

**Why does getting it right matter?**

For medically fragile people:
- Constraints ensure proper task sequencing
- 'mustBeWithin' constraints ensure medication timing
- Invalid withinMinutes values could create impossible schedules

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/constraints.test.ts:369-383:
   ```typescript
   describe('Spec 10: Constraints - withinMinutes Validation', () => {
     it('Property #357: withinMinutes required iff type = mustBeWithin', () => {
       fc.assert(
         fc.property(relationalConstraintGen(), (constraint) => {
           if (constraint.type === 'mustBeWithin') {
             expect(typeof constraint.withinMinutes).toBe('number')  // weak
             expect(constraint.withinMinutes).toBeGreaterThanOrEqual(1)  // strong
           } else {
             expect(Object.keys(constraint)).not.toContain('withinMinutes')
           }
         })
       )
     })
   })
   ```

2. **RelationalConstraint interface** - tests/fuzz/lib/types.ts:209-215:
   ```typescript
   export interface RelationalConstraint {
     id: ConstraintId
     type: ConstraintType
     sourceTarget: Target
     destTarget: Target
     withinMinutes?: number // required iff type = 'mustBeWithin'
   }
   ```

3. **ConstraintType** - tests/fuzz/lib/types.ts:200-207:
   ```typescript
   export type ConstraintType =
     | 'mustBeOnSameDay'
     | 'cantBeOnSameDay'
     | 'mustBeNextTo'
     | 'cantBeNextTo'
     | 'mustBeBefore'
     | 'mustBeAfter'
     | 'mustBeWithin'
   ```

4. **relationalConstraintGen** - tests/fuzz/generators/constraints.ts:39-64:
   ```typescript
   export function relationalConstraintGen(options?: {...}): Arbitrary<RelationalConstraint> {
     // ...
     if (type === 'mustBeWithin') {
       constraint.withinMinutes = withinMinutes
     }
     // ...
   }
   ```
   The generator only adds withinMinutes for 'mustBeWithin' type.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #357: withinMinutes required iff type = mustBeWithin', () => {
  fc.assert(
    fc.property(relationalConstraintGen(), (constraint) => {
      if (constraint.type === 'mustBeWithin') {
        // Verify withinMinutes exists and has valid value
        expect(constraint.withinMinutes).toBeDefined()
        expect(constraint.withinMinutes).toBeGreaterThanOrEqual(1)

        // Optional: verify reasonable upper bound
        expect(constraint.withinMinutes).toBeLessThanOrEqual(1440)  // max 24 hours
      } else {
        // Verify withinMinutes is absent for non-mustBeWithin types
        expect(constraint.withinMinutes).toBeUndefined()
      }
    })
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Remove `typeof x).toBe('number')` - redundant with line 375
2. Replace with `.toBeDefined()` if existence check is desired
3. Keep the `.toBeGreaterThanOrEqual(1)` as the primary value check
4. Optionally add upper bound check for reasonable withinMinutes values
5. Use `.toBeUndefined()` instead of checking Object.keys() for cleaner syntax

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/constraints.test.ts lines 365-394 to examine the violation at line 374

3. **Search for relationalConstraintGen** - Used Grep tool with pattern "relationalConstraintGen" in tests/fuzz directory:
   - Definition at constraints.ts:39
   - Multiple usages throughout the codebase

4. **Search for RelationalConstraint interface** - Used Grep tool with pattern "interface RelationalConstraint" found at types.ts:209

5. **Read RelationalConstraint interface** - Used Read tool on tests/fuzz/lib/types.ts lines 200-225:
   - Lines 200-207: ConstraintType union
   - Lines 209-215: RelationalConstraint interface with withinMinutes?: number

6. **Read relationalConstraintGen implementation** - Used Read tool on tests/fuzz/generators/constraints.ts lines 35-65:
   - Lines 61-63: conditionally adds withinMinutes for 'mustBeWithin' type

---

## Violation #122: tests/fuzz/properties/constraints.test.ts:409

**Test Name:** `boundary constraints are well-formed`

**Violation Line:**
```typescript
expect(typeof constraint.withinMinutes).toBe('number')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that boundary constraint values generated by `boundaryConstraintGen()` are well-formed with valid fields.

**What functionality or behavior is it verifying?**

The test verifies (lines 397-414):
1. constraint.id matches /^constraint-/ (line 398)
2. sourceTarget has either tag or seriesId (lines 400-402)
3. destTarget has either tag or seriesId (lines 404-406)
4. When type is 'mustBeWithin': withinMinutes is a number (line 409) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Boundary constraints test edge cases like minimal withinMinutes (1 minute), large withinMinutes (24 hours), and self-referential targets.

**What are the consequences if this test is wrong or weak?**

The `typeof constraint.withinMinutes).toBe('number')` assertion is weak because:
1. TypeScript already guarantees withinMinutes is a number when defined
2. The typeof check doesn't verify the value is valid (e.g., positive)
3. It doesn't check against the boundary values being tested (1, 1440)
4. A stronger assertion would verify the value is within expected range

**Why does getting it right matter?**

For medically fragile people:
- Boundary constraints test extreme scheduling scenarios
- Invalid withinMinutes at boundaries could cause edge-case failures
- Boundary values (1 minute, 24 hours) have different scheduling implications

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/constraints.test.ts:394-415:
   ```typescript
   describe('Spec 10: Constraints - Boundary Values', () => {
     it('boundary constraints are well-formed', () => {
       fc.assert(
         fc.property(boundaryConstraintGen(), (constraint) => {
           // ...
           if (constraint.type === 'mustBeWithin') {
             expect(typeof constraint.withinMinutes).toBe('number')  // weak
           }
         }),
         { numRuns: 200 }
       )
     })
   })
   ```

2. **boundaryConstraintGen** - tests/fuzz/generators/constraints.ts:226-254:
   ```typescript
   export function boundaryConstraintGen(): Arbitrary<RelationalConstraint> {
     return fc.oneof(
       // Minimal withinMinutes
       fc.tuple(...).map(([id, source, dest]) => ({
         id,
         type: 'mustBeWithin' as const,
         sourceTarget: source,
         destTarget: dest,
         withinMinutes: 1,  // Boundary value: minimum
       })),

       // Large withinMinutes (full day)
       fc.tuple(...).map(([id, source, dest]) => ({
         // ...
         withinMinutes: 1440,  // Boundary value: maximum (24 hours)
       })),
       // ...other cases
     )
   }
   ```

3. **Target interface** - tests/fuzz/lib/types.ts:159-162:
   ```typescript
   export interface Target {
     tag?: string
     seriesId?: SeriesId
   }
   ```

4. **RelationalConstraint interface** - tests/fuzz/lib/types.ts:209-215:
   ```typescript
   export interface RelationalConstraint {
     id: ConstraintId
     type: ConstraintType
     sourceTarget: Target
     destTarget: Target
     withinMinutes?: number  // required iff type = 'mustBeWithin'
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('boundary constraints are well-formed', () => {
  fc.assert(
    fc.property(boundaryConstraintGen(), (constraint) => {
      expect(constraint.id).toMatch(/^constraint-/)

      // sourceTarget validation
      const hasSourceTag = 'tag' in constraint.sourceTarget
      const hasSourceSeriesId = 'seriesId' in constraint.sourceTarget
      expect(hasSourceTag || hasSourceSeriesId).toBe(true)

      // destTarget validation
      const hasDestTag = 'tag' in constraint.destTarget
      const hasDestSeriesId = 'seriesId' in constraint.destTarget
      expect(hasDestTag || hasDestSeriesId).toBe(true)

      if (constraint.type === 'mustBeWithin') {
        // Verify withinMinutes exists and is valid
        expect(constraint.withinMinutes).toBeDefined()
        expect(constraint.withinMinutes).toBeGreaterThanOrEqual(1)
        expect(constraint.withinMinutes).toBeLessThanOrEqual(1440)

        // For boundary test, verify we're hitting boundary values
        expect([1, 1440]).toContain(constraint.withinMinutes)
      }
    }),
    { numRuns: 200 }
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Remove `typeof x).toBe('number')` - TypeScript handles this
2. Add `.toBeDefined()` to verify existence
3. Add `.toBeGreaterThanOrEqual(1)` for minimum bound
4. Add `.toBeLessThanOrEqual(1440)` for maximum bound
5. For boundary tests specifically, verify boundary values are hit

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/constraints.test.ts lines 393-417 to examine the violation at line 409

3. **Search for boundaryConstraintGen** - Used Grep tool with pattern "boundaryConstraintGen" in tests/fuzz directory:
   - Definition at constraints.ts:226

4. **Read boundaryConstraintGen implementation** - Used Read tool on tests/fuzz/generators/constraints.ts lines 220-255:
   - Lines 228-235: Minimal withinMinutes = 1
   - Lines 237-244: Large withinMinutes = 1440 (24 hours)

5. **Search for Target interface** - Used Grep tool with pattern "interface Target" found at types.ts:159

6. **Read Target interface** - Used Read tool on tests/fuzz/lib/types.ts lines 156-170:
   - Lines 159-162: Target interface with optional tag and seriesId

---

## Violation #123: tests/fuzz/properties/instances.test.ts:124

**Test Name:** `Property #314: cancelInstance excludes from schedule`

**Violation Line:**
```typescript
expect(manager.getSchedule(seriesId).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `cancelInstance` properly excludes cancelled instances from the schedule returned by `getSchedule`.

**What functionality or behavior is it verifying?**

The test verifies (lines 110-128):
1. Before cancellation: schedule has 1 item for the series (line 117-119)
2. After cancellation: schedule length is 0 (line 124) - THIS IS THE VIOLATION
3. After cancellation: getInstance returns isCancelled = true (line 125)

**Why does this specific test matter?**

Instance cancellation is essential for removing tasks/medications that no longer need to be scheduled.

**What are the consequences if this test is wrong or weak?**

The `manager.getSchedule(seriesId).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error message just shows numbers, not array contents
4. The test doesn't verify WHAT was removed, just that the count changed

**Why does getting it right matter?**

For medically fragile people:
- Cancelled medications must not appear in the schedule
- Showing cancelled items could cause confusion or double-dosing
- The schedule is the source of truth for caregiver actions

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/instances.test.ts:109-128:
   ```typescript
   describe('Spec 5: Instances - Cancellation', () => {
     it('Property #314: cancelInstance excludes from schedule', () => {
       fc.assert(
         fc.property(seriesIdGen(), localDateGen(), localDateTimeGen(), (seriesId, date, time) => {
           const manager = new InstanceManager()
           manager.scheduleInstance(seriesId, date, time, 60)

           // Before cancellation
           const scheduleBefore = manager.getSchedule(seriesId)
           expect(scheduleBefore.length === 1 && scheduleBefore[0].seriesId === seriesId).toBe(true)
           expect(scheduleBefore[0].instanceDate).toBe(date)

           manager.cancelInstance(seriesId, date)

           // After cancellation
           expect(manager.getSchedule(seriesId).length).toBe(0)  // weak
           expect(manager.getInstance(seriesId, date)?.isCancelled).toBe(true)
         })
       )
     })
   ```

2. **getSchedule implementation** - tests/fuzz/properties/instances.test.ts:94-97:
   ```typescript
   getSchedule(seriesId: SeriesId): ScheduledInstance[] {
     return Array.from(this.instances.values())
       .filter((i) => i.seriesId === seriesId && !i.isCancelled)
   }
   ```
   Filters out cancelled instances.

3. **cancelInstance implementation** - tests/fuzz/properties/instances.test.ts:55-65:
   ```typescript
   cancelInstance(seriesId: SeriesId, date: LocalDate): void {
     const key = this.makeKey(seriesId, date)
     const instance = this.instances.get(key)
     if (!instance) {
       throw new Error('Instance not found')
     }
     if (instance.isCancelled) {
       throw new Error('Instance already cancelled')
     }
     instance.isCancelled = true
   }
   ```

4. **InstanceManager class** - tests/fuzz/properties/instances.test.ts:33-103

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #314: cancelInstance excludes from schedule', () => {
  fc.assert(
    fc.property(seriesIdGen(), localDateGen(), localDateTimeGen(), (seriesId, date, time) => {
      const manager = new InstanceManager()
      manager.scheduleInstance(seriesId, date, time, 60)

      // Before cancellation - verify what exists
      const scheduleBefore = manager.getSchedule(seriesId)
      expect(scheduleBefore).toHaveLength(1)
      expect(scheduleBefore[0].seriesId).toBe(seriesId)
      expect(scheduleBefore[0].instanceDate).toBe(date)
      expect(scheduleBefore[0].isCancelled).toBe(false)

      manager.cancelInstance(seriesId, date)

      // After cancellation - verify schedule is empty
      expect(manager.getSchedule(seriesId)).toEqual([])

      // Verify instance still exists but is marked cancelled
      const instance = manager.getInstance(seriesId, date)
      expect(instance).toBeDefined()
      expect(instance?.isCancelled).toBe(true)
    })
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Or use `.toHaveLength(0)` for better error messages
3. Add pre-cancellation check that isCancelled is false
4. Split compound assertion on line 118 into separate assertions
5. Use `.toBeDefined()` before checking isCancelled

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/instances.test.ts lines 105-135 to examine the violation at line 124

3. **Search for InstanceManager** - Used Grep tool with pattern "class InstanceManager" found at line 33

4. **Read InstanceManager class** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 30-80:
   - Lines 33-103: Full class definition
   - Lines 55-65: cancelInstance method
   - Lines 94-97: getSchedule method

5. **Search for getSchedule** - Used Grep tool with pattern "getSchedule" to find all usages:
   - Line 94: Method definition
   - Line 117, 124: Test usages

---

## Violation #124: tests/fuzz/properties/instances.test.ts:224

**Test Name:** `Property #321: restoreInstance un-cancels`

**Violation Line:**
```typescript
expect(manager.getSchedule(seriesId).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `restoreInstance` properly un-cancels a previously cancelled instance, making it appear again in the schedule.

**What functionality or behavior is it verifying?**

The test verifies (lines 216-234):
1. After scheduling then cancelling: instance is cancelled (line 223)
2. After cancellation: schedule length is 0 (line 224) - THIS IS THE VIOLATION
3. After restoration: instance is no longer cancelled (line 228)
4. After restoration: schedule has 1 item (line 230)

**Why does this specific test matter?**

Instance restoration allows undoing accidental cancellations or re-activating previously cancelled tasks.

**What are the consequences if this test is wrong or weak?**

The `manager.getSchedule(seriesId).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error message just shows numbers, not array contents
4. This assertion is verifying a precondition before restoration, not the main behavior

**Why does getting it right matter?**

For medically fragile people:
- Restored medications must reappear in the schedule
- Accidental cancellations must be recoverable
- The schedule must accurately reflect current state

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/instances.test.ts:215-234:
   ```typescript
   describe('Spec 5: Instances - Restoration', () => {
     it('Property #321: restoreInstance un-cancels', () => {
       fc.assert(
         fc.property(seriesIdGen(), localDateGen(), localDateTimeGen(), (seriesId, date, time) => {
           const manager = new InstanceManager()
           manager.scheduleInstance(seriesId, date, time, 60)
           manager.cancelInstance(seriesId, date)

           expect(manager.getInstance(seriesId, date)?.isCancelled).toBe(true)
           expect(manager.getSchedule(seriesId).length).toBe(0)  // weak

           manager.restoreInstance(seriesId, date)

           expect(manager.getInstance(seriesId, date)?.isCancelled).toBe(false)
           const schedule = manager.getSchedule(seriesId)
           expect(schedule.length === 1 && schedule[0].seriesId === seriesId).toBe(true)
           expect(schedule[0].instanceDate).toBe(date)
         })
       )
     })
   })
   ```

2. **restoreInstance implementation** - tests/fuzz/properties/instances.test.ts:79-92:
   ```typescript
   restoreInstance(seriesId: SeriesId, date: LocalDate): void {
     const key = this.makeKey(seriesId, date)
     const instance = this.instances.get(key)
     if (!instance) {
       throw new Error('Instance not found')
     }
     if (!instance.isCancelled) {
       // Restore on non-cancelled is a no-op
       return
     }
     instance.isCancelled = false
     // Clear any reschedule when restoring
     instance.rescheduledTo = undefined
   }
   ```

3. **getSchedule implementation** - tests/fuzz/properties/instances.test.ts:94-97:
   ```typescript
   getSchedule(seriesId: SeriesId): ScheduledInstance[] {
     return Array.from(this.instances.values())
       .filter((i) => i.seriesId === seriesId && !i.isCancelled)
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #321: restoreInstance un-cancels', () => {
  fc.assert(
    fc.property(seriesIdGen(), localDateGen(), localDateTimeGen(), (seriesId, date, time) => {
      const manager = new InstanceManager()
      manager.scheduleInstance(seriesId, date, time, 60)
      manager.cancelInstance(seriesId, date)

      // Verify cancelled state
      expect(manager.getInstance(seriesId, date)?.isCancelled).toBe(true)
      expect(manager.getSchedule(seriesId)).toEqual([])

      manager.restoreInstance(seriesId, date)

      // Verify restored state
      const restoredInstance = manager.getInstance(seriesId, date)
      expect(restoredInstance).toBeDefined()
      expect(restoredInstance?.isCancelled).toBe(false)
      expect(restoredInstance?.rescheduledTo).toBeUndefined()  // Verify rescheduleTo cleared

      const schedule = manager.getSchedule(seriesId)
      expect(schedule).toHaveLength(1)
      expect(schedule[0].seriesId).toBe(seriesId)
      expect(schedule[0].instanceDate).toBe(date)
    })
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Split compound assertion on line 230 into separate assertions
3. Add `.toBeDefined()` before checking restored instance properties
4. Verify that rescheduledTo is cleared after restoration (as per implementation)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/instances.test.ts lines 215-250 to examine the violation at line 224

3. **Search for restoreInstance** - Used Grep tool with pattern "restoreInstance" in tests/fuzz/properties/instances.test.ts:
   - Line 79: Method definition
   - Lines 216, 226, 243: Test usages

4. **Read restoreInstance implementation** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 77-96:
   - Lines 79-92: restoreInstance method
   - Lines 85-87: No-op for non-cancelled
   - Lines 89-91: Sets isCancelled = false, clears rescheduledTo

5. **Read getSchedule implementation** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 94-97:
   - Filters out cancelled instances

---

## Violation #125: tests/fuzz/properties/instances.test.ts:353

**Test Name:** `Property #360: instances respect series bounds`

**Violation Line:**
```typescript
expect(withinBounds.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that instances scheduled outside a series' date bounds are filtered out by `getScheduleWithinBounds`.

**What functionality or behavior is it verifying?**

The test verifies (lines 331-361):
1. Sets up a BoundedInstanceManager with start and end dates for bounds (lines 341-346)
2. Schedules an instance with a random date (line 347)
3. Gets the bounded schedule (line 349)
4. If instanceDate is outside bounds: schedule length is 0 (line 353) - THIS IS THE VIOLATION
5. If instanceDate is within bounds: schedule has the instance (lines 355-357)

**Why does this specific test matter?**

Series bounds define valid date ranges for a recurring task. Instances outside these bounds should not appear in the schedule.

**What are the consequences if this test is wrong or weak?**

The `withinBounds.length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error message shows numbers instead of array contents
4. The test doesn't verify WHY the array is empty (bounds filtering vs other reasons)

**Why does getting it right matter?**

For medically fragile people:
- Series bounds define valid medication periods (e.g., prescription dates)
- Showing instances outside bounds could cause dosing errors
- The bounded schedule must accurately reflect valid instances only

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/instances.test.ts:331-361:
   ```typescript
   describe('Spec 5: Instances - Bounds', () => {
     it('Property #360: instances respect series bounds', () => {
       fc.assert(
         fc.property(
           seriesIdGen(),
           localDateGen(), localDateGen(), localDateGen(),
           localDateTimeGen(),
           (seriesId, boundStart, boundEnd, instanceDate, time) => {
             const [startDate, endDate] = boundStart < boundEnd
               ? [boundStart, boundEnd] : [boundEnd, boundStart]

             const manager = new BoundedInstanceManager()
             manager.setSeriesBounds(seriesId, { startDate, endDate })
             manager.scheduleInstance(seriesId, instanceDate, time, 60)

             const withinBounds = manager.getScheduleWithinBounds(seriesId)

             if (instanceDate < startDate || instanceDate > endDate) {
               expect(withinBounds.length).toBe(0)  // weak
             } else {
               // ...
             }
           }
         )
       )
     })
   })
   ```

2. **BoundedInstanceManager class** - tests/fuzz/properties/instances.test.ts:306-328:
   ```typescript
   class BoundedInstanceManager extends InstanceManager {
     private seriesBounds: Map<SeriesId, SeriesBounds> = new Map()

     setSeriesBounds(seriesId: SeriesId, bounds: SeriesBounds): void {
       this.seriesBounds.set(seriesId, bounds)
     }

     isDateWithinBounds(seriesId: SeriesId, date: LocalDate): boolean {
       const bounds = this.seriesBounds.get(seriesId)
       if (!bounds) return true // No bounds = always valid
       if (bounds.startDate && date < bounds.startDate) return false
       if (bounds.endDate && date > bounds.endDate) return false
       return true
     }

     getScheduleWithinBounds(seriesId: SeriesId): ScheduledInstance[] {
       return this.getSchedule(seriesId).filter((i) =>
         this.isDateWithinBounds(seriesId, i.instanceDate)
       )
     }
   }
   ```

3. **SeriesBounds interface** - tests/fuzz/properties/instances.test.ts:301-304:
   ```typescript
   interface SeriesBounds {
     startDate?: LocalDate
     endDate?: LocalDate
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #360: instances respect series bounds', () => {
  fc.assert(
    fc.property(
      seriesIdGen(),
      localDateGen(), localDateGen(), localDateGen(),
      localDateTimeGen(),
      (seriesId, boundStart, boundEnd, instanceDate, time) => {
        const [startDate, endDate] = boundStart < boundEnd
          ? [boundStart, boundEnd] : [boundEnd, boundStart]

        const manager = new BoundedInstanceManager()
        manager.setSeriesBounds(seriesId, { startDate, endDate })
        manager.scheduleInstance(seriesId, instanceDate, time, 60)

        const withinBounds = manager.getScheduleWithinBounds(seriesId)
        const isOutsideBounds = instanceDate < startDate || instanceDate > endDate

        if (isOutsideBounds) {
          // Verify no instances appear when outside bounds
          expect(withinBounds).toEqual([])

          // Verify the instance still exists but is filtered
          const allInstances = manager.getSchedule(seriesId)
          expect(allInstances).toHaveLength(1)  // Proves filtering, not absence
        } else {
          expect(withinBounds).toHaveLength(1)
          expect(withinBounds[0].seriesId).toBe(seriesId)
          expect(withinBounds[0].instanceDate).toBe(instanceDate)
        }
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Add verification that the instance exists in unfiltered schedule
3. This proves the bounds filtering works, not that the instance was never created
4. Split compound assertion on line 355 into separate assertions
5. Extract isOutsideBounds to a named variable for clarity

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read REPORT-121-130.md** - Used Read tool to find where to append the analysis (lines 1-676)

3. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/instances.test.ts lines 340-389 to examine the violation at line 353

4. **Read BoundedInstanceManager class** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 300-340:
   - Lines 301-304: SeriesBounds interface
   - Lines 306-328: BoundedInstanceManager class
   - Lines 309-311: setSeriesBounds method
   - Lines 313-321: isDateWithinBounds method
   - Lines 323-327: getScheduleWithinBounds method

5. **Search for getScheduleWithinBounds** - Used Grep tool with pattern "getScheduleWithinBounds" in tests/fuzz/properties:
   - Line 323: Method definition
   - Lines 349, 374, 380, 401: Test usages

---

## Violation #126: tests/fuzz/properties/instances.test.ts:380

**Test Name:** `Property #361: cancelled instances excluded from bounded schedule`

**Violation Line:**
```typescript
expect(manager.getScheduleWithinBounds(seriesId).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that cancelled instances are excluded from the bounded schedule, even when no bounds are set.

**What functionality or behavior is it verifying?**

The test verifies (lines 363-384):
1. Creates a BoundedInstanceManager with no bounds set (lines 370-371)
2. Schedules an instance (line 372)
3. Verifies instance appears in bounded schedule before cancellation (lines 374-376)
4. Cancels the instance (line 378)
5. Verifies bounded schedule is empty after cancellation (line 380) - THIS IS THE VIOLATION

**Why does this specific test matter?**

This test ensures that the BoundedInstanceManager inherits the cancellation filtering behavior from the base InstanceManager class.

**What are the consequences if this test is wrong or weak?**

The `manager.getScheduleWithinBounds(seriesId).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of array contents
4. The test doesn't verify WHY the schedule is empty (cancellation vs bounds filtering)

**Why does getting it right matter?**

For medically fragile people:
- Cancelled medications must not appear in any schedule view
- The BoundedInstanceManager is likely used for date-range views
- Showing cancelled items in any view could cause dosing errors

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/instances.test.ts:363-384:
   ```typescript
   it('Property #361: cancelled instances excluded from bounded schedule', () => {
     fc.assert(
       fc.property(
         seriesIdGen(),
         localDateGen(),
         localDateTimeGen(),
         (seriesId, date, time) => {
           const manager = new BoundedInstanceManager()
           // No bounds set - all dates valid
           manager.scheduleInstance(seriesId, date, time, 60)

           const scheduleBefore = manager.getScheduleWithinBounds(seriesId)
           expect(scheduleBefore.length === 1 && scheduleBefore[0].seriesId === seriesId).toBe(true)
           expect(scheduleBefore[0].instanceDate).toBe(date)

           manager.cancelInstance(seriesId, date)

           expect(manager.getScheduleWithinBounds(seriesId).length).toBe(0)  // weak
         }
       )
     )
   })
   ```

2. **cancelInstance implementation** - tests/fuzz/properties/instances.test.ts:55-65:
   ```typescript
   cancelInstance(seriesId: SeriesId, date: LocalDate): void {
     const key = this.makeKey(seriesId, date)
     const instance = this.instances.get(key)
     if (!instance) {
       throw new Error('Instance not found')
     }
     if (instance.isCancelled) {
       throw new Error('Instance already cancelled')
     }
     instance.isCancelled = true
   }
   ```

3. **getSchedule implementation (base class)** - tests/fuzz/properties/instances.test.ts:94-97:
   ```typescript
   getSchedule(seriesId: SeriesId): ScheduledInstance[] {
     return Array.from(this.instances.values())
       .filter((i) => i.seriesId === seriesId && !i.isCancelled)
   }
   ```

4. **getScheduleWithinBounds implementation** - tests/fuzz/properties/instances.test.ts:323-327:
   ```typescript
   getScheduleWithinBounds(seriesId: SeriesId): ScheduledInstance[] {
     return this.getSchedule(seriesId).filter((i) =>
       this.isDateWithinBounds(seriesId, i.instanceDate)
     )
   }
   ```

The filtering chain: getScheduleWithinBounds → getSchedule (filters out cancelled) → isDateWithinBounds filter.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #361: cancelled instances excluded from bounded schedule', () => {
  fc.assert(
    fc.property(
      seriesIdGen(),
      localDateGen(),
      localDateTimeGen(),
      (seriesId, date, time) => {
        const manager = new BoundedInstanceManager()
        // No bounds set - all dates valid
        manager.scheduleInstance(seriesId, date, time, 60)

        // Before cancellation - verify instance is visible
        const scheduleBefore = manager.getScheduleWithinBounds(seriesId)
        expect(scheduleBefore).toHaveLength(1)
        expect(scheduleBefore[0].seriesId).toBe(seriesId)
        expect(scheduleBefore[0].instanceDate).toBe(date)
        expect(scheduleBefore[0].isCancelled).toBe(false)

        manager.cancelInstance(seriesId, date)

        // After cancellation - verify schedule is empty
        expect(manager.getScheduleWithinBounds(seriesId)).toEqual([])

        // Verify instance still exists but is cancelled
        const instance = manager.getInstance(seriesId, date)
        expect(instance).toBeDefined()
        expect(instance?.isCancelled).toBe(true)
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Split compound assertion on line 375 into separate assertions
3. Add pre-cancellation check that isCancelled is false
4. Verify instance still exists after cancellation (proves filtering, not deletion)
5. Use `.toHaveLength(1)` instead of compound `.length === 1 &&` expression

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/instances.test.ts lines 360-404 to examine the violation at line 380

3. **Search for cancelInstance** - Used Grep tool with pattern "cancelInstance" in tests/fuzz/properties/instances.test.ts:
   - Line 55: Method definition
   - Lines 121, 136, 139, 150, 160, 162, 192, 221, 277, 378, etc.: Test usages

4. **Read cancelInstance and getSchedule implementations** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 50-100:
   - Lines 55-65: cancelInstance method (sets isCancelled = true)
   - Lines 94-97: getSchedule method (filters out cancelled instances)

5. **Read getScheduleWithinBounds implementation** - Used Read tool on tests/fuzz/properties/instances.test.ts lines 323-327:
   - Calls getSchedule() then filters by bounds
   - Inherited cancellation filtering from base class

---

## Violation #127: tests/fuzz/properties/links.test.ts:260

**Test Name:** `Property #344: unlink then delete parent succeeds`

**Violation Line:**
```typescript
expect(manager.getChildren(parentId).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that after deleting a link, the parent series no longer has the child in its children list.

**What functionality or behavior is it verifying?**

The test verifies (lines 241-263):
1. Creates a link between parent and child (lines 248-254)
2. Deletes the link using deleteLink(childId) (line 257)
3. Verifies the parent has no children (line 260) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Link management is essential for scheduling dependent tasks. If a parent-child relationship persists after deletion, it could cause scheduling confusion.

**What are the consequences if this test is wrong or weak?**

The `manager.getChildren(parentId).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of array contents
4. The test doesn't verify the child was actually in the list before deletion

**Why does getting it right matter?**

For medically fragile people:
- Links define dependencies between tasks (e.g., "take medication X after meal Y")
- Deleted links must be fully removed from both sides of the relationship
- Orphan link references could cause scheduling errors

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/links.test.ts:241-263:
   ```typescript
   it('Property #344: unlink then delete parent succeeds', () => {
     fc.assert(
       fc.property(seriesIdGen(), seriesIdGen(), (parentId, childId) => {
         fc.pre(parentId !== childId)

         const manager = new LinkManager()

         manager.createLink({
           parentSeriesId: parentId,
           childSeriesId: childId,
           targetDistance: 30,
           earlyWobble: 5,
           lateWobble: 5,
         })

         // Unlink first
         manager.deleteLink(childId)

         // Now parent has no children
         expect(manager.getChildren(parentId).length).toBe(0)  // weak
       })
     )
   })
   ```

2. **LinkManager class** - tests/fuzz/properties/links.test.ts:17-92:
   ```typescript
   class LinkManager {
     private links: Map<SeriesId, Link> = new Map() // childId -> Link
     private children: Map<SeriesId, Set<SeriesId>> = new Map() // parentId -> childIds
     // ...
   }
   ```

3. **deleteLink implementation** - tests/fuzz/properties/links.test.ts:52-60:
   ```typescript
   deleteLink(childId: SeriesId): boolean {
     const link = this.links.get(childId)
     if (!link) return false

     this.links.delete(childId)
     this.children.get(link.parentSeriesId)?.delete(childId)

     return true
   }
   ```

4. **getChildren implementation** - tests/fuzz/properties/links.test.ts:66-68:
   ```typescript
   getChildren(parentId: SeriesId): SeriesId[] {
     return Array.from(this.children.get(parentId) ?? [])
   }
   ```

5. **createLink implementation** - tests/fuzz/properties/links.test.ts:21-46:
   ```typescript
   createLink(link: Link): boolean {
     // ... validation ...
     this.links.set(link.childSeriesId, link)

     if (!this.children.has(link.parentSeriesId)) {
       this.children.set(link.parentSeriesId, new Set())
     }
     this.children.get(link.parentSeriesId)!.add(link.childSeriesId)

     return true
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #344: unlink then delete parent succeeds', () => {
  fc.assert(
    fc.property(seriesIdGen(), seriesIdGen(), (parentId, childId) => {
      fc.pre(parentId !== childId)

      const manager = new LinkManager()

      const created = manager.createLink({
        parentSeriesId: parentId,
        childSeriesId: childId,
        targetDistance: 30,
        earlyWobble: 5,
        lateWobble: 5,
      })
      expect(created).toBe(true)

      // Before deletion - verify child is in parent's children
      expect(manager.getChildren(parentId)).toContain(childId)
      expect(manager.hasLink(childId)).toBe(true)

      // Delete the link
      const deleted = manager.deleteLink(childId)
      expect(deleted).toBe(true)

      // After deletion - verify parent has no children
      expect(manager.getChildren(parentId)).toEqual([])
      expect(manager.hasLink(childId)).toBe(false)
      expect(manager.getParent(childId)).toBeUndefined()
    })
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Verify createLink returns true (link was created)
3. Add pre-deletion verification that child was in parent's children
4. Verify deleteLink returns true (link was deleted)
5. Verify both sides of the relationship are cleared (hasLink, getParent)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/links.test.ts lines 245-269 to examine the violation at line 260

3. **Search for LinkManager class** - Used Grep tool with pattern "class.*Manager|LinkManager" in tests/fuzz/properties/links.test.ts:
   - Line 17: class LinkManager definition

4. **Read LinkManager class** - Used Read tool on tests/fuzz/properties/links.test.ts lines 1-100:
   - Lines 17-92: Full LinkManager class definition
   - Lines 18-19: Private maps for links and children
   - Lines 21-46: createLink method
   - Lines 52-60: deleteLink method
   - Lines 66-68: getChildren method

5. **Read test context** - Used Read tool on tests/fuzz/properties/links.test.ts lines 220-269:
   - Lines 241-263: Test "Property #344: unlink then delete parent succeeds"

---

## Violation #128: tests/fuzz/properties/pattern-crud.test.ts:155

**Test Name:** `Property #265: deletePattern removes from series`

**Violation Line:**
```typescript
expect(manager.getPatternsForSeries(seriesId)).toEqual([])
```

**Note:** This line appears to already use the correct assertion pattern (`.toEqual([])`). The related weak assertion is on line 150: `expect(patternsBefore.length === 1 && patternsBefore[0].type === pattern.type).toBe(true)` which uses a compound boolean expression.

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `deletePattern` removes the pattern from the series association.

**What functionality or behavior is it verifying?**

The test verifies (lines 143-158):
1. Creates a pattern for a series (line 147)
2. Verifies the pattern exists before deletion (lines 149-150)
3. Deletes the pattern (line 152)
4. Verifies deletePattern returns true (line 153)
5. Verifies the pattern is undefined (line 154)
6. Verifies getPatternsForSeries returns empty array (line 155) - THIS IS THE CITED VIOLATION

**Why does this specific test matter?**

Pattern deletion is essential for removing scheduling rules that are no longer needed.

**What are the consequences if this test is wrong or weak?**

Line 155 uses `.toEqual([])` which is actually the correct form. However, line 150 has a weak assertion:
- `patternsBefore.length === 1 && patternsBefore[0].type === pattern.type).toBe(true)` is a compound boolean
- If this fails, you only know "something was false" not which condition failed
- Should be split into separate assertions

**Why does getting it right matter?**

For medically fragile people:
- Patterns define scheduling rules for medications
- Deleted patterns must not continue to generate instances
- The getPatternsForSeries result drives schedule generation

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/pattern-crud.test.ts:143-158:
   ```typescript
   it('Property #265: deletePattern removes from series', () => {
     fc.assert(
       fc.property(seriesIdGen(), simplePatternGen(), (seriesId, pattern) => {
         const manager = new PatternManager()
         const patternId = manager.createPattern(seriesId, pattern)

         const patternsBefore = manager.getPatternsForSeries(seriesId)
         expect(patternsBefore.length === 1 && patternsBefore[0].type === pattern.type).toBe(true)  // weak

         const deleted = manager.deletePattern(patternId)
         expect(deleted).toBe(true)
         expect(manager.getPattern(patternId)).toBeUndefined()
         expect(manager.getPatternsForSeries(seriesId)).toEqual([])  // cited but actually correct
       })
     )
   })
   ```

2. **PatternManager class** - tests/fuzz/properties/pattern-crud.test.ts:23-63:
   ```typescript
   class PatternManager {
     private patterns: Map<string, Pattern> = new Map()
     private seriesPatterns: Map<SeriesId, Set<string>> = new Map()
     private idCounter = 0

     createPattern(seriesId: SeriesId, pattern: Pattern): string {
       const id = `pattern-${++this.idCounter}`
       this.patterns.set(id, pattern)
       // ...
       return id
     }

     deletePattern(id: string): boolean {
       if (!this.patterns.has(id)) return false
       this.patterns.delete(id)
       for (const [, patternIds] of this.seriesPatterns) {
         patternIds.delete(id)
       }
       return true
     }

     getPatternsForSeries(seriesId: SeriesId): Pattern[] {
       const patternIds = this.seriesPatterns.get(seriesId) ?? new Set()
       return Array.from(patternIds)
         .map((id) => this.patterns.get(id))
         .filter((p): p is Pattern => p !== undefined)
     }
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #265: deletePattern removes from series', () => {
  fc.assert(
    fc.property(seriesIdGen(), simplePatternGen(), (seriesId, pattern) => {
      const manager = new PatternManager()
      const patternId = manager.createPattern(seriesId, pattern)

      // Before deletion - verify pattern exists
      const patternsBefore = manager.getPatternsForSeries(seriesId)
      expect(patternsBefore).toHaveLength(1)
      expect(patternsBefore[0].type).toBe(pattern.type)

      // Delete the pattern
      const deleted = manager.deletePattern(patternId)
      expect(deleted).toBe(true)

      // After deletion - verify pattern is gone
      expect(manager.getPattern(patternId)).toBeUndefined()
      expect(manager.getPatternsForSeries(seriesId)).toEqual([])
    })
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Line 155 is already correct - uses `.toEqual([])`
2. Line 150 should be split: replace compound boolean with separate assertions
3. Use `.toHaveLength(1)` instead of checking `.length === 1` in a boolean
4. Check `patternsBefore[0].type` separately from the length check

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/pattern-crud.test.ts lines 140-182 to examine the violation at line 155

3. **Search for weak assertion patterns** - Used Grep tool with pattern "\.length\)\.toBe\(" in tests/fuzz/properties/pattern-crud.test.ts:
   - Line 172, 235, 255, 286, 289 have `.length).toBe()` patterns
   - Line 155 uses `.toEqual([])` which is correct

4. **Read PatternManager class** - Used Read tool on tests/fuzz/properties/pattern-crud.test.ts lines 1-80:
   - Lines 23-63: PatternManager class
   - Lines 28-38: createPattern method
   - Lines 44-55: deletePattern method
   - Lines 57-62: getPatternsForSeries method

---

## Violation #129: tests/fuzz/properties/pattern-crud.test.ts:255

**Test Name:** `deleteConditionsForSeries removes all conditions`

**Violation Line:**
```typescript
expect(manager.getConditionsForSeries(seriesId).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that `deleteConditionsForSeries` removes all conditions associated with a series.

**What functionality or behavior is it verifying?**

The test verifies (lines 241-259):
1. Creates multiple conditions for a series (lines 249-251)
2. Deletes all conditions for the series (line 253)
3. Verifies the delete count matches the conditions count (line 254)
4. Verifies getConditionsForSeries returns empty (line 255) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Bulk condition deletion is essential when a series is deleted or when resetting scheduling rules.

**What are the consequences if this test is wrong or weak?**

The `manager.getConditionsForSeries(seriesId).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of array contents
4. The test doesn't verify the individual conditions were removed from the main map

**Why does getting it right matter?**

For medically fragile people:
- Conditions define scheduling requirements (e.g., "only if blood sugar < X")
- Deleted conditions must not continue to affect scheduling
- Orphan conditions could cause unexpected scheduling behavior

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/pattern-crud.test.ts:241-259:
   ```typescript
   it('deleteConditionsForSeries removes all conditions', () => {
     fc.assert(
       fc.property(
         seriesIdGen(),
         fc.array(countConditionGen(), { minLength: 1, maxLength: 5 }),
         (seriesId, conditions) => {
           const manager = new ConditionManager()

           for (const condition of conditions) {
             manager.createCondition(seriesId, condition)
           }

           const deleted = manager.deleteConditionsForSeries(seriesId)
           expect(deleted).toBe(conditions.length)
           expect(manager.getConditionsForSeries(seriesId).length).toBe(0)  // weak
         }
       )
     )
   })
   ```

2. **ConditionManager class** - tests/fuzz/properties/pattern-crud.test.ts:69-121:
   ```typescript
   class ConditionManager {
     private conditions: Map<string, Condition> = new Map()
     private seriesConditions: Map<SeriesId, Set<string>> = new Map()
     private idCounter = 0

     createCondition(seriesId: SeriesId, condition: Condition): string {
       const id = `condition-${++this.idCounter}`
       this.conditions.set(id, condition)
       // ...
       return id
     }

     getConditionsForSeries(seriesId: SeriesId): Condition[] {
       const conditionIds = this.seriesConditions.get(seriesId) ?? new Set()
       return Array.from(conditionIds)
         .map((id) => this.conditions.get(id))
         .filter((c): c is Condition => c !== undefined)
     }

     deleteConditionsForSeries(seriesId: SeriesId): number {
       const conditionIds = this.seriesConditions.get(seriesId) ?? new Set()
       let deleted = 0
       for (const id of conditionIds) {
         if (this.conditions.delete(id)) {
           deleted++
         }
       }
       this.seriesConditions.delete(seriesId)
       return deleted
     }
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('deleteConditionsForSeries removes all conditions', () => {
  fc.assert(
    fc.property(
      seriesIdGen(),
      fc.array(countConditionGen(), { minLength: 1, maxLength: 5 }),
      (seriesId, conditions) => {
        const manager = new ConditionManager()
        const conditionIds: string[] = []

        for (const condition of conditions) {
          conditionIds.push(manager.createCondition(seriesId, condition))
        }

        // Verify conditions exist before deletion
        expect(manager.getConditionsForSeries(seriesId)).toHaveLength(conditions.length)

        const deleted = manager.deleteConditionsForSeries(seriesId)
        expect(deleted).toBe(conditions.length)

        // Verify conditions are gone from series
        expect(manager.getConditionsForSeries(seriesId)).toEqual([])

        // Verify individual conditions are gone from main map
        for (const id of conditionIds) {
          expect(manager.getCondition(id)).toBeUndefined()
        }
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Add pre-deletion verification that conditions exist
3. Track created condition IDs and verify each is undefined after deletion
4. Use `.toHaveLength()` for length checks with better error messages

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/pattern-crud.test.ts lines 240-290 to examine the violation at line 255

3. **Read ConditionManager class** - Used Read tool on tests/fuzz/properties/pattern-crud.test.ts lines 65-125:
   - Lines 69-121: ConditionManager class
   - Lines 74-84: createCondition method
   - Lines 103-108: getConditionsForSeries method
   - Lines 110-120: deleteConditionsForSeries method

---

## Violation #130: tests/fuzz/properties/pattern-crud.test.ts:286

**Test Name:** `patterns and conditions for different series are independent`

**Violation Line:**
```typescript
expect(conditionManager.getConditionsForSeries(series1).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that patterns and conditions created for one series don't appear in queries for a different series.

**What functionality or behavior is it verifying?**

The test verifies (lines 267-295):
1. Creates a pattern for series1 (line 280)
2. Creates a condition for series2 (line 281)
3. Verifies series1 has the pattern (lines 284-285)
4. Verifies series1 has NO conditions (line 286) - THIS IS THE VIOLATION
5. Verifies series2 has NO patterns (line 289)
6. Verifies series2 has the condition (lines 290-291)

**Why does this specific test matter?**

Series isolation is fundamental. Patterns and conditions must only apply to their associated series.

**What are the consequences if this test is wrong or weak?**

The `conditionManager.getConditionsForSeries(series1).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of array contents
4. Related: Lines 285, 289, 291 also have weak assertion patterns

**Why does getting it right matter?**

For medically fragile people:
- Cross-series contamination could apply wrong scheduling rules
- Medication A's conditions must never affect medication B's schedule
- Series isolation prevents dangerous scheduling errors

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/pattern-crud.test.ts:266-296:
   ```typescript
   describe('Pattern/Condition - Cross Reference', () => {
     it('patterns and conditions for different series are independent', () => {
       fc.assert(
         fc.property(
           seriesIdGen(),
           seriesIdGen(),
           simplePatternGen(),
           countConditionGen(),
           (series1, series2, pattern, condition) => {
             fc.pre(series1 !== series2)

             const patternManager = new PatternManager()
             const conditionManager = new ConditionManager()

             patternManager.createPattern(series1, pattern)
             conditionManager.createCondition(series2, condition)

             // Series 1 has pattern but no condition
             const series1Patterns = patternManager.getPatternsForSeries(series1)
             expect(series1Patterns.length === 1 && series1Patterns[0].type === pattern.type).toBe(true)
             expect(conditionManager.getConditionsForSeries(series1).length).toBe(0)  // weak

             // Series 2 has condition but no pattern
             expect(patternManager.getPatternsForSeries(series2).length).toBe(0)  // also weak
             const series2Conditions = conditionManager.getConditionsForSeries(series2)
             expect(series2Conditions.length === 1 && series2Conditions[0].type === condition.type).toBe(true)
           }
         )
       )
     })
   })
   ```

2. **PatternManager.getPatternsForSeries** - tests/fuzz/properties/pattern-crud.test.ts:57-62:
   ```typescript
   getPatternsForSeries(seriesId: SeriesId): Pattern[] {
     const patternIds = this.seriesPatterns.get(seriesId) ?? new Set()
     return Array.from(patternIds)
       .map((id) => this.patterns.get(id))
       .filter((p): p is Pattern => p !== undefined)
   }
   ```

3. **ConditionManager.getConditionsForSeries** - tests/fuzz/properties/pattern-crud.test.ts:103-108:
   ```typescript
   getConditionsForSeries(seriesId: SeriesId): Condition[] {
     const conditionIds = this.seriesConditions.get(seriesId) ?? new Set()
     return Array.from(conditionIds)
       .map((id) => this.conditions.get(id))
       .filter((c): c is Condition => c !== undefined)
   }
   ```

Both methods use a Map<SeriesId, Set<string>> to track associations, ensuring series isolation.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('patterns and conditions for different series are independent', () => {
  fc.assert(
    fc.property(
      seriesIdGen(),
      seriesIdGen(),
      simplePatternGen(),
      countConditionGen(),
      (series1, series2, pattern, condition) => {
        fc.pre(series1 !== series2)

        const patternManager = new PatternManager()
        const conditionManager = new ConditionManager()

        patternManager.createPattern(series1, pattern)
        conditionManager.createCondition(series2, condition)

        // Series 1 has pattern but no condition
        const series1Patterns = patternManager.getPatternsForSeries(series1)
        expect(series1Patterns).toHaveLength(1)
        expect(series1Patterns[0].type).toBe(pattern.type)
        expect(conditionManager.getConditionsForSeries(series1)).toEqual([])

        // Series 2 has condition but no pattern
        expect(patternManager.getPatternsForSeries(series2)).toEqual([])
        const series2Conditions = conditionManager.getConditionsForSeries(series2)
        expect(series2Conditions).toHaveLength(1)
        expect(series2Conditions[0].type).toBe(condition.type)
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace all `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Split compound boolean assertions (lines 285, 291) into separate assertions
3. Use `.toHaveLength(1)` instead of checking `.length === 1` in a boolean
4. Check `.type` properties separately from length checks

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/pattern-crud.test.ts lines 265-297 to examine the violation at line 286

3. **Read PatternManager and ConditionManager** - Used Read tool on tests/fuzz/properties/pattern-crud.test.ts lines 1-125:
   - Lines 23-63: PatternManager class with getPatternsForSeries at lines 57-62
   - Lines 69-121: ConditionManager class with getConditionsForSeries at lines 103-108

4. **Cross-reference series isolation** - Both managers use Map<SeriesId, Set<string>> to ensure patterns/conditions are associated with specific series only

---

## REPORT-121-130 COMPLETE

All 10 violations (#121-#130) have been analyzed in this report file.
