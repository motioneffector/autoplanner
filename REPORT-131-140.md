# REPORT-131-140: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #131-140 as specified in REPORT-SPEC.md.

---

## Violation #131: tests/fuzz/properties/pattern-crud.test.ts:289

**Test Name:** `patterns and conditions for different series are independent`

**Violation Line:**
```typescript
expect(patternManager.getPatternsForSeries(series2).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that patterns created for one series don't appear when querying a different series.

**What functionality or behavior is it verifying?**

The test verifies (lines 267-296):
1. Creates a pattern for series1 (line 280)
2. Creates a condition for series2 (line 281)
3. Verifies series1 has the pattern (lines 284-285)
4. Verifies series1 has no conditions (line 286)
5. Verifies series2 has NO patterns (line 289) - THIS IS THE VIOLATION
6. Verifies series2 has the condition (lines 290-291)

**Why does this specific test matter?**

Series isolation is fundamental to the scheduling system. Each series must only see its own patterns.

**What are the consequences if this test is wrong or weak?**

The `patternManager.getPatternsForSeries(series2).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of array contents
4. The test doesn't provide information about what patterns leaked

**Why does getting it right matter?**

For medically fragile people:
- Pattern isolation prevents cross-medication contamination
- One medication's scheduling rules must never apply to another
- Leaking patterns could create dangerous schedules

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/pattern-crud.test.ts:266-296:
   ```typescript
   describe('Pattern/Condition - Cross Reference', () => {
     it('patterns and conditions for different series are independent', () => {
       fc.assert(
         fc.property(
           seriesIdGen(),
           seriesIdGen(),
           simplePatternGen(),
           countConditionGen(),
           (series1, series2, pattern, condition) => {
             fc.pre(series1 !== series2)

             const patternManager = new PatternManager()
             const conditionManager = new ConditionManager()

             patternManager.createPattern(series1, pattern)
             conditionManager.createCondition(series2, condition)

             // ...
             // Series 2 has condition but no pattern
             expect(patternManager.getPatternsForSeries(series2).length).toBe(0)  // weak
             // ...
           }
         )
       )
     })
   })
   ```

2. **getPatternsForSeries implementation** - tests/fuzz/properties/pattern-crud.test.ts:57-62:
   ```typescript
   getPatternsForSeries(seriesId: SeriesId): Pattern[] {
     const patternIds = this.seriesPatterns.get(seriesId) ?? new Set()
     return Array.from(patternIds)
       .map((id) => this.patterns.get(id))
       .filter((p): p is Pattern => p !== undefined)
   }
   ```

3. **Series pattern storage** - tests/fuzz/properties/pattern-crud.test.ts:24-25:
   ```typescript
   private patterns: Map<string, Pattern> = new Map()
   private seriesPatterns: Map<SeriesId, Set<string>> = new Map()
   ```

The `seriesPatterns` map ensures each series only tracks its own pattern IDs.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('patterns and conditions for different series are independent', () => {
  fc.assert(
    fc.property(
      seriesIdGen(),
      seriesIdGen(),
      simplePatternGen(),
      countConditionGen(),
      (series1, series2, pattern, condition) => {
        fc.pre(series1 !== series2)

        const patternManager = new PatternManager()
        const conditionManager = new ConditionManager()

        patternManager.createPattern(series1, pattern)
        conditionManager.createCondition(series2, condition)

        // Series 1 has pattern but no condition
        const series1Patterns = patternManager.getPatternsForSeries(series1)
        expect(series1Patterns).toHaveLength(1)
        expect(series1Patterns[0].type).toBe(pattern.type)
        expect(conditionManager.getConditionsForSeries(series1)).toEqual([])

        // Series 2 has condition but no pattern
        expect(patternManager.getPatternsForSeries(series2)).toEqual([])
        const series2Conditions = conditionManager.getConditionsForSeries(series2)
        expect(series2Conditions).toHaveLength(1)
        expect(series2Conditions[0].type).toBe(condition.type)
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Split compound boolean assertions (lines 285, 291) into separate assertions
3. Use `.toHaveLength(1)` for positive length checks
4. Check `.type` properties separately from length checks

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/pattern-crud.test.ts lines 265-297 to examine the violation at line 289

3. **Search for getPatternsForSeries** - Used Grep tool with pattern "getPatternsForSeries" in tests/fuzz/properties/pattern-crud.test.ts:
   - Line 57: Method definition
   - Lines 138, 149, 155, 172, 284, 289: Test usages

4. **Read getPatternsForSeries implementation** - Used Read tool on tests/fuzz/properties/pattern-crud.test.ts lines 280-300:
   - Lines 57-62: getPatternsForSeries method
   - Lines 24-25: Private maps for pattern storage

---

## Violation #132: tests/fuzz/properties/reflow.test.ts:1440

**Test Name:** `Property #372: completeness — if valid arrangement exists, finds one`

**Violation Line:**
```typescript
expect(result.unassigned.length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that the CompletenessCheckingEngine can find a valid assignment when non-overlapping time slots are provided.

**What functionality or behavior is it verifying?**

The test verifies (lines 1413-1444):
1. Creates items with non-overlapping time slots (lines 1421-1433)
2. Calls findCompleteAssignment (line 1435)
3. Verifies success is true (line 1438)
4. Verifies all items are assigned (line 1439)
5. Verifies no items are unassigned (line 1440) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Completeness is a fundamental property of the scheduling algorithm. If a valid arrangement exists, the algorithm must find it.

**What are the consequences if this test is wrong or weak?**

The `result.unassigned.length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of which items were unassigned
4. Line 1439 has a similar weak pattern (`.length).toBe(itemCount)`)

**Why does getting it right matter?**

For medically fragile people:
- Completeness ensures no medications are dropped from the schedule
- If a valid arrangement exists, every medication must be scheduled
- Unassigned items could mean missed medications

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/reflow.test.ts:1412-1444:
   ```typescript
   describe('Spec 12: Reflow - Completeness', () => {
     it('Property #372: completeness — if valid arrangement exists, finds one', () => {
       fc.assert(
         fc.property(
           fc.integer({ min: 1, max: 5 }),
           fc.integer({ min: 30, max: 60 }),
           (itemCount, baseDuration) => {
             const engine = new CompletenessCheckingEngine()

             // Create items with non-overlapping time slots
             const items = Array.from({ length: itemCount }, (_, i) => ({
               seriesId: `series-${i}` as SeriesId,
               duration: baseDuration as Duration,
               domain: {
                 seriesId: `series-${i}` as SeriesId,
                 slots: [{
                   start: 8 * 60 + i * (baseDuration + 30),
                   end: 8 * 60 + i * (baseDuration + 30) + baseDuration,
                 }],
               },
             }))

             const result = engine.findCompleteAssignment(items)

             expect(result.success).toBe(true)
             expect(result.assignments.length).toBe(itemCount)  // also weak
             expect(result.unassigned.length).toBe(0)  // THIS IS THE VIOLATION
           }
         )
       )
     })
   })
   ```

2. **CompletenessCheckingEngine class** - tests/fuzz/properties/reflow.test.ts:1363-1410:
   ```typescript
   class CompletenessCheckingEngine extends BalancingReflowEngine {
     findCompleteAssignment(items: Array<{...}>): SchedulingResult {
       const assignments: Assignment[] = []
       const unassigned: SeriesId[] = []
       const usedSlots: TimeSlot[] = []

       // Sort by domain size (MRV heuristic)
       const sorted = [...items].sort((a, b) => a.domain.slots.length - b.domain.slots.length)

       for (const item of sorted) {
         let placed = false
         for (const slot of item.domain.slots) {
           const conflicts = usedSlots.some(used =>
             slot.start < used.end && used.start < slot.end
           )
           if (!conflicts) {
             assignments.push({ seriesId: item.seriesId, slot })
             usedSlots.push(slot)
             placed = true
             break
           }
         }
         if (!placed) {
           unassigned.push(item.seriesId)
         }
       }

       return { success: unassigned.length === 0, assignments, unassigned }
     }
   }
   ```

3. **SchedulingResult interface** - tests/fuzz/properties/reflow.test.ts:1357-1361:
   ```typescript
   interface SchedulingResult {
     success: boolean
     assignments: Assignment[]
     unassigned: SeriesId[]
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #372: completeness — if valid arrangement exists, finds one', () => {
  fc.assert(
    fc.property(
      fc.integer({ min: 1, max: 5 }),
      fc.integer({ min: 30, max: 60 }),
      (itemCount, baseDuration) => {
        const engine = new CompletenessCheckingEngine()

        // Create items with non-overlapping time slots
        const items = Array.from({ length: itemCount }, (_, i) => ({
          seriesId: `series-${i}` as SeriesId,
          duration: baseDuration as Duration,
          domain: {
            seriesId: `series-${i}` as SeriesId,
            slots: [{
              start: 8 * 60 + i * (baseDuration + 30),
              end: 8 * 60 + i * (baseDuration + 30) + baseDuration,
            }],
          },
        }))

        const result = engine.findCompleteAssignment(items)

        // Verify complete success
        expect(result.success).toBe(true)
        expect(result.assignments).toHaveLength(itemCount)
        expect(result.unassigned).toEqual([])

        // Verify all items are assigned
        const assignedSeriesIds = result.assignments.map(a => a.seriesId)
        for (let i = 0; i < itemCount; i++) {
          expect(assignedSeriesIds).toContain(`series-${i}`)
        }
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(itemCount)` with `.toHaveLength(itemCount)`
3. Add verification that each expected seriesId is in the assignments
4. Consider verifying the assigned slots are within the original domains

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/reflow.test.ts lines 1425-1475 to examine the violation at line 1440

3. **Search for CompletenessCheckingEngine** - Used Grep tool with pattern "class CompletenessCheckingEngine" found at line 1363

4. **Read CompletenessCheckingEngine class** - Used Read tool on tests/fuzz/properties/reflow.test.ts lines 1360-1415:
   - Lines 1357-1361: SchedulingResult interface
   - Lines 1363-1410: CompletenessCheckingEngine class
   - Lines 1368-1409: findCompleteAssignment method

5. **Read test context** - Used Read tool on tests/fuzz/properties/reflow.test.ts lines 1400-1450:
   - Lines 1412-1444: Test "Property #372: completeness"

---

## Violation #133: tests/fuzz/properties/series.test.ts:424

**Test Name:** `Property #284: splitSeries sets original endDate`

**Violation Line:**
```typescript
expect(typeof original?.bounds?.endDate).toBe('string')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is split, the original series has its endDate set to the day before the split date.

**What functionality or behavior is it verifying?**

The test verifies (lines 414-427):
1. Creates a series (line 418)
2. Splits the series at a given date (line 420)
3. Retrieves the original series (line 422)
4. Verifies the bounds endDate is a string (line 424) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Series splitting is essential for handling prescription changes or medication adjustments mid-schedule.

**What are the consequences if this test is wrong or weak?**

The `typeof original?.bounds?.endDate).toBe('string')` assertion is weak because:
1. TypeScript already guarantees LocalDate is a string (branded type)
2. It doesn't verify the VALUE is correct (should be day before splitDate)
3. `.toBeDefined()` would be clearer if just checking existence
4. The test should verify the actual date logic, not just the type

**Why does getting it right matter?**

For medically fragile people:
- Series bounds define when a medication schedule is valid
- Incorrect endDate could cause medication gaps or overlaps
- The day-before-split logic is crucial for avoiding double-dosing

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:414-427:
   ```typescript
   it('Property #284: splitSeries sets original endDate', () => {
     fc.assert(
       fc.property(minimalSeriesGen(), localDateGen(), (series, splitDate) => {
         const manager = new SeriesManager()
         const originalId = manager.createSeries(series)

         manager.splitSeries(originalId, splitDate)

         const original = manager.getSeries(originalId)
         // Verify endDate is set as a string (LocalDate)
         expect(typeof original?.bounds?.endDate).toBe('string')  // weak
       })
     )
   })
   ```

2. **splitSeries implementation** - tests/fuzz/properties/series.test.ts:128-157:
   ```typescript
   splitSeries(id: SeriesId, splitDate: LocalDate): SeriesId | null {
     if (this.lockedSeries.has(id)) {
       throw new Error('Cannot split locked series')
     }

     const original = this.series.get(id)
     if (!original) return null

     // Create new series for the future portion
     const newId = `series-${++this.idCounter}` as SeriesId
     const newSeries: Series = {
       ...original,
       id: newId,
       bounds: original.bounds ? { ...original.bounds, startDate: splitDate } : { startDate: splitDate },
     }

     // Update original to end at split date
     if (original.bounds) {
       const dayBeforeSplit = this.addDays(splitDate, -1)
       original.bounds = { ...original.bounds, endDate: dayBeforeSplit }
     } else {
       const dayBeforeSplit = this.addDays(splitDate, -1)
       original.bounds = { endDate: dayBeforeSplit }
     }

     this.series.set(newId, newSeries)
     return newId
   }
   ```

3. **addDays helper** - tests/fuzz/properties/series.test.ts:159-164:
   ```typescript
   private addDays(date: LocalDate, days: number): LocalDate {
     const parsed = parseLocalDate(date)
     const d = new Date(parsed.year, parsed.month - 1, parsed.day)
     d.setDate(d.getDate() + days)
     return makeLocalDate(d.getFullYear(), d.getMonth() + 1, d.getDate())
   }
   ```

The implementation shows the endDate should be `splitDate - 1 day`.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #284: splitSeries sets original endDate', () => {
  fc.assert(
    fc.property(minimalSeriesGen(), localDateGen(), (series, splitDate) => {
      const manager = new SeriesManager()
      const originalId = manager.createSeries(series)

      manager.splitSeries(originalId, splitDate)

      const original = manager.getSeries(originalId)

      // Verify bounds is defined
      expect(original).toBeDefined()
      expect(original?.bounds).toBeDefined()
      expect(original?.bounds?.endDate).toBeDefined()

      // Verify endDate is the day before splitDate
      const expectedEndDate = subtractDay(splitDate)
      expect(original?.bounds?.endDate).toBe(expectedEndDate)
    })
  )
})

function subtractDay(date: LocalDate): LocalDate {
  // Helper to compute expected value
  const parsed = parseLocalDate(date)
  const d = new Date(parsed.year, parsed.month - 1, parsed.day)
  d.setDate(d.getDate() - 1)
  return makeLocalDate(d.getFullYear(), d.getMonth() + 1, d.getDate())
}
```

**What specific changes would transform this test into its ideal form?**

1. Remove `typeof x).toBe('string')` - TypeScript handles this
2. Add `.toBeDefined()` checks for the property chain
3. Verify the actual date VALUE, not just its type
4. The endDate should equal `splitDate - 1 day`
5. Consider edge cases like splitDate at series start/end

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 410-460 to examine the violation at line 424

3. **Search for SeriesManager class** - Used Grep tool with pattern "class SeriesManager" found at line 26

4. **Search for splitSeries** - Used Grep tool with pattern "splitSeries" in tests/fuzz/properties/series.test.ts:
   - Line 128: Method definition
   - Lines 395, 401, 414, 420, 429, 435, 443, 453, etc.: Test usages

5. **Read SeriesManager class** - Used Read tool on tests/fuzz/properties/series.test.ts lines 20-100:
   - Lines 26-165: SeriesManager class

6. **Read splitSeries implementation** - Used Read tool on tests/fuzz/properties/series.test.ts lines 125-165:
   - Lines 128-157: splitSeries method
   - Lines 145-151: Sets original.bounds.endDate to dayBeforeSplit
   - Lines 159-164: addDays helper method

---

## Violation #134: tests/fuzz/properties/series.test.ts:647

**Test Name:** `Property #253: deleteSeries cascades to patterns`

**Violation Line:**
```typescript
expect(manager.getPatterns(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is deleted with cascade, all its associated patterns are also deleted.

**What functionality or behavior is it verifying?**

The test verifies (lines 627-651):
1. Creates a series (line 634)
2. Adds multiple patterns to the series (lines 637-639)
3. Verifies patterns exist before deletion (line 641)
4. Deletes the series with cascade (line 644)
5. Verifies all patterns are deleted (line 647) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Cascade deletion ensures orphan data doesn't remain when a series is deleted.

**What are the consequences if this test is wrong or weak?**

The `manager.getPatterns(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of which patterns remained
4. Line 641 also has a weak pattern (`.length).toBe(patternCount)`)

**Why does getting it right matter?**

For medically fragile people:
- Orphan patterns could cause undefined scheduling behavior
- Deleted series must have all associated data removed
- Cascade delete is essential for data integrity

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:627-651:
   ```typescript
   describe('Spec 3: Series - Cascade Deletion', () => {
     it('Property #253: deleteSeries cascades to patterns', () => {
       fc.assert(
         fc.property(
           minimalSeriesGen(),
           fc.integer({ min: 1, max: 5 }),
           (series, patternCount) => {
             const manager = new CascadeSeriesManager()
             const id = manager.createSeries(series)

             // Add patterns
             for (let i = 0; i < patternCount; i++) {
               manager.addPattern(id)
             }

             expect(manager.getPatterns(id).length).toBe(patternCount)

             // Delete series with cascade
             manager.deleteSeriesWithCascade(id)

             // Patterns should be deleted
             expect(manager.getPatterns(id).length).toBe(0)  // weak
           }
         )
       )
     })
   })
   ```

2. **CascadeSeriesManager class** - tests/fuzz/properties/series.test.ts:575-624:
   ```typescript
   class CascadeSeriesManager extends SeriesManager {
     private patterns: Map<SeriesId, Set<string>> = new Map()
     private conditions: Map<SeriesId, Set<string>> = new Map()

     addPattern(seriesId: SeriesId): string {
       const patternId = `pattern-${++this.patternCounter}`
       if (!this.patterns.has(seriesId)) {
         this.patterns.set(seriesId, new Set())
       }
       this.patterns.get(seriesId)!.add(patternId)
       return patternId
     }

     getPatterns(seriesId: SeriesId): string[] {
       return Array.from(this.patterns.get(seriesId) ?? [])
     }

     deleteSeriesWithCascade(id: SeriesId): boolean {
       // ...
       // Cascade delete patterns
       this.patterns.delete(id)
       // Cascade delete conditions
       this.conditions.delete(id)
       // Delete the series itself
       return this.deleteSeries(id)
     }
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #253: deleteSeries cascades to patterns', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      fc.integer({ min: 1, max: 5 }),
      (series, patternCount) => {
        const manager = new CascadeSeriesManager()
        const id = manager.createSeries(series)
        const patternIds: string[] = []

        // Add patterns and track IDs
        for (let i = 0; i < patternCount; i++) {
          patternIds.push(manager.addPattern(id))
        }

        // Verify patterns exist before deletion
        expect(manager.getPatterns(id)).toHaveLength(patternCount)
        for (const patternId of patternIds) {
          expect(manager.getPatterns(id)).toContain(patternId)
        }

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all patterns are deleted
        expect(manager.getPatterns(id)).toEqual([])

        // Verify series itself is deleted
        expect(manager.getSeries(id)).toBeUndefined()
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(patternCount)` with `.toHaveLength(patternCount)`
3. Track pattern IDs and verify each was in the list before deletion
4. Verify the deleteSeriesWithCascade return value
5. Verify the series itself is deleted

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 635-685 to examine the violation at line 647

3. **Search for CascadeSeriesManager** - Used Grep tool with pattern "class CascadeSeriesManager" found at line 575

4. **Read CascadeSeriesManager class** - Used Read tool on tests/fuzz/properties/series.test.ts lines 570-630:
   - Lines 575-624: CascadeSeriesManager class
   - Lines 576-577: Private maps for patterns and conditions
   - Lines 581-588: addPattern method
   - Lines 599-601: getPatterns method
   - Lines 607-623: deleteSeriesWithCascade method

5. **Read test context** - Used Read tool on tests/fuzz/properties/series.test.ts lines 600-650:
   - Lines 626-651: Test "Property #253: deleteSeries cascades to patterns"

---

## Violation #135: tests/fuzz/properties/series.test.ts:673

**Test Name:** `Property #254: deleteSeries cascades to conditions`

**Violation Line:**
```typescript
expect(manager.getConditions(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is deleted with cascade, all its associated conditions are also deleted.

**What functionality or behavior is it verifying?**

The test verifies (lines 653-677):
1. Creates a series (line 660)
2. Adds multiple conditions to the series (lines 663-665)
3. Verifies conditions exist before deletion (line 667)
4. Deletes the series with cascade (line 670)
5. Verifies all conditions are deleted (line 673) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Conditions define scheduling rules that must be cleaned up when a series is deleted.

**What are the consequences if this test is wrong or weak?**

The `manager.getConditions(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of which conditions remained
4. Line 667 also has a weak pattern (`.length).toBe(conditionCount)`)

**Why does getting it right matter?**

For medically fragile people:
- Orphan conditions could cause undefined scheduling behavior
- Conditions affect when/if medications are scheduled
- Deleted series must have all associated data removed

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:653-677:
   ```typescript
   it('Property #254: deleteSeries cascades to conditions', () => {
     fc.assert(
       fc.property(
         minimalSeriesGen(),
         fc.integer({ min: 1, max: 5 }),
         (series, conditionCount) => {
           const manager = new CascadeSeriesManager()
           const id = manager.createSeries(series)

           // Add conditions
           for (let i = 0; i < conditionCount; i++) {
             manager.addCondition(id)
           }

           expect(manager.getConditions(id).length).toBe(conditionCount)

           // Delete series with cascade
           manager.deleteSeriesWithCascade(id)

           // Conditions should be deleted
           expect(manager.getConditions(id).length).toBe(0)  // weak
         }
       )
     )
   })
   ```

2. **addCondition implementation** - tests/fuzz/properties/series.test.ts:590-597:
   ```typescript
   addCondition(seriesId: SeriesId): string {
     const conditionId = `condition-${++this.conditionCounter}`
     if (!this.conditions.has(seriesId)) {
       this.conditions.set(seriesId, new Set())
     }
     this.conditions.get(seriesId)!.add(conditionId)
     return conditionId
   }
   ```

3. **getConditions implementation** - tests/fuzz/properties/series.test.ts:603-605:
   ```typescript
   getConditions(seriesId: SeriesId): string[] {
     return Array.from(this.conditions.get(seriesId) ?? [])
   }
   ```

4. **deleteSeriesWithCascade** - tests/fuzz/properties/series.test.ts:607-623:
   ```typescript
   deleteSeriesWithCascade(id: SeriesId): boolean {
     // ...
     // Cascade delete conditions
     this.conditions.delete(id)
     // ...
     return this.deleteSeries(id)
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #254: deleteSeries cascades to conditions', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      fc.integer({ min: 1, max: 5 }),
      (series, conditionCount) => {
        const manager = new CascadeSeriesManager()
        const id = manager.createSeries(series)
        const conditionIds: string[] = []

        // Add conditions and track IDs
        for (let i = 0; i < conditionCount; i++) {
          conditionIds.push(manager.addCondition(id))
        }

        // Verify conditions exist before deletion
        expect(manager.getConditions(id)).toHaveLength(conditionCount)
        for (const conditionId of conditionIds) {
          expect(manager.getConditions(id)).toContain(conditionId)
        }

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all conditions are deleted
        expect(manager.getConditions(id)).toEqual([])

        // Verify series itself is deleted
        expect(manager.getSeries(id)).toBeUndefined()
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(conditionCount)` with `.toHaveLength(conditionCount)`
3. Track condition IDs and verify each was in the list before deletion
4. Verify the deleteSeriesWithCascade return value
5. Verify the series itself is deleted

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 650-700 to examine the violation at line 673

3. **Read CascadeSeriesManager methods** - Used Read tool on tests/fuzz/properties/series.test.ts lines 587-625:
   - Lines 590-597: addCondition method
   - Lines 603-605: getConditions method
   - Lines 607-623: deleteSeriesWithCascade method (deletes conditions at line 619)

---

## Violation #136: tests/fuzz/properties/series.test.ts:781

**Test Name:** `Property #255: deleteSeries cascades to reminders`

**Violation Line:**
```typescript
expect(manager.getReminders(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is deleted with cascade, all its associated reminders are also deleted.

**What functionality or behavior is it verifying?**

The test verifies (lines 755-785):
1. Creates a series (line 768)
2. Adds multiple reminders to the series (lines 771-773)
3. Verifies reminders exist before deletion (line 775)
4. Deletes the series with cascade (line 778)
5. Verifies all reminders are deleted (line 781) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Reminders are critical for medication adherence. They must be cleaned up when a series is deleted.

**What are the consequences if this test is wrong or weak?**

The `manager.getReminders(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of which reminders remained
4. Line 775 also has a weak pattern

**Why does getting it right matter?**

For medically fragile people:
- Orphan reminders for deleted medications could cause confusion
- Caregivers might be reminded about non-existent medications
- Reminder cascade is essential for data integrity

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:754-785:
   ```typescript
   describe('Spec 3: Series - Cascade Deletion (Reminders)', () => {
     it('Property #255: deleteSeries cascades to reminders', () => {
       fc.assert(
         fc.property(
           minimalSeriesGen(),
           fc.array(
             fc.record({
               minutesBefore: fc.integer({ min: 1, max: 60 }),
               tag: fc.string({ minLength: 1, maxLength: 10 }),
             }),
             { minLength: 1, maxLength: 5 }
           ),
           (series, reminderConfigs) => {
             const manager = new ReminderCascadeManager()
             const id = manager.createSeries(series)

             for (const config of reminderConfigs) {
               manager.addReminder(id, config.minutesBefore, config.tag)
             }

             expect(manager.getReminders(id).length).toBe(reminderConfigs.length)

             manager.deleteSeriesWithCascade(id)

             expect(manager.getReminders(id).length).toBe(0)  // weak
           }
         )
       )
     })
   })
   ```

2. **Reminder interface** - tests/fuzz/properties/series.test.ts:714-719:
   ```typescript
   interface Reminder {
     id: string
     seriesId: SeriesId
     minutesBefore: number
     tag: string
   }
   ```

3. **ReminderCascadeManager class** - tests/fuzz/properties/series.test.ts:721-752:
   ```typescript
   class ReminderCascadeManager extends CascadeSeriesManager {
     private reminders: Map<SeriesId, Reminder[]> = new Map()

     addReminder(seriesId: SeriesId, minutesBefore: number, tag: string): Reminder {
       // ...creates reminder object, adds to map
       return reminder
     }

     getReminders(seriesId: SeriesId): Reminder[] {
       return this.reminders.get(seriesId) ?? []
     }

     deleteRemindersForSeries(seriesId: SeriesId): void {
       this.reminders.delete(seriesId)
     }

     override deleteSeriesWithCascade(id: SeriesId): boolean {
       this.deleteRemindersForSeries(id)  // Delete reminders first
       return super.deleteSeriesWithCascade(id)  // Then parent cascade
     }
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #255: deleteSeries cascades to reminders', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      fc.array(
        fc.record({
          minutesBefore: fc.integer({ min: 1, max: 60 }),
          tag: fc.string({ minLength: 1, maxLength: 10 }),
        }),
        { minLength: 1, maxLength: 5 }
      ),
      (series, reminderConfigs) => {
        const manager = new ReminderCascadeManager()
        const id = manager.createSeries(series)
        const reminderIds: string[] = []

        // Add reminders and track IDs
        for (const config of reminderConfigs) {
          const reminder = manager.addReminder(id, config.minutesBefore, config.tag)
          reminderIds.push(reminder.id)
        }

        // Verify reminders exist before deletion
        const remindersBefore = manager.getReminders(id)
        expect(remindersBefore).toHaveLength(reminderConfigs.length)
        for (let i = 0; i < reminderConfigs.length; i++) {
          expect(remindersBefore[i].minutesBefore).toBe(reminderConfigs[i].minutesBefore)
          expect(remindersBefore[i].tag).toBe(reminderConfigs[i].tag)
        }

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all reminders are deleted
        expect(manager.getReminders(id)).toEqual([])
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(reminderConfigs.length)` with `.toHaveLength()`
3. Track reminder details and verify content before deletion
4. Verify the deleteSeriesWithCascade return value

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 765-815 to examine the violation at line 781

3. **Read ReminderCascadeManager class** - Used Read tool on tests/fuzz/properties/series.test.ts lines 710-775:
   - Lines 714-719: Reminder interface
   - Lines 721-752: ReminderCascadeManager class
   - Lines 725-736: addReminder method
   - Lines 738-740: getReminders method
   - Lines 742-744: deleteRemindersForSeries method
   - Lines 746-751: deleteSeriesWithCascade override

---

## Violation #137: tests/fuzz/properties/series.test.ts:879

**Test Name:** `Property #256: deleteSeries cascades to instance exceptions`

**Violation Line:**
```typescript
expect(manager.getExceptions(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is deleted with cascade, all its associated instance exceptions are also deleted.

**What functionality or behavior is it verifying?**

The test verifies (lines 858-883):
1. Creates a series (line 866)
2. Adds multiple instance exceptions (cancelled) to the series (lines 869-871)
3. Verifies exceptions exist before deletion (line 873)
4. Deletes the series with cascade (line 876)
5. Verifies all exceptions are deleted (line 879) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Instance exceptions track cancelled or rescheduled instances. They must be cleaned up when a series is deleted.

**What are the consequences if this test is wrong or weak?**

The `manager.getExceptions(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. If this fails, the error shows numbers instead of which exceptions remained
4. Line 873 also has a weak pattern

**Why does getting it right matter?**

For medically fragile people:
- Orphan exceptions for deleted medications could cause confusion
- Exceptions track critical scheduling changes (cancellations, reschedules)
- Exception cascade is essential for data integrity

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:857-883:
   ```typescript
   describe('Spec 3: Series - Cascade Deletion (Instance Exceptions)', () => {
     it('Property #256: deleteSeries cascades to instance exceptions', () => {
       fc.assert(
         fc.property(
           minimalSeriesGen(),
           fc.array(localDateGen(), { minLength: 1, maxLength: 5 }),
           (series, dates) => {
             const uniqueDates = [...new Set(dates)]
             const manager = new ExceptionCascadeManager()
             const id = manager.createSeries(series)

             for (const date of uniqueDates) {
               manager.addException(id, date, 'cancelled')
             }

             expect(manager.getExceptions(id).length).toBe(uniqueDates.length)

             manager.deleteSeriesWithCascade(id)

             expect(manager.getExceptions(id).length).toBe(0)  // weak
           }
         )
       )
     })
   })
   ```

2. **InstanceException interface** - tests/fuzz/properties/series.test.ts:817-823:
   ```typescript
   interface InstanceException {
     id: string
     seriesId: SeriesId
     instanceDate: LocalDate
     type: 'cancelled' | 'rescheduled'
     newTime?: LocalDateTime
   }
   ```

3. **ExceptionCascadeManager class** - tests/fuzz/properties/series.test.ts:825-855:
   ```typescript
   class ExceptionCascadeManager extends ReminderCascadeManager {
     private exceptions: Map<SeriesId, InstanceException[]> = new Map()

     addException(seriesId: SeriesId, date: LocalDate, type: 'cancelled' | 'rescheduled', newTime?: LocalDateTime): InstanceException {
       // ...creates exception object, adds to map
       return exception
     }

     getExceptions(seriesId: SeriesId): InstanceException[] {
       return this.exceptions.get(seriesId) ?? []
     }

     deleteExceptionsForSeries(seriesId: SeriesId): void {
       this.exceptions.delete(seriesId)
     }

     override deleteSeriesWithCascade(id: SeriesId): boolean {
       this.deleteExceptionsForSeries(id)  // Delete exceptions first
       return super.deleteSeriesWithCascade(id)  // Then parent cascade
     }
   }
   ```

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #256: deleteSeries cascades to instance exceptions', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      fc.array(localDateGen(), { minLength: 1, maxLength: 5 }),
      (series, dates) => {
        const uniqueDates = [...new Set(dates)]
        const manager = new ExceptionCascadeManager()
        const id = manager.createSeries(series)

        // Add exceptions and track them
        for (const date of uniqueDates) {
          manager.addException(id, date, 'cancelled')
        }

        // Verify exceptions exist before deletion
        const exceptionsBefore = manager.getExceptions(id)
        expect(exceptionsBefore).toHaveLength(uniqueDates.length)
        for (const date of uniqueDates) {
          expect(exceptionsBefore.some(e => e.instanceDate === date)).toBe(true)
        }

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all exceptions are deleted
        expect(manager.getExceptions(id)).toEqual([])
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(uniqueDates.length)` with `.toHaveLength()`
3. Verify exception dates match before deletion
4. Verify the deleteSeriesWithCascade return value

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 860-910 to examine the violation at line 879

3. **Read ExceptionCascadeManager class** - Used Read tool on tests/fuzz/properties/series.test.ts lines 810-870:
   - Lines 817-823: InstanceException interface
   - Lines 825-855: ExceptionCascadeManager class
   - Lines 829-841: addException method
   - Lines 843-845: getExceptions method
   - Lines 847-849: deleteExceptionsForSeries method
   - Lines 851-854: deleteSeriesWithCascade override

---

## Violation #138: tests/fuzz/properties/series.test.ts:908

**Test Name:** `exception cascade includes both cancelled and rescheduled`

**Violation Line:**
```typescript
expect(manager.getExceptions(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that cascade deletion removes both 'cancelled' and 'rescheduled' exception types.

**What functionality or behavior is it verifying?**

The test verifies (lines 885-912):
1. Creates a series (line 896)
2. Adds a 'cancelled' exception (line 898)
3. Adds a 'rescheduled' exception with newTime (line 899)
4. Verifies both exception types exist (lines 901-904)
5. Deletes the series with cascade (line 906)
6. Verifies all exceptions are deleted (line 908) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Different exception types have different data (rescheduled has newTime). Both must be properly cascaded.

**What are the consequences if this test is wrong or weak?**

The `manager.getExceptions(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. Line 904 has a compound boolean assertion which is also weak
4. If cascade only deleted one type, this wouldn't clearly indicate which

**Why does getting it right matter?**

For medically fragile people:
- Both cancelled and rescheduled exceptions affect the schedule
- Orphan rescheduled exceptions could cause confusion about medication timing
- Complete cascade deletion is essential for data integrity

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:885-912:
   ```typescript
   it('exception cascade includes both cancelled and rescheduled', () => {
     fc.assert(
       fc.property(
         minimalSeriesGen(),
         localDateGen(),
         localDateGen(),
         localDateTimeGen(),
         (series, date1, date2, newTime) => {
           fc.pre(date1 !== date2)

           const manager = new ExceptionCascadeManager()
           const id = manager.createSeries(series)

           manager.addException(id, date1, 'cancelled')
           manager.addException(id, date2, 'rescheduled', newTime)

           const exceptions = manager.getExceptions(id)
           const cancelledEx = exceptions.find((e) => e.type === 'cancelled')
           const rescheduledEx = exceptions.find((e) => e.type === 'rescheduled')
           expect(exceptions.length === 2 && cancelledEx?.type === 'cancelled' && rescheduledEx?.type === 'rescheduled').toBe(true)  // weak

           manager.deleteSeriesWithCascade(id)

           expect(manager.getExceptions(id).length).toBe(0)  // THIS IS THE VIOLATION
         }
       )
     )
   })
   ```

2. **Exception types** - tests/fuzz/properties/series.test.ts:821:
   ```typescript
   type: 'cancelled' | 'rescheduled'
   ```

3. **addException with newTime** - tests/fuzz/properties/series.test.ts:829-841:
   The rescheduled type uses the optional `newTime` parameter.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('exception cascade includes both cancelled and rescheduled', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      localDateGen(),
      localDateGen(),
      localDateTimeGen(),
      (series, date1, date2, newTime) => {
        fc.pre(date1 !== date2)

        const manager = new ExceptionCascadeManager()
        const id = manager.createSeries(series)

        manager.addException(id, date1, 'cancelled')
        manager.addException(id, date2, 'rescheduled', newTime)

        // Verify both exception types exist before deletion
        const exceptions = manager.getExceptions(id)
        expect(exceptions).toHaveLength(2)

        const cancelledEx = exceptions.find((e) => e.type === 'cancelled')
        expect(cancelledEx).toBeDefined()
        expect(cancelledEx?.type).toBe('cancelled')
        expect(cancelledEx?.instanceDate).toBe(date1)

        const rescheduledEx = exceptions.find((e) => e.type === 'rescheduled')
        expect(rescheduledEx).toBeDefined()
        expect(rescheduledEx?.type).toBe('rescheduled')
        expect(rescheduledEx?.instanceDate).toBe(date2)
        expect(rescheduledEx?.newTime).toBe(newTime)

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all exceptions are deleted
        expect(manager.getExceptions(id)).toEqual([])
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Split compound boolean assertion (line 904) into separate assertions
3. Verify exception dates and newTime values
4. Use `.toBeDefined()` before checking exception properties
5. Verify the deleteSeriesWithCascade return value

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 885-935 to examine the violation at line 908

3. **Cross-reference InstanceException interface** - tests/fuzz/properties/series.test.ts:817-823:
   - Line 821: type: 'cancelled' | 'rescheduled'
   - Line 822: newTime?: LocalDateTime (optional, used for rescheduled)

---

## Violation #139: tests/fuzz/properties/series.test.ts:1146

**Test Name:** `Property #259: deleteSeries cascades to series_tag`

**Violation Line:**
```typescript
expect(manager.getTagsForSeries(id).length).toBe(0)
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that when a series is deleted with cascade, all its tag associations are also deleted.

**What functionality or behavior is it verifying?**

The test verifies (lines 1128-1150):
1. Creates a series (line 1136)
2. Adds multiple tags to the series (lines 1138-1140)
3. Verifies tags exist before deletion (line 1142)
4. Deletes the series with cascade (line 1144)
5. Verifies all tags are removed from series (line 1146) - THIS IS THE VIOLATION

**Why does this specific test matter?**

Tags are used for grouping and searching series. They must be cleaned up when a series is deleted.

**What are the consequences if this test is wrong or weak?**

The `manager.getTagsForSeries(id).length).toBe(0)` assertion is weak because:
1. Using `.length).toBe(0)` instead of `.toHaveLength(0)` provides worse error messages
2. `.toEqual([])` would be clearer and more idiomatic
3. Line 1142 also has a weak pattern

**Why does getting it right matter?**

For medically fragile people:
- Tags organize medications into categories
- Orphan tag associations could cause search confusion
- Tag cascade ensures bidirectional map is properly cleaned

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/series.test.ts:1127-1150:
   ```typescript
   describe('Spec 3: Series - Cascade Deletion (Series Tags)', () => {
     it('Property #259: deleteSeries cascades to series_tag', () => {
       fc.assert(
         fc.property(
           minimalSeriesGen(),
           fc.array(fc.string({ minLength: 1, maxLength: 15 }), { minLength: 1, maxLength: 5 }),
           (series, tags) => {
             const uniqueTags = [...new Set(tags)]
             const manager = new TagCascadeManager()
             const id = manager.createSeries(series)

             for (const tag of uniqueTags) {
               manager.addTag(id, tag)
             }

             expect(manager.getTagsForSeries(id).length).toBe(uniqueTags.length)

             manager.deleteSeriesWithCascade(id)

             expect(manager.getTagsForSeries(id).length).toBe(0)  // weak
           }
         )
       )
     })
   })
   ```

2. **TagCascadeManager class** - tests/fuzz/properties/series.test.ts:1085-1125:
   ```typescript
   class TagCascadeManager extends AdaptiveDurationCascadeManager {
     private seriesTags: Map<SeriesId, Set<string>> = new Map()
     private tagToSeries: Map<string, Set<SeriesId>> = new Map()

     override addTag(seriesId: SeriesId, tag: string): void {
       // Add to series -> tags map
       const tags = this.seriesTags.get(seriesId) ?? new Set()
       tags.add(tag)
       this.seriesTags.set(seriesId, tags)

       // Add to tag -> series map (bidirectional)
       const seriesSet = this.tagToSeries.get(tag) ?? new Set()
       seriesSet.add(seriesId)
       this.tagToSeries.set(tag, seriesSet)
     }

     getTagsForSeries(seriesId: SeriesId): string[] {
       return Array.from(this.seriesTags.get(seriesId) ?? [])
     }

     deleteTagsForSeries(seriesId: SeriesId): void {
       const tags = this.seriesTags.get(seriesId)
       if (tags) {
         for (const tag of tags) {
           const seriesSet = this.tagToSeries.get(tag)
           if (seriesSet) {
             seriesSet.delete(seriesId)
             if (seriesSet.size === 0) {
               this.tagToSeries.delete(tag)
             }
           }
         }
       }
       this.seriesTags.delete(seriesId)
     }

     override deleteSeriesWithCascade(id: SeriesId): boolean {
       this.deleteTagsForSeries(id)  // Delete tags first
       return super.deleteSeriesWithCascade(id)
     }
   }
   ```

The implementation maintains a bidirectional map (series→tags and tag→series) that must be properly cleaned up.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #259: deleteSeries cascades to series_tag', () => {
  fc.assert(
    fc.property(
      minimalSeriesGen(),
      fc.array(fc.string({ minLength: 1, maxLength: 15 }), { minLength: 1, maxLength: 5 }),
      (series, tags) => {
        const uniqueTags = [...new Set(tags)]
        const manager = new TagCascadeManager()
        const id = manager.createSeries(series)

        for (const tag of uniqueTags) {
          manager.addTag(id, tag)
        }

        // Verify tags exist before deletion
        const tagsBefore = manager.getTagsForSeries(id)
        expect(tagsBefore).toHaveLength(uniqueTags.length)
        for (const tag of uniqueTags) {
          expect(tagsBefore).toContain(tag)
        }

        // Delete series with cascade
        const deleted = manager.deleteSeriesWithCascade(id)
        expect(deleted).toBe(true)

        // Verify all tags are removed from series
        expect(manager.getTagsForSeries(id)).toEqual([])

        // Verify series is removed from tag lookup
        for (const tag of uniqueTags) {
          expect(manager.getSeriesByTag(tag)).not.toContain(id)
        }
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Replace `.length).toBe(0)` with `.toEqual([])` for clearer intent
2. Replace `.length).toBe(uniqueTags.length)` with `.toHaveLength()`
3. Verify each tag is in the list before deletion
4. Verify the deleteSeriesWithCascade return value
5. Verify bidirectional cleanup (tag→series direction)

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/series.test.ts lines 1130-1180 to examine the violation at line 1146

3. **Read TagCascadeManager class** - Used Read tool on tests/fuzz/properties/series.test.ts lines 1070-1140:
   - Lines 1085-1125: TagCascadeManager class
   - Lines 1086-1087: Bidirectional maps (seriesTags, tagToSeries)
   - Lines 1089-1099: addTag method
   - Lines 1101-1103: getTagsForSeries method
   - Lines 1105-1119: deleteTagsForSeries method
   - Lines 1121-1124: deleteSeriesWithCascade override

---

## Violation #140: tests/fuzz/properties/temporal.test.ts:810

**Test Name:** `Property #380: all input times interpreted as configured timezone`

**Violation Line:**
```typescript
expect(typeof result.utcOffset).toBe('number')
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This property-based test verifies that times are correctly interpreted with the configured timezone, returning proper metadata including UTC offset.

**What functionality or behavior is it verifying?**

The test verifies (lines 785-816):
1. Creates a TimezoneInterpreter with a timezone (line 800)
2. Interprets a time (line 801)
3. Verifies the time is preserved (line 804)
4. Verifies the configured timezone is used (line 807)
5. Verifies utcOffset is a number (line 810) - THIS IS THE VIOLATION
6. Verifies utcOffset is within valid range -12 to +14 (lines 811-812)

**Why does this specific test matter?**

Timezone interpretation is critical for scheduling medications correctly across time zones.

**What are the consequences if this test is wrong or weak?**

The `typeof result.utcOffset).toBe('number')` assertion is weak because:
1. TypeScript already guarantees utcOffset is a number (return type at line 723)
2. Lines 811-812 already verify the value is in a valid range
3. If the range assertions pass, the typeof assertion must also pass
4. The typeof check is redundant with the stronger assertions on the next lines

**Why does getting it right matter?**

For medically fragile people:
- Timezone interpretation affects when medications are scheduled
- Incorrect offsets could shift medication times by hours
- UTC offset validation ensures accurate time conversion

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **Test context** - tests/fuzz/properties/temporal.test.ts:784-816:
   ```typescript
   describe('Spec 1: Temporal Types - Timezone Configuration', () => {
     it('Property #380: all input times interpreted as configured timezone', () => {
       const timezones = [
         'America/New_York', 'America/Chicago', 'America/Denver',
         'America/Los_Angeles', 'UTC', 'Europe/London',
       ]

       fc.assert(
         fc.property(
           fc.constantFrom(...timezones),
           localTimeGen(),
           (timezone, time) => {
             const interpreter = new TimezoneInterpreter(timezone)
             const result = interpreter.interpretTime(time)

             expect(result.time).toBe(time)
             expect(result.timezone).toBe(timezone)
             expect(typeof result.utcOffset).toBe('number')  // weak - redundant
             expect(result.utcOffset).toBeGreaterThanOrEqual(-12)  // strong
             expect(result.utcOffset).toBeLessThanOrEqual(14)     // strong
           }
         )
       )
     })
   })
   ```

2. **TimezoneInterpreter class** - tests/fuzz/properties/temporal.test.ts:716-782:
   ```typescript
   class TimezoneInterpreter {
     constructor(private configuredTimezone: string) {}

     interpretTime(time: LocalTime): { time: LocalTime; timezone: string; utcOffset: number } {
       const utcOffset = this.getUTCOffset(this.configuredTimezone)
       return {
         time,
         timezone: this.configuredTimezone,
         utcOffset,  // typed as number
       }
     }

     private getUTCOffset(timezone: string): number {
       const offsets: Record<string, number> = {
         'America/New_York': -5,
         'America/Chicago': -6,
         'America/Denver': -7,
         'America/Los_Angeles': -8,
         'UTC': 0,
         'Europe/London': 0,
         'Europe/Paris': 1,
         'Asia/Tokyo': 9,
       }
       return offsets[timezone] ?? 0
     }
   }
   ```

The return type explicitly declares `utcOffset: number`, making the typeof check redundant.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('Property #380: all input times interpreted as configured timezone', () => {
  const timezones = [
    'America/New_York', 'America/Chicago', 'America/Denver',
    'America/Los_Angeles', 'UTC', 'Europe/London',
  ]

  fc.assert(
    fc.property(
      fc.constantFrom(...timezones),
      localTimeGen(),
      (timezone, time) => {
        const interpreter = new TimezoneInterpreter(timezone)
        const result = interpreter.interpretTime(time)

        // Verify time is preserved
        expect(result.time).toBe(time)

        // Verify timezone is used
        expect(result.timezone).toBe(timezone)

        // Verify UTC offset is within valid range
        expect(result.utcOffset).toBeGreaterThanOrEqual(-12)
        expect(result.utcOffset).toBeLessThanOrEqual(14)

        // Verify offset matches expected for this timezone
        const expectedOffsets: Record<string, number> = {
          'America/New_York': -5,
          'America/Chicago': -6,
          'America/Denver': -7,
          'America/Los_Angeles': -8,
          'UTC': 0,
          'Europe/London': 0,
        }
        expect(result.utcOffset).toBe(expectedOffsets[timezone])
      }
    )
  )
})
```

**What specific changes would transform this test into its ideal form?**

1. Remove `typeof x).toBe('number')` - TypeScript handles this and range checks are stronger
2. Keep the range checks (they're already strong assertions)
3. Add verification that the offset matches expected values for each timezone
4. The `.toBeGreaterThanOrEqual()` and `.toBeLessThanOrEqual()` assertions are good

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/fuzz/properties/temporal.test.ts lines 795-845 to examine the violation at line 810

3. **Search for TimezoneInterpreter** - Used Grep tool with pattern "class TimezoneInterpreter" found at line 716

4. **Read TimezoneInterpreter class** - Used Read tool on tests/fuzz/properties/temporal.test.ts lines 710-775:
   - Lines 716-782: TimezoneInterpreter class
   - Lines 723-732: interpretTime method with typed return { utcOffset: number }
   - Lines 761-774: getUTCOffset method with timezone offset mappings

---

## REPORT-131-140 COMPLETE

All 10 violations (#131-#140) have been analyzed in this report file.
