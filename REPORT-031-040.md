# REPORT-031-040: WEAK_ASSERTION Violation Analysis

This report contains detailed analysis of violations #31-40 as specified in REPORT-SPEC.md.

---

## Violation #31: tests/10-reminders.test.ts:326

**Test Name:** `acknowledged not in pending`

**Violation Line:**
```typescript
expect(forOurInstance).toHaveLength(0); // Acknowledged - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 6 from the reminders specification: "Excludes acknowledged reminders" (notes/testing-spec-10-reminders.md:82) and POST 2: "Reminder no longer appears in getPendingReminders for that instance" (notes/testing-spec-10-reminders.md:106). Once a reminder is acknowledged for a specific instance, it should not appear in the pending reminders list.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created with minutesBefore=15 (lines 308-312)
2. The reminder is acknowledged for instance date '2024-01-15' (line 316)
3. When `getPendingReminders` is called at 08:50 (after fire time of 08:45)
4. The acknowledged reminder is NOT in the pending results (lines 323-326)

**Why does this specific test matter?**

Acknowledgments prevent repeated notifications. If acknowledged reminders continued appearing:
- Users would see the same reminder multiple times
- Alert fatigue would increase
- The acknowledgment system would be useless

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that acknowledgment filtering works
2. It doesn't verify the reminder WOULD appear if not acknowledged
3. It doesn't verify via `isReminderAcknowledged`
4. Could pass if `getPendingReminders` always returns `[]`

It could pass when:
- `getPendingReminders` is broken
- The reminder was never created
- The acknowledgment was never recorded
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, duplicate reminders could:
- Cause confusion about whether a task was already done
- Lead to double-administration of medications
- Create alert fatigue reducing responsiveness to real alerts

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 6** - notes/testing-spec-10-reminders.md:82 states "LAW 6: Excludes acknowledged reminders"

2. **POST 2** - notes/testing-spec-10-reminders.md:106 states "POST 2: Reminder no longer appears in getPendingReminders for that instance"

3. **getPendingReminders Definition** - notes/testing-spec-10-reminders.md:66-75 shows the algorithm:
   ```
   getPendingReminders(asOf) =
     ...
     if fireTime ≤ asOf AND not isAcknowledged(r.id, i.instanceDate)
     yield { ... }
   ```
   Line 73 explicitly checks `not isAcknowledged(r.id, i.instanceDate)`

4. **acknowledgeReminder Signature** - notes/testing-spec-10-reminders.md:93 defines `acknowledgeReminder(reminderId: ReminderId, instanceDate: LocalDate): void`

5. **Test Plan Reference** - notes/test-plan-10.md:63 states "acknowledged not in pending | acknowledge, query | Not returned | LAW 6"

6. **LAW 10** - notes/testing-spec-10-reminders.md:112 states "LAW 10: Acknowledgment is idempotent"

7. **LAW 11** - notes/testing-spec-10-reminders.md:113 states "LAW 11: Acknowledging doesn't affect other instances of same series"

8. **isReminderAcknowledged Signature** - notes/testing-spec-10-reminders.md:122 defines `isReminderAcknowledged(reminderId: ReminderId, instanceDate: LocalDate): boolean`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify acknowledgment state and compare with unacknowledged behavior:

```typescript
it('acknowledged not in pending', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error('Setup failed');

  const reminderId = createResult.value.id;
  const instanceDate = parseDate('2024-01-15');

  // Verify reminder exists
  const reminder = await getReminder(adapter, reminderId);
  expect(reminder).not.toBeNull();

  // First, verify reminder WOULD appear if not acknowledged
  const pendingBefore = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const beforeAck = pendingBefore.filter(p =>
    p.instanceDate === instanceDate && p.reminderId === reminderId
  );
  expect(beforeAck).toHaveLength(1);
  expect(beforeAck[0].tag).toBe('test');

  // Now acknowledge
  await acknowledgeReminder(adapter, reminderId, instanceDate);

  // Verify acknowledgment was recorded
  const isAcked = await isReminderAcknowledged(adapter, reminderId, instanceDate);
  expect(isAcked).toBe(true);

  // LAW 6: Now verify it's excluded from pending
  const pendingAfter = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const afterAck = pendingAfter.filter(p =>
    p.instanceDate === instanceDate && p.reminderId === reminderId
  );
  expect(afterAck).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-ack: `expect(beforeAck).toHaveLength(1)` - Reminder appears before acknowledgment
2. Pre-ack: `expect(beforeAck[0].tag).toBe('test')` - Correct reminder
3. Post-ack: `expect(isAcked).toBe(true)` - Acknowledgment recorded
4. Post-ack: `expect(afterAck).toEqual([])` - No longer in pending

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the reminder appears in pending BEFORE acknowledgment
- Confirms acknowledgment was actually recorded via isReminderAcknowledged
- Tests the before/after state change
- Cannot pass if `getPendingReminders` always returns []
- Cannot pass if acknowledgment wasn't recorded

**What specific changes would transform this test into its ideal form?**

Add before line 316 (before acknowledgeReminder):
```typescript
// Verify reminder appears before acknowledgment
const pendingBefore = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T08:50:00'),
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const beforeAck = pendingBefore.filter(p =>
  p.instanceDate === parseDate('2024-01-15') && p.reminderId === createResult.value.id
);
expect(beforeAck).toHaveLength(1);
```

Add after line 316 (after acknowledgeReminder):
```typescript
// Verify acknowledgment was recorded
const isAcked = await isReminderAcknowledged(adapter, createResult.value.id, parseDate('2024-01-15'));
expect(isAcked).toBe(true);
```

Replace lines 323-326:
```typescript
const forOurInstance = pending.filter(p =>
  p.instanceDate === parseDate('2024-01-15') && p.reminderId === createResult.value.id
);
expect(forOurInstance).toHaveLength(0);
```

With:
```typescript
const forOurInstance = pending.filter(p =>
  p.instanceDate === parseDate('2024-01-15') && p.reminderId === createResult.value.id
);
expect(forOurInstance).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 310-359 to examine the exact violation at line 326 and full test context

3. **Check for existing report file** - Used Glob tool with pattern `REPORT-031-040.md` - file did not exist, needed to create it

4. **Search for LAW 6 and acknowledgment specification** - Used Grep tool with pattern `LAW 6|acknowledged.*pending|excludes acknowledged` (case insensitive) in notes directory, finding many files

5. **Search specifically for LAW 6 in reminders spec** - Used Grep tool with pattern `LAW 6.*acknowledged|Excludes acknowledged|acknowledged.*excluded` in notes/testing-spec-10-reminders.md, finding:
   - Line 82: LAW 6: Excludes acknowledged reminders

6. **Read acknowledgment specification** - Used Read tool on notes/testing-spec-10-reminders.md lines 78-127 to find:
   - Lines 81-86: LAW 5-9 (pending reminder properties)
   - Lines 93-115: acknowledgeReminder specification with POST 1-2, LAW 10-12
   - Lines 122: isReminderAcknowledged signature

7. **Read getPendingReminders algorithm** - Used Read tool on notes/testing-spec-10-reminders.md lines 63-82 to find:
   - Lines 66-75: Algorithm definition showing `not isAcknowledged` check at line 73

8. **Search test plan reference** - Used Grep tool with pattern `acknowledged.*not.*pending|acknowledged.*excluded|LAW 6` in notes/test-plan-10.md, finding:
   - Line 63: "acknowledged not in pending | acknowledge, query | Not returned | LAW 6"
   - Line 64: "unacknowledged in pending | don't acknowledge | Returned | LAW 6"

---

## Violation #32: tests/10-reminders.test.ts:362

**Test Name:** `cancelled instance excluded`

**Violation Line:**
```typescript
expect(forCancelled).toHaveLength(0); // Cancelled instance - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 7 from the reminders specification: "Excludes reminders for cancelled instances" (notes/testing-spec-10-reminders.md:83). When an instance is cancelled via `cancelInstance`, reminders for that instance should not appear in the pending reminders list.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created for the series (lines 348-352)
2. The instance on '2024-01-15' is cancelled (line 354)
3. When `getPendingReminders` is called at 08:50 (after fire time of 08:45)
4. Reminders for the cancelled instance are NOT returned (lines 361-362)

**Why does this specific test matter?**

Reminders for cancelled instances should never fire. If they appeared in pending:
- Users would be reminded about tasks that were intentionally removed
- Alert would be confusing and irrelevant
- The cancellation system would be undermined

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that cancellation filtering works
2. It doesn't verify the reminder WOULD appear if not cancelled
3. It doesn't verify the instance was actually cancelled
4. Could pass if `getPendingReminders` always returns `[]`

It could pass when:
- `getPendingReminders` is broken
- The reminder was never created
- The cancellation didn't happen
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, reminders for cancelled instances could:
- Alert caregivers about tasks that were intentionally skipped
- Cause confusion about the current care plan
- Lead to performing cancelled tasks

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 7** - notes/testing-spec-10-reminders.md:83 states "LAW 7: Excludes reminders for cancelled instances"

2. **B5** - notes/testing-spec-10-reminders.md:194 states "B5: Cancelled instance → no reminder fires"

3. **Verification Strategy** - notes/testing-spec-10-reminders.md:212 states "Cancelled instance → reminder not in pending"

4. **Test Plan Reference** - notes/test-plan-10.md:70 states "cancelled instance excluded | cancel instance | Reminder not pending | LAW 7"

5. **cancelInstance Signature** - notes/testing-spec-09-instance-exceptions.md:28 defines `cancelInstance(seriesId: SeriesId, instanceDate: LocalDate): void`

6. **Cancellation Effect** - notes/testing-spec-09-instance-exceptions.md:43 (POST 2) states "Instance no longer appears in schedule"

7. **getPendingReminders Algorithm** - notes/testing-spec-10-reminders.md:66-75 shows the algorithm iterates over scheduled instances, so cancelled instances (which are excluded from schedule) would naturally not produce pending reminders

8. **LAW 1 (Instance Exceptions)** - notes/testing-spec-09-instance-exceptions.md:50 states "LAW 1: Cancelled instance excluded from getSchedule results"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify cancellation state and compare with non-cancelled behavior:

```typescript
it('cancelled instance excluded', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);

  const instanceDate = parseDate('2024-01-15');

  // First, verify reminder WOULD appear for non-cancelled instance
  const pendingBefore = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const beforeCancel = pendingBefore.filter(p => p.instanceDate === instanceDate);
  expect(beforeCancel).toHaveLength(1);
  expect(beforeCancel[0].tag).toBe('test');

  // Now cancel the instance
  await cancelInstance(adapter, testSeriesId, instanceDate);

  // Verify the instance is actually cancelled
  const exception = await getException(adapter, testSeriesId, instanceDate);
  expect(exception).not.toBeNull();
  expect(exception?.type).toBe('cancelled');

  // LAW 7: Now verify reminder is excluded
  const pendingAfter = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const afterCancel = pendingAfter.filter(p => p.instanceDate === instanceDate);
  expect(afterCancel).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-cancel: `expect(beforeCancel).toHaveLength(1)` - Reminder appears before cancellation
2. Pre-cancel: `expect(beforeCancel[0].tag).toBe('test')` - Correct reminder
3. Post-cancel: `expect(exception?.type).toBe('cancelled')` - Instance is cancelled
4. Post-cancel: `expect(afterCancel).toEqual([])` - No longer in pending

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the reminder appears in pending BEFORE cancellation
- Confirms the instance was actually cancelled via getException
- Tests the before/after state change
- Cannot pass if `getPendingReminders` always returns []
- Cannot pass if cancellation didn't happen

**What specific changes would transform this test into its ideal form?**

Add after line 352 (after createReminder):
```typescript
// Verify reminder appears before cancellation
const pendingBefore = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T08:50:00'),
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const beforeCancel = pendingBefore.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(beforeCancel).toHaveLength(1);
```

Add after line 354 (after cancelInstance):
```typescript
// Verify the instance is actually cancelled
const exception = await getException(adapter, testSeriesId, parseDate('2024-01-15'));
expect(exception).not.toBeNull();
expect(exception?.type).toBe('cancelled');
```

Replace line 362:
```typescript
expect(forCancelled).toHaveLength(0);
```

With:
```typescript
expect(forCancelled).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 346-395 to examine the exact violation at line 362 and full test context

3. **Search for LAW 7 specification** - Used Grep tool with pattern `LAW 7|cancelled.*instance.*excluded|excludes.*cancelled` in notes/testing-spec-10-reminders.md, finding:
   - Line 83: LAW 7: Excludes reminders for cancelled instances

4. **Search test plan reference** - Used Grep tool with pattern `cancelled.*instance.*excluded|cancelled.*excluded|LAW 7` in notes/test-plan-10.md, finding:
   - Line 70: "cancelled instance excluded | cancel instance | Reminder not pending | LAW 7"

5. **Search for cancelled instance mentions** - Used Grep tool with pattern `cancelled.*instance|Cancelled instance|B5.*cancelled` in notes/testing-spec-10-reminders.md, finding:
   - Line 83: LAW 7
   - Line 194: B5 boundary condition
   - Line 212: Verification strategy

6. **Search for cancelInstance specification** - Used Grep tool with pattern `cancelInstance|cancel.*instance` in notes/testing-spec-09-instance-exceptions.md, finding:
   - Line 28: cancelInstance signature
   - Line 53: LAW 4 about cancel after reschedule
   - Lines 236-239: Error types related to cancellation

---

## Violation #33: tests/10-reminders.test.ts:385

**Test Name:** `completed instance excluded`

**Violation Line:**
```typescript
expect(forCompleted).toHaveLength(0); // Completed instance - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 8 from the reminders specification: "Excludes reminders for completed instances (optional, configurable)" (notes/testing-spec-10-reminders.md:84). When an instance has been completed (via `logCompletion`), reminders for that instance should not appear in the pending reminders list.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created for the series (lines 366-370)
2. A completion is logged for the instance on '2024-01-15' (lines 372-377)
3. When `getPendingReminders` is called at 08:50 (after fire time of 08:45)
4. Reminders for the completed instance are NOT returned (lines 384-385)

**Why does this specific test matter?**

Reminders for completed instances are unnecessary. If they appeared in pending:
- Users would be reminded about tasks already done
- Alert fatigue would increase
- The completion tracking would be undermined

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that completion filtering works
2. It doesn't verify the reminder WOULD appear if not completed
3. It doesn't verify the completion was actually recorded
4. Could pass if `getPendingReminders` always returns `[]`

It could pass when:
- `getPendingReminders` is broken
- The reminder was never created
- The completion wasn't logged
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, reminders for completed instances could:
- Alert caregivers about tasks already performed
- Cause confusion about whether to repeat the task
- Lead to duplicate care actions (dangerous for medications)

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 8** - notes/testing-spec-10-reminders.md:84 states "LAW 8: Excludes reminders for completed instances (optional, configurable)"

2. **Test Plan Reference** - notes/test-plan-10.md:71 states "completed instance excluded | complete instance | Reminder not pending (optional) | LAW 8"

3. **logCompletion Signature** - notes/testing-spec-06-completions.md:36 defines `logCompletion(input: LogCompletionInput): CompletionId`

4. **LAW 1 (Completions)** - notes/testing-spec-06-completions.md:68 states "LAW 1: After logCompletion, getCompletionByInstance(seriesId, instanceDate) ≠ null"

5. **getPendingReminders Algorithm** - notes/testing-spec-10-reminders.md:66-75 shows the algorithm considers whether instances are completed when configured to do so

6. **Configurable Behavior** - The "(optional, configurable)" note in LAW 8 indicates this behavior can be enabled/disabled based on user preferences

7. **LogCompletionInput Type** - notes/testing-spec-06-completions.md:38-44 defines the input structure for logging completions

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify completion state and compare with non-completed behavior:

```typescript
it('completed instance excluded', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);

  const instanceDate = parseDate('2024-01-15');

  // First, verify reminder WOULD appear for non-completed instance
  const pendingBefore = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const beforeComplete = pendingBefore.filter(p => p.instanceDate === instanceDate);
  expect(beforeComplete).toHaveLength(1);
  expect(beforeComplete[0].tag).toBe('test');

  // Now log the completion
  const completionResult = await logCompletion(adapter, {
    seriesId: testSeriesId,
    instanceDate,
    startTime: parseDateTime('2024-01-15T09:00:00'),
    endTime: parseDateTime('2024-01-15T09:30:00'),
  });
  expect(completionResult.ok).toBe(true);

  // Verify the completion was actually recorded
  const completion = await getCompletionByInstance(adapter, testSeriesId, instanceDate);
  expect(completion).not.toBeNull();

  // LAW 8: Now verify reminder is excluded
  const pendingAfter = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const afterComplete = pendingAfter.filter(p => p.instanceDate === instanceDate);
  expect(afterComplete).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-complete: `expect(beforeComplete).toHaveLength(1)` - Reminder appears before completion
2. Pre-complete: `expect(beforeComplete[0].tag).toBe('test')` - Correct reminder
3. Post-complete: `expect(completion).not.toBeNull()` - Completion recorded
4. Post-complete: `expect(afterComplete).toEqual([])` - No longer in pending

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the reminder appears in pending BEFORE completion
- Confirms the completion was actually recorded via getCompletionByInstance
- Tests the before/after state change
- Cannot pass if `getPendingReminders` always returns []
- Cannot pass if completion wasn't logged

**What specific changes would transform this test into its ideal form?**

Add after line 370 (after createReminder):
```typescript
// Verify reminder appears before completion
const pendingBefore = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T08:50:00'),
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const beforeComplete = pendingBefore.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(beforeComplete).toHaveLength(1);
```

Add after line 377 (after logCompletion):
```typescript
// Verify the completion was actually recorded
const completion = await getCompletionByInstance(adapter, testSeriesId, parseDate('2024-01-15'));
expect(completion).not.toBeNull();
```

Replace line 385:
```typescript
expect(forCompleted).toHaveLength(0);
```

With:
```typescript
expect(forCompleted).toEqual([]);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 363-412 to examine the exact violation at line 385 and full test context

3. **Search for LAW 8 specification** - Used Grep tool with pattern `LAW 8|completed.*instance.*excluded|excludes.*completed` in notes/testing-spec-10-reminders.md, finding:
   - Line 84: LAW 8: Excludes reminders for completed instances (optional, configurable)

4. **Search test plan reference** - Used Grep tool with pattern `completed.*instance.*excluded|completed.*excluded|LAW 8` in notes/test-plan-10.md, finding:
   - Line 71: "completed instance excluded | complete instance | Reminder not pending (optional) | LAW 8"

5. **Search for logCompletion specification** - Used Grep tool with pattern `logCompletion|log.*completion` in notes/testing-spec-06-completions.md, finding:
   - Line 36: logCompletion signature
   - Line 68: LAW 1 about completion recording

---

## Violation #34: tests/10-reminders.test.ts:760

**Test Name:** `not original time`

**Violation Line:**
```typescript
expect(forInstance).toHaveLength(0); // Not yet due with rescheduled time
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 20 from the reminders specification: "fireTime respects rescheduled time, not original time" (notes/testing-spec-10-reminders.md:168). When an instance is rescheduled to a later time, the reminder fire time should be calculated based on the new scheduled time, not the original.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created with minutesBefore=15 (lines 743-747)
2. The instance is rescheduled from 09:00 to 10:00 (line 750)
3. Original fire time would be 08:45, new fire time is 09:45
4. Query at 08:50 (after original fire time but before new fire time)
5. Reminder should NOT be pending (lines 759-760)

**Why does this specific test matter?**

Rescheduling an instance should reschedule its reminder too. If the reminder still fired at the original time:
- Users would be reminded too early
- The reschedule wouldn't properly propagate
- Confusion about when the task is actually due

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0, not that rescheduled time is respected
2. It doesn't verify the reminder DOES appear at the new fire time
3. It doesn't verify the reschedule actually happened
4. Could pass if `getPendingReminders` always returns `[]`

It could pass when:
- `getPendingReminders` is broken
- The reminder was never created
- The reschedule didn't happen
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, incorrect reminder timing after reschedule could:
- Alert caregivers too early before the rescheduled time
- Cause confusion about when the task is actually due
- Lead to care being administered at the wrong time

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 20** - notes/testing-spec-10-reminders.md:168 states "LAW 20: fireTime respects rescheduled time, not original time"

2. **LAW 9** - notes/testing-spec-10-reminders.md:85 states "LAW 9: Includes reminders for rescheduled instances (at new time)"

3. **calculateFireTime Definition** - notes/testing-spec-10-reminders.md:155-160:
   ```
   calculateFireTime(instance: ScheduledInstance, reminder: Reminder): LocalDateTime =
     if instance.allDay then
       addMinutes(makeDateTime(instance.date, "00:00:00"), -reminder.minutesBefore)
     else
       addMinutes(instance.scheduledTime, -reminder.minutesBefore)
   ```
   Uses `instance.scheduledTime` which would be the rescheduled time after rescheduling.

4. **Test Plan Reference** - notes/test-plan-10.md:147 states "not original time | original 09:00, rescheduled 10:00 | Based on 10:00 | LAW 20"

5. **B4 Boundary Condition** - notes/testing-spec-10-reminders.md:193 states "B4: Rescheduled instance → reminder fire time recalculated"

6. **LAW 5** - notes/testing-spec-10-reminders.md:81 states "LAW 5: Only returns reminders where fireTime ≤ asOf" - explains why the reminder isn't returned at 08:50 (fire time is 09:45)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

The ideal test would verify fire time calculation at both original and new times:

```typescript
it('not original time', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);

  const instanceDate = parseDate('2024-01-15');

  // Verify reminder appears at original fire time (08:45) BEFORE reschedule
  const pendingBeforeReschedule = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:45:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const beforeReschedule = pendingBeforeReschedule.filter(p => p.instanceDate === instanceDate);
  expect(beforeReschedule).toHaveLength(1);

  // Reschedule from 09:00 to 10:00
  await rescheduleInstance(adapter, testSeriesId, instanceDate, parseDateTime('2024-01-15T10:00:00'));

  // Verify the reschedule happened
  const exception = await getException(adapter, testSeriesId, instanceDate);
  expect(exception).not.toBeNull();
  expect(exception?.type).toBe('rescheduled');
  expect(exception?.newTime).toBe(parseDateTime('2024-01-15T10:00:00'));

  // LAW 20: Query at 08:50 - after original fire time (08:45) but before new fire time (09:45)
  const pendingAtOriginal = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const atOriginalTime = pendingAtOriginal.filter(p => p.instanceDate === instanceDate);
  expect(atOriginalTime).toEqual([]);  // NOT pending - uses rescheduled time

  // Now verify it DOES appear at the new fire time (09:45)
  const pendingAtNew = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T09:45:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const atNewTime = pendingAtNew.filter(p => p.instanceDate === instanceDate);
  expect(atNewTime).toHaveLength(1);
  expect(atNewTime[0].tag).toBe('test');
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-reschedule: `expect(beforeReschedule).toHaveLength(1)` - Reminder at original fire time
2. Post-reschedule: `expect(exception?.type).toBe('rescheduled')` - Reschedule recorded
3. Post-reschedule at original time: `expect(atOriginalTime).toEqual([])` - NOT pending at original
4. Post-reschedule at new time: `expect(atNewTime).toHaveLength(1)` - Pending at new time

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies reminder would appear at original time before reschedule
- Confirms the reschedule was recorded
- Tests both original and new fire times after reschedule
- Cannot pass if `getPendingReminders` always returns []
- Cannot pass if reschedule didn't happen

**What specific changes would transform this test into its ideal form?**

Add before line 750 (before rescheduleInstance):
```typescript
// Verify reminder appears at original fire time before reschedule
const pendingBefore = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T08:45:00'),
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const beforeReschedule = pendingBefore.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(beforeReschedule).toHaveLength(1);
```

Add after line 750 (after rescheduleInstance):
```typescript
// Verify the reschedule happened
const exception = await getException(adapter, testSeriesId, parseDate('2024-01-15'));
expect(exception?.type).toBe('rescheduled');
```

Replace line 760:
```typescript
expect(forInstance).toHaveLength(0);
```

With:
```typescript
expect(forInstance).toEqual([]);

// Verify reminder DOES appear at new fire time (09:45)
const pendingAtNew = await getPendingReminders(adapter, {
  asOf: parseDateTime('2024-01-15T09:45:00'),
  range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
});
const atNewTime = pendingAtNew.filter(p => p.instanceDate === parseDate('2024-01-15'));
expect(atNewTime).toHaveLength(1);
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/10-reminders.test.ts lines 745-794 to examine the exact violation at line 760 and full test context

3. **Read more context** - Used Read tool on tests/10-reminders.test.ts lines 725-769 to find the test name "not original time" starting at line 742

4. **Search for LAW 20 specification** - Used Grep tool with pattern `LAW 20|rescheduled.*time|fireTime.*rescheduled|reschedule.*fire` in notes/testing-spec-10-reminders.md, finding:
   - Line 85: LAW 9 about rescheduled instances
   - Line 168: LAW 20 about fire time respecting rescheduled time

5. **Read fire time calculation specification** - Used Read tool on notes/testing-spec-10-reminders.md lines 150-179 to find:
   - Lines 155-160: calculateFireTime function definition
   - Lines 166-170: LAW 18-22 about fire time properties

6. **Search test plan reference** - Used Grep tool with pattern `not original time|LAW 20|rescheduled.*time` in notes/test-plan-10.md, finding:
   - Line 72: rescheduled instance included test case
   - Line 146: uses rescheduled time test case
   - Line 147: not original time test case
   - Line 166: B4 boundary condition about reschedule

---

## Violation #35: tests/10-reminders.test.ts:895

**Test Name:** `B5: cancelled no reminder`

**Violation Line:**
```typescript
expect(forCancelled).toHaveLength(0); // Cancelled - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies boundary condition B5 from the reminders specification: "Cancelled instance → no reminder fires" (notes/testing-spec-10-reminders.md:194). When an instance is cancelled, no reminders should be generated for it.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created for the series (lines 881-885)
2. The instance on '2024-01-15' is cancelled (line 887)
3. When `getPendingReminders` is called at 08:50
4. Reminders for the cancelled instance are NOT returned (lines 894-895)

**Why does this specific test matter?**

This is a boundary condition test ensuring cancelled instances produce no reminders. If reminders appeared:
- Users would be reminded about cancelled tasks
- The cancellation would be ineffective
- Confusion about the schedule

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the cancellation happened
3. It doesn't verify reminder would appear without cancellation
4. Could pass if `getPendingReminders` always returns `[]`

**Why does getting it right matter?**

For medically fragile people, reminders for cancelled instances could:
- Alert caregivers about tasks intentionally removed
- Cause confusion about the care plan
- Lead to unnecessary care actions

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **B5** - notes/testing-spec-10-reminders.md:194 states "B5: Cancelled instance → no reminder fires"

2. **LAW 7** - notes/testing-spec-10-reminders.md:83 states "LAW 7: Excludes reminders for cancelled instances"

3. **Test Plan Reference** - notes/test-plan-10.md:167 states "cancelled no reminder | cancel | No pending | B5"

4. **cancelInstance** - notes/testing-spec-09-instance-exceptions.md:28 defines `cancelInstance(seriesId: SeriesId, instanceDate: LocalDate): void`

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('B5: cancelled no reminder', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'test',
  });
  expect(createResult.ok).toBe(true);

  const instanceDate = parseDate('2024-01-15');

  // Verify reminder appears before cancellation
  const pendingBefore = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  expect(pendingBefore.filter(p => p.instanceDate === instanceDate)).toHaveLength(1);

  await cancelInstance(adapter, testSeriesId, instanceDate);

  // Verify cancellation
  const exception = await getException(adapter, testSeriesId, instanceDate);
  expect(exception?.type).toBe('cancelled');

  // B5: Cancelled instance - no reminder
  const pending = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  expect(pending.filter(p => p.instanceDate === instanceDate)).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-cancel: Reminder appears before cancellation
2. Post-cancel: Verify cancellation recorded
3. Post-cancel: `expect(...).toEqual([])` - No reminders for cancelled instance

**How would the ideal test avoid being weak or tautological?**

- Verifies reminder exists before cancellation
- Confirms cancellation was recorded
- Cannot pass if getPendingReminders always returns []

**What specific changes would transform this test into its ideal form?**

Add before line 887: verification that reminder appears before cancellation
Add after line 887: verification that cancellation was recorded
Replace line 895 with `expect(forCancelled).toEqual([]);`

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on tests/10-reminders.test.ts lines 880-929 to examine violation at line 895

3. **Search for B5 specification** - Used Grep tool with pattern `B5.*cancelled|cancelled.*no reminder` in notes/testing-spec-10-reminders.md and notes/test-plan-10.md, finding:
   - test-plan-10.md:167: "cancelled no reminder | cancel | No pending | B5"

4. **Read boundary conditions** - Used Read tool on notes/testing-spec-10-reminders.md lines 185-204 to find:
   - Line 194: B5: Cancelled instance → no reminder fires

---

## Violation #36: tests/10-reminders.test.ts:1062

**Test Name:** `15-min meeting reminder early`

**Violation Line:**
```typescript
expect(forInstance).toHaveLength(0); // Not yet due - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 5 from the reminders specification: "Only returns reminders where fireTime ≤ asOf" (notes/testing-spec-10-reminders.md:81). A 15-minute reminder for a 09:00 meeting fires at 08:45. Querying at 08:30 should return nothing.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A reminder is created with minutesBefore=15 for a meeting (lines 1049-1053)
2. Meeting is at 09:00, so fire time is 08:45
3. Query at 08:30 (before fire time)
4. Reminder should NOT be pending (lines 1061-1062)

**Why does this specific test matter?**

This tests a real-world scenario: meeting reminder timing. Users shouldn't be notified too early.

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the reminder WOULD appear at the correct time
3. Could pass if `getPendingReminders` always returns `[]`

**Why does getting it right matter?**

For medically fragile people, premature reminders could:
- Cause confusion about timing
- Lead to care being administered too early

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 5** - notes/testing-spec-10-reminders.md:81 states "LAW 5: Only returns reminders where fireTime ≤ asOf"

2. **getPendingReminders Algorithm** - notes/testing-spec-10-reminders.md:73 shows `if fireTime ≤ asOf AND not isAcknowledged(...)`

3. **Test Plan Reference** - notes/test-plan-10.md:192 states "15-min meeting reminder early | meeting 09:00, 15min reminder | 08:30 | Not pending"

4. **Verification Strategy** - notes/testing-spec-10-reminders.md:209 states "Reminder not yet due → not in pending"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('15-min meeting reminder early', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'meeting',
  });
  expect(createResult.ok).toBe(true);

  const instanceDate = parseDate('2024-01-15');

  // Query at 08:30 - not yet due (fire time is 08:45)
  const pendingEarly = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:30:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  expect(pendingEarly.filter(p => p.instanceDate === instanceDate)).toEqual([]);

  // Verify it DOES appear at 08:45
  const pendingOnTime = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:45:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  const atFireTime = pendingOnTime.filter(p => p.instanceDate === instanceDate);
  expect(atFireTime).toHaveLength(1);
  expect(atFireTime[0].tag).toBe('meeting');
});
```

**What assertions would perfectly verify the intended behavior?**

1. At 08:30: `expect(...).toEqual([])` - Not yet pending
2. At 08:45: `expect(...).toHaveLength(1)` - Now pending
3. At 08:45: Verify correct tag

**How would the ideal test avoid being weak or tautological?**

- Tests both before and at fire time
- Cannot pass if getPendingReminders always returns []

**What specific changes would transform this test into its ideal form?**

Replace line 1062 with `expect(forInstance).toEqual([]);` and add verification at fire time.

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on tests/10-reminders.test.ts lines 1045-1094

3. **Search for LAW 5 specification** - Used Grep tool with pattern `LAW 5|fireTime.*asOf|not yet due` in notes/testing-spec-10-reminders.md, finding:
   - Line 73: Algorithm condition
   - Line 81: LAW 5
   - Line 209: Verification strategy

4. **Search test plan reference** - Used Grep tool with pattern `15-min meeting|meeting reminder early|not yet due` in notes/test-plan-10.md, finding:
   - Line 55: reminder not yet due
   - Lines 191-192: 15-min meeting reminder tests

---

## Violation #37: tests/10-reminders.test.ts:1086

**Test Name:** `acknowledge dismisses`

**Violation Line:**
```typescript
expect(forInstance).toHaveLength(0); // Acknowledged - correctly excluded
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 6 from the reminders specification: "Excludes acknowledged reminders" (notes/testing-spec-10-reminders.md:82). Once a meeting reminder is acknowledged, it should not appear in pending reminders.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A meeting reminder is created with minutesBefore=15 (lines 1066-1070)
2. The reminder is acknowledged for '2024-01-15' (line 1075)
3. Query at 08:50 (after fire time of 08:45)
4. The acknowledged reminder is NOT returned (lines 1083-1086)

**Why does this specific test matter?**

Acknowledgment dismisses reminders. If acknowledged reminders reappeared:
- Users would see the same notification again
- The acknowledgment system would be useless
- Alert fatigue would increase

**What are the consequences if this test is wrong or weak?**

The `toHaveLength(0)` assertion is weak because:
1. It only verifies the count is 0
2. It doesn't verify the reminder WOULD appear without acknowledgment
3. It doesn't verify acknowledgment was recorded
4. Could pass if `getPendingReminders` always returns `[]`

**Why does getting it right matter?**

For medically fragile people, duplicate notifications could:
- Cause confusion about whether the reminder was already handled
- Lead to duplicate care actions

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 6** - notes/testing-spec-10-reminders.md:82 states "LAW 6: Excludes acknowledged reminders"

2. **Test Plan Reference** - notes/test-plan-10.md:193 states "acknowledge dismisses | acknowledge at 08:46 | 08:50 | Not pending"

3. **acknowledgeReminder** - notes/testing-spec-10-reminders.md:93 defines `acknowledgeReminder(reminderId: ReminderId, instanceDate: LocalDate): void`

4. **POST 2** - notes/testing-spec-10-reminders.md:106 states "POST 2: Reminder no longer appears in getPendingReminders for that instance"

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('acknowledge dismisses', async () => {
  const createResult = await createReminder(adapter, {
    seriesId: testSeriesId,
    minutesBefore: 15,
    tag: 'meeting',
  });
  expect(createResult.ok).toBe(true);
  if (!createResult.ok) throw new Error('Setup failed');

  const reminderId = createResult.value.id;
  const instanceDate = parseDate('2024-01-15');

  // Verify reminder is pending before acknowledgment
  const pendingBefore = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  expect(pendingBefore.filter(p => p.reminderId === reminderId)).toHaveLength(1);

  // Acknowledge
  await acknowledgeReminder(adapter, reminderId, instanceDate);

  // Verify acknowledgment recorded
  const isAcked = await isReminderAcknowledged(adapter, reminderId, instanceDate);
  expect(isAcked).toBe(true);

  // LAW 6: Now excluded
  const pending = await getPendingReminders(adapter, {
    asOf: parseDateTime('2024-01-15T08:50:00'),
    range: { start: instanceDate, end: instanceDate },
  });
  expect(pending.filter(p => p.reminderId === reminderId)).toEqual([]);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-ack: Reminder pending
2. Post-ack: `isReminderAcknowledged` returns true
3. Post-ack: Reminder not in pending

**How would the ideal test avoid being weak or tautological?**

- Tests before/after acknowledgment
- Verifies acknowledgment was recorded
- Cannot pass if getPendingReminders always returns []

**What specific changes would transform this test into its ideal form?**

Add verification that reminder was pending before acknowledgment and that acknowledgment was recorded.

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159)

2. **Read the specific test** - Used Read tool on tests/10-reminders.test.ts lines 1065-1104

3. **Search test plan reference** - Used Grep tool with pattern `acknowledge dismisses|LAW 6|acknowledged.*excluded` in notes/test-plan-10.md, finding:
   - Line 63: acknowledged not in pending
   - Line 193: acknowledge dismisses

4. **Search for LAW 6** - Used Grep tool with pattern `LAW 6|Excludes acknowledged` in notes/testing-spec-10-reminders.md, finding:
   - Line 82: LAW 6: Excludes acknowledged reminders

---

## Violation #38: tests/11-links.test.ts:286

**Test Name:** `unlink removes relationship`

**Violation Line:**
```typescript
expect(childLinks).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies POST 3 from the links specification: "Link removed" (notes/testing-spec-11-links.md:86). When `unlinkSeries` is called on a child series, the parent-child link should be completely removed.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A parent series is created (line 273)
2. A child series is created (line 274)
3. The child is linked to the parent (lines 276-280)
4. The child is unlinked (line 282)
5. After unlinking, no links exist for that child (lines 284-286)

**Why does this specific test matter?**

Unlinking allows series to become independent again. If unlink didn't remove the relationship:
- The child would remain dependent on the parent
- Scheduling would still be relative instead of independent
- Users couldn't detach chains when needed

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the array is empty, not that a link existed before
2. It doesn't verify the link was actually created before unlinking
3. Could pass if `linkSeries` never worked
4. Could pass if `getAllLinks` always returns `[]`

It could pass when:
- `linkSeries` is broken
- `getAllLinks` is broken
- The filter is wrong
- Some other bug causes empty results

**Why does getting it right matter?**

For medically fragile people, chain relationships are important:
- Treatment chains ensure proper sequencing
- Unable to unlink could trap users in incorrect chains
- Proper unlinking allows care plan flexibility

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **unlinkSeries Signature** - notes/testing-spec-11-links.md:76 defines `unlinkSeries(childId: SeriesId): void`

2. **PRE 6** - notes/testing-spec-11-links.md:81 states "PRE 6: Child has a parent link"

3. **POST 3** - notes/testing-spec-11-links.md:86 states "POST 3: Link removed"

4. **POST 4** - notes/testing-spec-11-links.md:87 states "POST 4: Child scheduling returns to independent"

5. **Test Plan Reference** - notes/test-plan-11.md:48 states "unlink removes relationship | link then unlink | Link gone | POST 3"

6. **getAllLinks** - notes/testing-spec-11-links.md:97 defines `getAllLinks(): Link[]`

7. **Cascade Behavior LAW 20** - notes/testing-spec-11-links.md:227 states "LAW 20: Delete child → link deleted (CASCADE)"

8. **Link Type** - notes/testing-spec-11-links.md:14-21 defines the Link structure with childSeriesId, parentSeriesId, targetDistance, etc.

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('unlink removes relationship', async () => {
  const parentId = await createTestSeries('Parent');
  const childId = await createTestSeries('Child');

  // Create the link
  const linkResult = await linkSeries(adapter, {
    parentSeriesId: parentId,
    childSeriesId: childId,
    targetDistance: 15,
  });
  expect(linkResult.ok).toBe(true);

  // Verify link exists before unlink
  const allLinksBefore = await getAllLinks(adapter);
  const linksBefore = allLinksBefore.filter(l => l.childSeriesId === childId);
  expect(linksBefore).toHaveLength(1);
  expect(linksBefore[0].parentSeriesId).toBe(parentId);
  expect(linksBefore[0].targetDistance).toBe(15);

  // Also verify via getLinkByChild
  const linkByChild = await getLinkByChild(adapter, childId);
  expect(linkByChild).not.toBeNull();
  expect(linkByChild?.parentSeriesId).toBe(parentId);

  // POST 3: Now unlink
  const unlinkResult = await unlinkSeries(adapter, childId);
  expect(unlinkResult.ok).toBe(true);

  // Verify link is removed
  const allLinksAfter = await getAllLinks(adapter);
  const linksAfter = allLinksAfter.filter(l => l.childSeriesId === childId);
  expect(linksAfter).toEqual([]);

  // Also verify via getLinkByChild (LAW 4)
  const linkByChildAfter = await getLinkByChild(adapter, childId);
  expect(linkByChildAfter).toBeNull();
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-unlink: `expect(linkResult.ok).toBe(true)` - Link creation succeeded
2. Pre-unlink: `expect(linksBefore).toHaveLength(1)` - Link exists
3. Pre-unlink: `expect(linksBefore[0].parentSeriesId).toBe(parentId)` - Correct parent
4. Pre-unlink: `expect(linkByChild).not.toBeNull()` - Link queryable by child
5. Post-unlink: `expect(unlinkResult.ok).toBe(true)` - Unlink succeeded
6. Post-unlink: `expect(linksAfter).toEqual([])` - Link removed from getAllLinks
7. Post-unlink: `expect(linkByChildAfter).toBeNull()` - getLinkByChild returns null (LAW 4)

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the link was created successfully
- Confirms the link exists BEFORE unlinking (via both getAllLinks and getLinkByChild)
- Verifies actual link properties (parentSeriesId, targetDistance)
- Tests the before/after state change
- Cannot pass if `linkSeries` doesn't work
- Cannot pass if `getAllLinks` always returns []
- Uses multiple query methods to verify removal

**What specific changes would transform this test into its ideal form?**

Add after line 280 (after linkSeries):
```typescript
// Verify link exists before unlink
const allLinksBefore = await getAllLinks(adapter);
const linksBefore = allLinksBefore.filter(l => l.childSeriesId === childId);
expect(linksBefore).toHaveLength(1);
expect(linksBefore[0].parentSeriesId).toBe(parentId);

const linkByChild = await getLinkByChild(adapter, childId);
expect(linkByChild).not.toBeNull();
```

Add after line 282 (after unlinkSeries):
```typescript
// Verify getLinkByChild also returns null (LAW 4)
const linkByChildAfter = await getLinkByChild(adapter, childId);
expect(linkByChildAfter).toBeNull();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/11-links.test.ts lines 270-319 to examine the exact violation at line 286 and full test context

3. **Read the links specification** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/notes/testing-spec-11-links.md (full file, lines 1-305) to find:
   - Line 76: unlinkSeries signature
   - Lines 79-88: PRE 6 and POST 3-4
   - Line 97: getAllLinks signature
   - Lines 14-21: Link type definition
   - Line 227: LAW 20 about cascade deletion

4. **Search test plan reference** - Used Grep tool with pattern `unlink removes relationship|POST 3|Link gone` in notes/test-plan-11.md, finding:
   - Line 48: "unlink removes relationship | link then unlink | Link gone | POST 3"

---

## Violation #39: tests/11-links.test.ts:304

**Test Name:** `unlinked child independent`

**Violation Line:**
```typescript
expect(childLinks).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies POST 4 from the links specification: "Child scheduling returns to independent" (notes/testing-spec-11-links.md:87). After unlinking, a child series should no longer depend on its former parent for scheduling.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A parent and child series are created (lines 290-291)
2. The child is linked to the parent (lines 293-297)
3. The child is unlinked (line 299)
4. After unlinking, there are no links for the child (lines 302-304)
5. Comment states "Child should schedule independently now" (line 301)

**Why does this specific test matter?**

Independence after unlinking is critical:
- Users need to detach series from chains
- The child should no longer be affected by parent completion times
- Scheduling should return to the series' own patterns

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the array is empty, not that a link existed before
2. It doesn't verify the link was created before unlinking
3. It doesn't verify that the child now schedules independently
4. Could pass if `linkSeries` never worked
5. Doesn't test actual scheduling independence, only link absence

It could pass when:
- `linkSeries` is broken
- `getAllLinks` is broken
- The child was never actually linked

**Why does getting it right matter?**

For medically fragile people:
- Treatment chains need to be modifiable
- Care plans evolve over time
- Series that were once dependent may need to become independent
- Incorrect independence could affect care timing

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **POST 4** - notes/testing-spec-11-links.md:87 states "POST 4: Child scheduling returns to independent"

2. **Test Plan Reference** - notes/test-plan-11.md:49 states "unlinked child independent | unlink | Child schedules independently | POST 4"

3. **unlinkSeries Signature** - notes/testing-spec-11-links.md:76 defines `unlinkSeries(childId: SeriesId): void`

4. **POST 3** - notes/testing-spec-11-links.md:86 states "POST 3: Link removed" (prerequisite for independence)

5. **LAW 4** - notes/testing-spec-11-links.md:103 states "LAW 4: getLinkByChild returns null if child has no parent"

6. **Child Scheduling Section** - notes/testing-spec-11-links.md:128-151 describes how child scheduling depends on parent - when unlinked, this no longer applies

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('unlinked child independent', async () => {
  const parentId = await createTestSeries('Parent');
  const childId = await createTestSeries('Child');

  // Create the link
  const linkResult = await linkSeries(adapter, {
    parentSeriesId: parentId,
    childSeriesId: childId,
    targetDistance: 15,
  });
  expect(linkResult.ok).toBe(true);

  // Verify child is linked (has dependency)
  const linkBefore = await getLinkByChild(adapter, childId);
  expect(linkBefore).not.toBeNull();
  expect(linkBefore?.parentSeriesId).toBe(parentId);

  // Unlink
  await unlinkSeries(adapter, childId);

  // Verify link is removed
  const allLinks = await getAllLinks(adapter);
  const childLinks = allLinks.filter(l => l.childSeriesId === childId);
  expect(childLinks).toEqual([]);

  // Also verify via getLinkByChild (LAW 4)
  const linkAfter = await getLinkByChild(adapter, childId);
  expect(linkAfter).toBeNull();

  // POST 4: Verify child schedules independently
  // Get child's schedule - should use its own pattern, not relative to parent
  const childSchedule = await getSchedule(adapter, {
    seriesId: childId,
    range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
  });
  // Child should have schedule based on its own series settings
  expect(childSchedule.length).toBeGreaterThanOrEqual(0);

  // If child has a scheduled time, it should NOT be affected by parent completion
  // Log a completion for parent
  await logCompletion(adapter, {
    seriesId: parentId,
    instanceDate: parseDate('2024-01-15'),
    startTime: parseDateTime('2024-01-15T09:00:00'),
    endTime: parseDateTime('2024-01-15T10:00:00'),  // Ends at 10:00
  });

  // Child schedule should NOT change based on parent completion
  const childScheduleAfter = await getSchedule(adapter, {
    seriesId: childId,
    range: { start: parseDate('2024-01-15'), end: parseDate('2024-01-15') },
  });
  // Schedule should remain the same (independent)
  expect(childScheduleAfter).toEqual(childSchedule);
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-unlink: `expect(linkBefore).not.toBeNull()` - Link exists
2. Pre-unlink: `expect(linkBefore?.parentSeriesId).toBe(parentId)` - Correct parent
3. Post-unlink: `expect(childLinks).toEqual([])` - Link removed
4. Post-unlink: `expect(linkAfter).toBeNull()` - getLinkByChild confirms (LAW 4)
5. Post-parent-completion: `expect(childScheduleAfter).toEqual(childSchedule)` - Child unaffected by parent

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the link was created
- Confirms link exists before unlinking
- Tests link removal via multiple methods
- Actually tests scheduling independence by checking parent completion doesn't affect child
- Cannot pass if linkSeries doesn't work
- Cannot pass if unlink doesn't truly make child independent

**What specific changes would transform this test into its ideal form?**

Add after line 297 (after linkSeries):
```typescript
// Verify child is linked before unlink
const linkBefore = await getLinkByChild(adapter, childId);
expect(linkBefore).not.toBeNull();
expect(linkBefore?.parentSeriesId).toBe(parentId);
```

Add after line 304 (after toEqual):
```typescript
// Also verify via getLinkByChild
const linkAfter = await getLinkByChild(adapter, childId);
expect(linkAfter).toBeNull();
```

Optionally add scheduling independence verification after that.

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/11-links.test.ts lines 289-318 to examine the exact violation at line 304 and full test context

3. **Search for POST 4 and independence** - Used Grep tool with pattern `POST 4|independent|unlinked.*child|child.*independent` in notes/testing-spec-11-links.md, finding:
   - Line 87: "POST 4: Child scheduling returns to independent"

4. **Search test plan reference** - Used Grep tool with pattern `unlinked child independent|POST 4|child.*independent` in notes/test-plan-11.md, finding:
   - Line 49: "unlinked child independent | unlink | Child schedules independently | POST 4"

---

## Violation #40: tests/11-links.test.ts:823

**Test Name:** `delete child cascades link`

**Violation Line:**
```typescript
expect(childLinks).toEqual([]);
```

---

### Question 1: Purpose & Importance

**What is this test actually testing?**

This test verifies LAW 20 from the links specification: "Delete child → link deleted (CASCADE)" (notes/testing-spec-11-links.md:227). When a child series is deleted, its parent-child link should be automatically removed.

**What functionality or behavior is it verifying?**

The test verifies that:
1. A parent and child series are created (lines 814-815)
2. The child is linked to the parent (line 817)
3. The child series is deleted (line 819)
4. After deletion, the link no longer exists (lines 821-823)

**Why does this specific test matter?**

Cascade deletion of links prevents orphaned data:
- Links referencing deleted series would be invalid
- Database integrity requires this cleanup
- Users shouldn't see links to non-existent series

**What are the consequences if this test is wrong or weak?**

The `toEqual([])` assertion is weak because:
1. It only verifies the array is empty, not that a link existed before
2. It doesn't verify the link was actually created
3. It doesn't verify the child was actually deleted
4. Could pass if `linkSeries` never worked
5. Could pass if `getAllLinks` always returns `[]`

It could pass when:
- `linkSeries` is broken
- `deleteSeries` doesn't actually delete
- `getAllLinks` is broken
- The filter logic is wrong

**Why does getting it right matter?**

For medically fragile people:
- Data integrity is critical for care records
- Orphaned links could cause confusion or errors
- Cascade behavior ensures clean data model

---

### Question 2: Codebase Utilization Analysis

**How is the functionality under test actually used throughout the codebase?**

1. **LAW 20** - notes/testing-spec-11-links.md:227 states "LAW 20: Delete child → link deleted (CASCADE)"

2. **Verification Strategy** - notes/testing-spec-11-links.md:290 states "Delete child → link gone"

3. **Test Plan Reference** - notes/test-plan-11.md:138 states "delete child cascades link | delete child series | Link deleted | LAW 20"

4. **Test Plan Verification Note** - notes/test-plan-11.md:232 states "Verify cascade deletes by checking links after child deletion"

5. **LAW 21** - notes/testing-spec-11-links.md:228 states "LAW 21: Delete parent → error if has children (RESTRICT)" (contrasts with LAW 20 - child deletion is CASCADE, parent deletion is RESTRICT)

6. **getAllLinks** - notes/testing-spec-11-links.md:97 defines `getAllLinks(): Link[]`

7. **deleteSeries** - notes/testing-spec-05-series-crud.md defines series deletion behavior (cascade is database-level)

---

### Question 3: Platonic Ideal

**What would the ideal version of this test look like?**

```typescript
it('delete child cascades link', async () => {
  const parentId = await createTestSeries('Parent');
  const childId = await createTestSeries('Child');

  // Create the link
  const linkResult = await linkSeries(adapter, {
    parentSeriesId: parentId,
    childSeriesId: childId,
    targetDistance: 15,
  });
  expect(linkResult.ok).toBe(true);

  // Verify link exists before deletion
  const allLinksBefore = await getAllLinks(adapter);
  const linksBefore = allLinksBefore.filter(l => l.childSeriesId === childId);
  expect(linksBefore).toHaveLength(1);
  expect(linksBefore[0].parentSeriesId).toBe(parentId);

  // Also verify via getLinkByChild
  const linkByChild = await getLinkByChild(adapter, childId);
  expect(linkByChild).not.toBeNull();

  // Verify child series exists before deletion
  const childBefore = await getSeries(adapter, childId);
  expect(childBefore).not.toBeNull();

  // LAW 20: Delete the child
  const deleteResult = await deleteSeries(adapter, childId);
  expect(deleteResult.ok).toBe(true);

  // Verify child is deleted
  const childAfter = await getSeries(adapter, childId);
  expect(childAfter).toBeNull();

  // Verify link is cascaded (removed)
  const allLinksAfter = await getAllLinks(adapter);
  const linksAfter = allLinksAfter.filter(l => l.childSeriesId === childId);
  expect(linksAfter).toEqual([]);

  // Also verify via getLinkByChild - but child doesn't exist, so null expected
  // (This might throw or return null depending on implementation)
});
```

**What assertions would perfectly verify the intended behavior?**

1. Pre-delete: `expect(linkResult.ok).toBe(true)` - Link was created
2. Pre-delete: `expect(linksBefore).toHaveLength(1)` - Link exists
3. Pre-delete: `expect(linksBefore[0].parentSeriesId).toBe(parentId)` - Correct link
4. Pre-delete: `expect(childBefore).not.toBeNull()` - Child exists
5. Post-delete: `expect(deleteResult.ok).toBe(true)` - Deletion succeeded
6. Post-delete: `expect(childAfter).toBeNull()` - Child is gone
7. Post-delete: `expect(linksAfter).toEqual([])` - Link cascaded

**How would the ideal test avoid being weak or tautological?**

The ideal test:
- Verifies the link was created successfully
- Confirms link exists before deletion
- Confirms child exists before deletion
- Verifies deletion succeeded
- Confirms both child and link are gone
- Cannot pass if linkSeries doesn't work
- Cannot pass if deleteSeries doesn't work
- Cannot pass if getAllLinks always returns []

**What specific changes would transform this test into its ideal form?**

Add after line 817 (after linkSeries):
```typescript
// Verify link exists before deletion
const allLinksBefore = await getAllLinks(adapter);
const linksBefore = allLinksBefore.filter(l => l.childSeriesId === childId);
expect(linksBefore).toHaveLength(1);
expect(linksBefore[0].parentSeriesId).toBe(parentId);
```

Add after line 819 (after deleteSeries):
```typescript
// Verify deletion succeeded
const childAfter = await getSeries(adapter, childId);
expect(childAfter).toBeNull();
```

---

### Question 4: Research Methodology

**What specific actions were taken to gather the information?**

1. **Read REPORT-SPEC.md** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/REPORT-SPEC.md (lines 1-159) to understand mandatory analysis requirements

2. **Read the specific test** - Used Read tool on /home/legion/Documents/RealmScribe/libs/autoplanner/tests/11-links.test.ts lines 810-849 to examine the exact violation at line 823 and full test context

3. **Search for LAW 20 and cascade deletion** - Used Grep tool with pattern `LAW 20|Delete child|delete.*cascade.*link|child.*deleted.*link` in notes/testing-spec-11-links.md, finding:
   - Line 227: "LAW 20: Delete child → link deleted (CASCADE)"
   - Line 290: "Delete child → link gone"

4. **Search test plan reference** - Used Grep tool with pattern `delete child cascades link|LAW 20|child.*cascade|cascade.*link` in notes/test-plan-11.md, finding:
   - Line 138: "delete child cascades link | delete child series | Link deleted | LAW 20"
   - Line 232: "Verify cascade deletes by checking links after child deletion"

---

